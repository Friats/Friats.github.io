<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Matlab基础</title>
      <link href="/2023/09/09/matlab-base/"/>
      <url>/2023/09/09/matlab-base/</url>
      
        <content type="html"><![CDATA[<h1 id="1、编程基础内容"><a href="#1、编程基础内容" class="headerlink" title="1、编程基础内容"></a>1、编程基础内容</h1><h2 id="1-1、常用变量举例"><a href="#1-1、常用变量举例" class="headerlink" title="1.1、常用变量举例"></a>1.1、常用变量举例</h2><pre class=" language-matlab"><code class="language-matlab">clear all%whos a                                            <span class="token comment" spellcheck="true">%a为变量，可以得到这个变量的基础内容</span>clear a                                            <span class="token comment" spellcheck="true">%清除a变量</span>clc                                                <span class="token comment" spellcheck="true">%清除且不保留历史记录</span>home                                            <span class="token comment" spellcheck="true">%新建变量行并不清除内容</span>t <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">:</span><span class="token number">10</span>                                        <span class="token comment" spellcheck="true">%默认间隔1的向量</span>t <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">:</span><span class="token number">0.2</span><span class="token operator">:</span><span class="token number">10</span>                                    <span class="token comment" spellcheck="true">%默认间隔为0.2的向量</span>A <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>                                <span class="token comment" spellcheck="true">%空格和逗号都可以简单的表示行元素，分号则为另起一行</span><span class="token comment" spellcheck="true">%矩阵的+-*都和变量类似，共轭转置转置'非共轭转置.’    .*按照元素相乘</span>myChars <span class="token operator">=</span> <span class="token string">'abc'</span>                                 <span class="token comment" spellcheck="true">%变量类型为字符而非字符串</span>mystr <span class="token operator">=</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">'abc'</span><span class="token punctuation">)</span>                            <span class="token comment" spellcheck="true">%此即为字符串</span>mystr<span class="token punctuation">,</span>reverse                                    <span class="token comment" spellcheck="true">%字符串倒转，字符串还可以做相加等操作</span>mycell <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">,</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token string">'abc'</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">%元胞数组</span>mystruct <span class="token operator">=</span> <span class="token function">struct</span><span class="token punctuation">(</span><span class="token string">'Name'</span><span class="token punctuation">,</span><span class="token string">'Jiang'</span><span class="token punctuation">,</span><span class="token string">'Score'</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">%结构体</span></code></pre><h2 id="1-2、脚本和函数"><a href="#1-2、脚本和函数" class="headerlink" title="1.2、脚本和函数"></a>1.2、脚本和函数</h2><pre class=" language-matlab"><code class="language-matlab"><span class="token comment" spellcheck="true">%%</span><span class="token comment" spellcheck="true">%使用双百分号可以将脚本分节</span><span class="token comment" spellcheck="true">%实时脚本：live editor</span><span class="token comment" spellcheck="true">%实时脚本可以将每行函数运行的结果放在函数下面，保存起来，观看起来更加直观</span><span class="token comment" spellcheck="true">%函数定义</span><span class="token keyword">function</span> <span class="token punctuation">[</span>m<span class="token punctuation">,</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">myFunc</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>z<span class="token punctuation">)</span>m <span class="token operator">=</span> x <span class="token operator">+</span> y <span class="token operator">+</span> z<span class="token punctuation">;</span>n <span class="token operator">=</span> x <span class="token operator">+</span> y <span class="token operator">-</span> z<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token comment" spellcheck="true">%注意文件名和函数名保持一致</span><span class="token comment" spellcheck="true">%调用</span><span class="token punctuation">[</span>a<span class="token punctuation">,</span>b<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">myFunc</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">%子函数</span><span class="token keyword">function</span> <span class="token punctuation">[</span>m<span class="token punctuation">,</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">myFunc</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>z<span class="token punctuation">)</span>m <span class="token operator">=</span> <span class="token function">myadd</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span> <span class="token operator">+</span> z<span class="token punctuation">;</span>n <span class="token operator">=</span> <span class="token function">myadd</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span> <span class="token operator">-</span> z<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">function</span> xy <span class="token operator">=</span> <span class="token function">myadd</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span>xy <span class="token operator">=</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token comment" spellcheck="true">%嵌套函数</span><span class="token keyword">function</span> <span class="token punctuation">[</span>m<span class="token punctuation">,</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">myFunc</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>z<span class="token punctuation">)</span>m <span class="token operator">=</span> <span class="token function">myadd</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> z<span class="token punctuation">;</span>n <span class="token operator">=</span> <span class="token function">myadd</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> z<span class="token punctuation">;</span>    <span class="token keyword">function</span> xy <span class="token operator">=</span> <span class="token function">myadd</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        xy <span class="token operator">=</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">end</span></code></pre><h2 id="1-3、循环体"><a href="#1-3、循环体" class="headerlink" title="1.3、循环体"></a>1.3、循环体</h2><pre class=" language-matlab"><code class="language-matlab"><span class="token keyword">for</span> ct <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">:</span><span class="token number">10</span>    <span class="token function">disp</span><span class="token punctuation">(</span>ct<span class="token punctuation">)</span><span class="token keyword">end</span><span class="token comment" spellcheck="true">%%</span>ct <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">while</span> ct <span class="token operator">&lt;=</span> <span class="token number">10</span>    <span class="token function">disp</span><span class="token punctuation">(</span>ct<span class="token punctuation">)</span><span class="token punctuation">;</span>    ct <span class="token operator">=</span> ct <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token comment" spellcheck="true">%%</span>a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">if</span> a <span class="token operator">></span> <span class="token number">5</span>    <span class="token function">disp</span><span class="token punctuation">(</span><span class="token string">'Ture'</span><span class="token punctuation">)</span><span class="token keyword">else</span>    <span class="token function">disp</span><span class="token punctuation">(</span><span class="token string">'false'</span><span class="token punctuation">)</span><span class="token keyword">end</span></code></pre><h2 id="1-4、调试"><a href="#1-4、调试" class="headerlink" title="1.4、调试"></a>1.4、调试</h2><pre class=" language-matlab"><code class="language-matlab"><span class="token comment" spellcheck="true">%可以通过去掉一些顿号来输出更多信息</span><span class="token comment" spellcheck="true">%可以在代码前面打断点，鼠标移动上去看对应的值</span><span class="token comment" spellcheck="true">%断点可以改成条件断点，右键 Set/Modify Condition    输入条件</span></code></pre><h2 id="1-5、路径"><a href="#1-5、路径" class="headerlink" title="1.5、路径"></a>1.5、路径</h2><pre class=" language-matlab"><code class="language-matlab"><span class="token comment" spellcheck="true">%调试脚本的过程中，如果脚本此时不存在当前目录下，可以将脚本对应目录在Current Folder中右键点击后选择Add to Path中的Selected Folders</span><span class="token comment" spellcheck="true">%如果此时，存在多个路径下有同名脚本，就会产生只运行最后一个加入路径中的同名脚本</span><span class="token comment" spellcheck="true">%这一项可以从Home窗口里的设置路径找到</span><span class="token comment" spellcheck="true">%还有一种方式可以使用</span>mkdir <span class="token operator">+</span>myPackage<span class="token comment" spellcheck="true">%文件夹创建好后添加一个新的同名文件，假如说叫Pack</span><span class="token comment" spellcheck="true">%调用Pack的方式很简单</span>myPackage<span class="token punctuation">.</span>Pack<span class="token comment" spellcheck="true">%即可，一定要在父目录下调用，也就是能看到myPackage的文件夹下调用</span><span class="token comment" spellcheck="true">%当然这个包可以有多级，只需要不停的mkdir +name</span></code></pre><h1 id="2、Simulink仿真环境"><a href="#2、Simulink仿真环境" class="headerlink" title="2、Simulink仿真环境"></a>2、Simulink仿真环境</h1><h2 id="2-1、Simulink介绍"><a href="#2-1、Simulink介绍" class="headerlink" title="2.1、Simulink介绍"></a>2.1、Simulink介绍</h2><p>可以在Library中寻找合适的模块，建立对应的模型</p><p>要记住，Simulink是不具备向前兼容性的，所以如果两台电脑上的Simulink版本不同。可以在</p><p>File    -&gt;    Export Model to    -&gt;    Previous Version<br>在这个窗口中就可以将模型的版本转化成过去老的版本</p><h2 id="2-1、简单模型"><a href="#2-1、简单模型" class="headerlink" title="2.1、简单模型"></a>2.1、简单模型</h2><p><img src="1.png"></p><p>以此系统为例</p><p><img src="2.png"></p><p>搭建如图所示系统，并在命令行中输入对应变量的值，方便调试，使用示波器进行观察输出</p><p>这里有个快捷键ctrl i 可以快速反转模块</p><p>将仿真时间跳到50s，可以看到仿真结果带有锯齿状，这个和求解器的设置有关<br><img src="3.png"></p><p><img src="4.png"></p><p>现在的求解器是变步长自动求解器，虽然这个功能很好用，但是，在一些场景中这类型的求解器往往都会有一定的缺点</p><p>虽然Matlab的求解其有很多，比如ode45算的很快但是可能会出现结果不稳定的情况，比如ode23s算的很慢，因为每一步都会计算一个雅可比矩阵，但是算的很稳定</p><p>这里先将步长改小再选择ode45看一下效果</p><p><img src="5.png"></p><p><img src="6.png"></p><p>现在看起来好的很多了</p><h2 id="2-2、控制器设置"><a href="#2-2、控制器设置" class="headerlink" title="2.2、控制器设置"></a>2.2、控制器设置</h2><p><img src="7.png"></p><p><img src="8.png"></p><p>以上一小节的内容为例，将这次的系统做一下修改</p><p>由于上一次制作的模型比较简单</p><p>这里将其分装起来，按下Ctrl M，调出Create Mask 窗口添加对应变量</p><p><img src="9.png"></p><p>在次窗口中添加对应变量以及提示信息还有默认值</p><p>设置完成后，再次双击模块是修改其默认值，如果要修改这个模块的内容需要点击左下角的箭头</p><p>添加Sum 和 PID Control内容，添加完成后稍微调整一下PID参数</p><p><img src="10.png"></p><p>PID的具体原理可以参考我的其他文章</p><p>由于在控制器上实现这种系统一般都是离散的，并非连续运行的，会有最小的时间参数</p><p>这里我们将系统改为连续的看一下</p><p><img src="11.png"></p><p><img src="12.png"></p><p>似乎基本看不出什么变化，这可能是应为采样率过高</p><p>我们可以从</p><p><img src="13.png"></p><p><img src="14.png"></p><p>调出高亮显示离散变量传递的路径和位置</p><h2 id="2-3、控制系统工具箱"><a href="#2-3、控制系统工具箱" class="headerlink" title="2.3、控制系统工具箱"></a>2.3、控制系统工具箱</h2><p>我们以这个引擎控制系统为例</p><p><img src="15.png"></p><pre class=" language-matlab"><code class="language-matlab">sys_engine <span class="token operator">=</span> <span class="token function">tf</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0.02</span> <span class="token number">0.2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">%传递函数构建 第一个参数是分子，第二个参数从大到小是s阶数从大到小</span>s <span class="token operator">=</span> <span class="token function">tf</span><span class="token punctuation">(</span><span class="token string">'s'</span><span class="token punctuation">)</span>sys_actuator <span class="token operator">=</span> <span class="token number">0.1</span><span class="token operator">/</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token operator">*</span>s <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">%上面这两句是另一种创建传递函数的方式</span>system <span class="token operator">=</span> sys_actuator <span class="token operator">*</span> sys_engine<span class="token comment" spellcheck="true">%级联传递函数，另一种表示方法</span>system <span class="token operator">=</span> <span class="token function">series</span><span class="token punctuation">(</span>sys_actuator <span class="token punctuation">,</span> sys_engine<span class="token punctuation">)</span><span class="token comment" spellcheck="true">%将控制器传递函数也加进去</span>sys_ctrl <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">/</span>ssys_ol <span class="token operator">=</span> sys_ctrl <span class="token operator">*</span> system<span class="token comment" spellcheck="true">%上面为开环传递函数</span>sys_cl_K1 <span class="token operator">=</span> <span class="token function">feedback</span><span class="token punctuation">(</span>sys_ol<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">%闭环系统的传递函数</span><span class="token function">step</span><span class="token punctuation">(</span>sys_cl_K1<span class="token punctuation">)</span><span class="token comment" spellcheck="true">%画出闭环传递函数的阶跃响应，从图中可以看到系统虽然是稳定的，但是响应较慢，所以我们可以通过调整K的值来使系统响应更加迅速</span><span class="token function">rlocus</span><span class="token punctuation">(</span>sys_ol<span class="token punctuation">)</span><span class="token comment" spellcheck="true">%画出开环传递函数的根轨迹图，在反曲线中选择一点如图</span></code></pre><p><img src="16.png"></p><pre class=" language-matlab"><code class="language-matlab">sys_ctrl <span class="token operator">=</span> <span class="token number">5</span><span class="token operator">/</span>ssys_ol <span class="token operator">=</span> sys_ctrl <span class="token operator">*</span> systemsys_cl_K5 <span class="token operator">=</span> <span class="token function">feedback</span><span class="token punctuation">(</span>sys_ol<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">%现在已经有了两个传递函数，我们可以使用APPs里面的Linear System Analyzer来比较(线性系统分析器)</span><span class="token comment" spellcheck="true">%打开之后点击Import ，选择对应的线性系统来比较</span></code></pre><p><img src="17.png"></p><p><img src="18.png"></p><pre class=" language-matlab"><code class="language-matlab">A <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token operator">-</span><span class="token number">2</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>B <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>C <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>D <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>sys <span class="token operator">=</span> <span class="token function">ss</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>B<span class="token punctuation">,</span>C<span class="token punctuation">,</span>D<span class="token punctuation">)</span><span class="token comment" spellcheck="true">%使用矩阵得到状态空间的模型，同样也可以获得阶跃响应Bode图</span><span class="token function">step</span><span class="token punctuation">(</span>sys<span class="token punctuation">)</span><span class="token function">bode</span><span class="token punctuation">(</span>sys<span class="token punctuation">)</span><span class="token function">tf</span><span class="token punctuation">(</span>sys<span class="token punctuation">)</span><span class="token comment" spellcheck="true">%也可以转换成传递函数</span><span class="token function">ss</span><span class="token punctuation">(</span>sys_engine<span class="token punctuation">)</span><span class="token comment" spellcheck="true">%将传递函数转换成状态空间模型</span><span class="token comment" spellcheck="true">%%</span>A <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">1</span><span class="token punctuation">]</span>B <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">%上面这个系统是不可控的，我们可以观察矩阵的秩</span><span class="token punctuation">[</span>B A<span class="token operator">*</span>B A<span class="token operator">*</span>A<span class="token operator">*</span>B<span class="token punctuation">]</span><span class="token function">ctrb</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>B<span class="token punctuation">)</span><span class="token comment" spellcheck="true">%上边是两种取得其秩的方式</span><span class="token comment" spellcheck="true">%%</span><span class="token comment" spellcheck="true">%上面的模型都是连续模型，而通常我们使用的都是离散模型，下面使用Matlab来构建离散系统</span><span class="token function">tf</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'Ts'</span><span class="token punctuation">,</span> <span class="token number">0.1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">%采样时间为0.1的模型</span><span class="token comment" spellcheck="true">%对于已经定义好的模型可以用以下方法转化</span><span class="token function">c2d</span><span class="token punctuation">(</span>sys_engine<span class="token punctuation">,</span><span class="token number">0.01</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">%这里面有对应的参数可以选取</span><span class="token function">c2d</span><span class="token punctuation">(</span>sys_engine<span class="token punctuation">,</span><span class="token number">0.01</span><span class="token punctuation">,</span><span class="token string">'zoh'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">%零阶保持器——默认</span><span class="token function">c2d</span><span class="token punctuation">(</span>sys_engine<span class="token punctuation">,</span><span class="token number">0.01</span><span class="token punctuation">,</span><span class="token string">'foh'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">%一阶保持器</span><span class="token function">c2d</span><span class="token punctuation">(</span>sys_engine<span class="token punctuation">,</span><span class="token number">0.01</span><span class="token punctuation">,</span><span class="token string">'tustin'</span><span class="token punctuation">)</span><span class="token function">d2c</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token comment" spellcheck="true">%离散后的系统还可以转换回连续系统，不过由于离散系统本身丢失了一部分信息，导致其不能完全等于原来的系统</span><span class="token function">d2d</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">%使用此函数将离散系统的采样频率改编成另一个采样频率</span>system<span class="token function">lsim</span><span class="token punctuation">(</span>system<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token operator">:</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">0.5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">%使用此函数对系统进行仿真，这里第二个输入为一列输入向量，第三个是对应输入的时间</span><span class="token comment" spellcheck="true">%除此之外还可以用另一种方式来仿真，使用ode45等求解器来仿真</span><span class="token comment" spellcheck="true">%首先定义一个函数</span><span class="token keyword">function</span> dx <span class="token operator">=</span> <span class="token function">mySystem</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token comment" spellcheck="true">%第一个必须为时间，第二个为状态向量</span>dx <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">dx</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">dx</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token comment" spellcheck="true">%保存</span><span class="token function">ode45</span><span class="token punctuation">(</span><span class="token operator">@</span>mySystem<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">%第一个输入必须加@作为句柄，第二个输入为时间区间，第三个输入为初始状态</span><span class="token comment" spellcheck="true">%运行后，就会得到系统的图</span><span class="token punctuation">[</span>t<span class="token punctuation">,</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">ode45</span><span class="token punctuation">(</span><span class="token operator">@</span>mySystem<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">%非画图，只得到对应的数据</span><span class="token comment" spellcheck="true">%阶数越高的线性系统就应该使用传递函数表示么？</span><span class="token comment" spellcheck="true">%×，高阶系统最好使用传递函数表示</span></code></pre><h2 id="2-4、简单模型建立"><a href="#2-4、简单模型建立" class="headerlink" title="2.4、简单模型建立"></a>2.4、简单模型建立</h2><p><img src="19.png"></p><p>系统有两个输入，一个是油门和方向盘，模型并未考虑不同轮子之间的动态，可以称此系统为单轮车/独轮车模型</p><p>最终模型如图</p><p><img src="20.png"></p><p><img src="21.png"></p><p>对于这个系统我们可以通过一种方式来获取他的系统传递函数，输入那里右键线性分析点-&gt;开环输入，输出那里右键线性分析点-&gt;输出测量，这两个对于系统的仿真是没有任何影响的，只是用来获取传递函数的</p><p><img src="23.png"></p><p>随后打开线性化器 linear analysis</p><p><img src="22.png"></p><p>随后使用默认的缺省设置，点击step 阶跃，等待其画出对应的阶跃图</p><p><img src="24.png"></p><p>我们可以在左边的线性分析工作区中看到我们的状态空间的对象，这个就是我们对输入输出线性化得到的结果，可以将它右键导出到工作区，然后使用tf(linsys1)，得到的结果是一个积分器，因为我们的系统油门输出到速度输出是个普通的积分关系</p><p>同样的我们也可以对模块进行线性分析，左键选中要分析的模块，在线性化器中按照图示选择，随后生成对应图谱</p><p><img src="25.png"></p><p><img src="26.png"></p><p>对于这些非线性系统，我们在不同的状态点，线性化的结果是不一样的，我们这里选的初始值是</p><p><img src="27.png"></p><p>在线性化的窗口中，我们还能选择模型的初始条件，在其中可以选择其为模型的初始条件或自己设定配平，设定后弹出对话框里可以选择参数是否已知或稳态</p><p><img src="28.png"></p><p>如果我们什么都不修改，直接点击开始配平，他就会自动帮我们计算相应的结果</p><p><img src="29.png"></p><p>以对应的结果去线性化得到的结果也是不同的</p><p>下面我们对我们现有系统做一个修改，将油门和车速做一个反馈调节，将系统初始状态的速度改为0，PID参数 1 0 0，运行看一下效果</p><p><img src="30.png"></p><p><img src="31.png"></p><p>由于这个参数是随便给定的，所以这里的效果不是很好，所以我们可以使用PID调节器去整定这个参数</p><p><img src="32.png"></p><p><img src="33.png"></p><p>在PID调节器中，拖动上面两个滑动条来得出对应的曲线和参数，调整好之后点击更新模块，就可以将参数输入进模型里了</p><p>出了使用simulink中的线性化器外，我们还可以用命令行的方式去线性化，如图</p><p><img src="35.png"></p><p><img src="36.png"></p><p>以这个策略为例，建立第一个完整的程序讲解</p><p><img src="37.png"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电池自加热</title>
      <link href="/2023/08/11/battey-heat/"/>
      <url>/2023/08/11/battey-heat/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>​        本文主要是对寒冷地区电池用电难问题的一个探讨，主要旨在了解和探讨</p><h1 id="1、自加热"><a href="#1、自加热" class="headerlink" title="1、自加热"></a>1、自加热</h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> BMS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BMS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IEC 60730 ClassB标准</title>
      <link href="/2023/08/10/classb/"/>
      <url>/2023/08/10/classb/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>储能类电器需要通过家庭用电安全标准，确保电器在使用过程中的软硬件均能安全运行，即使出现故障或失效也能在一定范围内保障用户的人身财产安全</p><p>IEC 60730标准适用的设备分成了以下三类：</p><ul><li>A类：不用于确保设备的安全性</li><li>B类：阻止受控设备上的不安全运行</li><li>C类：防止特殊危害</li></ul><p>这里本文只讨论B类安全</p><h1 id="1、认证需求资料-软硬件相关"><a href="#1、认证需求资料-软硬件相关" class="headerlink" title="1、认证需求资料(软硬件相关)"></a>1、认证需求资料(软硬件相关)</h1><p>资料清单如下：</p><p>软件设计规范：主要是功能安全需求规范以及功能安全系统的架构文件，此文件有相应示例文档，在此不多赘述</p><p>原理图Layout以及Bom</p><p>保护板Bom</p><p>关键元器件降额设计</p><p>软硬件接口文件：MCU的管脚定义、编号、功能、输入输出方向、模拟数字、信号定义等</p><p>软件编码规范：国际标准或是公司自身标准皆可</p><p>源代码或烧写代码</p><p>源代码审查报告：通过会议评审方式，对源代码中是否符合软件编码规范以及统一范式进行会议评审，通过此方式将代码整体逻辑展示，其余会议成员对表中各项示例进行分析评判，确认是否符合条例，并追加修改意见以及交付日期</p><p>软件架构设计文件：包括总体架构说明、模块调用关系、数据流、采用何种数据结构以及存储方式等</p><p>软件单元设计文件：对架构设计文件中各个模块内容做详细说明，包括流程图、调用关系、输入输出参数等信息</p><p>软件静态测试报告：静态测试主要对代码中符合编码规范部分进行统计，最终输出一个报告，包含代码行数通过率等信息，这里使用Understand即可</p><p>软件动态测试报告：动态测试主要是对软件覆盖率、测试用例通过项进行检查，最终得到一个完整的测试报告，工具会对每一个函数进行单元测试，大多数情况下都需要自己编写测试用例，这里可以使用软件：tessy、gtest和pytest</p><p>软硬件集成测试报告：这里根据功能安全需求，对各种保护、失效进行详尽的测试，如果可以尽量包含边界测试和结果</p><p>参数配置文件</p><p>通讯协议文件</p><p>故障注入测试报告：通过仿真对功能安全库的验证，包括CPU寄存器异常数据注入、CRC错误校验、时钟树偏移检测、RAM栈溢出检测要求注入之后，软件能跳入安全模式中，除此之外，还应包含失效检测等测试结果，如果有的话可以包含硬件FMEA中失效部分的注入测试</p><p>BMS产品配置管理文件：开发软件及其版本</p><p>元器件FMEA报告</p><p>电池规格书</p><p>以上只是和研发相关的一些文件例子，这里只是举例说明，完成了上述部分只是完成了功能安全的后半部分工作，前半部分则是功能安全库的移植，这里引出我们第二部分内容</p><h2 id="2、功能安全库移植"><a href="#2、功能安全库移植" class="headerlink" title="2、功能安全库移植"></a>2、功能安全库移植</h2><p>大部分芯片厂商都推出了符合功能安全内容的历程及对应的库文件</p><p>这里我们以ST的为例</p><p>目前已有多个版本</p><p><img src="1.png"></p><p>这里以G0系列为例有两种方式，其一，部分功能安全库已集成到stm32cube配置里了，可以根据需求勾选并生成，这种方式我们就不说了</p><p>这里重点说说第二种，通过手动移植的方式，这里要注意的是，我使用的版本是较为老的版本2.3.0，新版本中，对于这些内容做了优化，这里不多赘述</p><p>移植的步骤：</p><p>1、将图中内容移植到你的工程中，要注意，这里使用的都是Hal库编写，如果是其他的库，可能得自己手动实现了</p><p><img src="2.png"></p><p><img src="3.png"></p><p><img src="4.png" alt="仅移植图中选中的内容即可"></p><p>移植之后，主函数循环体前增加</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* This is where the main self-test routines are initialized */</span>  <span class="token function">STL_InitRunTimeChecks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>主函数循环中增加</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* This is where the main self-test routines are executed */</span>    <span class="token function">STL_DoRunTimeChecks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>添加完成之后，整体工程已经初见雏形，接下来需要对STL库的做一些小修改</p><p><img src="5.png" alt="删除选中部分内容即可"></p><p>如果你的程序中已经存在看门狗，去掉上面的看门狗，如果程序中没有保留</p><p><img src="6.png" alt="同一文件中"></p><p>根据硬件晶振和系统时钟树修改即可</p><p><img src="7.png" alt="同一文件中"></p><p>这里如果程序存在Bootloader，修改ROM_START的内容，这个文件到此修改完毕</p><p><img src="8.png"></p><p>此文件中复制262行开始的内容到自己的.s文件中</p><p><img src="9.png"></p><p>图示选中函数即为安全模式所属函数，一切功能安全检测失效均跳入此模块，在此模块中添加安全模式下的运行内容即可</p><p><img src="10.png" alt="同一文件中"></p><p>将自己的时钟函数替换此函数</p><p><img src="11.png"></p><p><img src="12.png"></p><p><img src="13.png"></p><p>将此文件夹下的两个中断和一个函数内容复制到自己的工程里对应位置</p><p>此时上述文件内容满足使用需求，记得删除着这些函数中打印函数和串口初始化内容</p><p>到这里，移植已经完成了一大半</p><h2 id="3、其他配置"><a href="#3、其他配置" class="headerlink" title="3、其他配置"></a>3、其他配置</h2><p><img src="14.png"></p><p>在此调整配置内容和此图一样</p><p><img src="15.png"></p><p>修改第一处鼠标选中内容的大小以及起始地址，如果第二处选中位置有报错，修改UNINIT后的大小</p><p><img src="16.png"></p><p><img src="17.png"></p><p>在这两处增加两个.ini文件</p><p>以上便是修改的全部内容，这里要注意两个事情</p><p>1、CRC校验码记得每次编译固件修改成对的值，当然也可用st移植文档中的方法去自动生成，不过测试结果表明，需要自己修改bat文件</p><p>2、如果你的程序使用了RTC，那么你可能需要做一个SRAM变量，每次上电尽早读取备份内容，以免有处初始化将备份内容清空</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> IEC60730 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IEC60730 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BMS基础知识</title>
      <link href="/2023/08/10/bms-base/"/>
      <url>/2023/08/10/bms-base/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>​        本文主要是对BMS行业内容的一个扫盲，纯属个人经历及网上资料得出的结论，如有不恰当的地方欢迎指出</p><h1 id="1、电池管理系统的需求分析"><a href="#1、电池管理系统的需求分析" class="headerlink" title="1、电池管理系统的需求分析"></a>1、电池管理系统的需求分析</h1><p>这里以电动汽车为例，用户对车辆的一个需求主要分为以下几点：</p><ul><li>车辆的动力性能</li><li>车辆的续航里程</li><li>车辆的安全性</li><li>使用过程中的便捷性</li></ul><p>这里从电池的角度上来讲</p><ol><li>车辆的动力性能可以由电池本身的最大输出功率、能量密度等来体现</li><li>车辆的续航历程可以由电池的能量密度、剩余能量估计等来体现</li><li>由于目前电车的用电压都较高，远远超出了人体的安全电压电流范畴，特别是充电过程中的电压甚至能达到600V，所以在使用的过程中，电池需要面对更为严苛的用电安全标准，包括热、寿命、穿刺失控等</li><li>使用的便利性可以体现在充电时长、能量损耗、电池寿命上</li></ol><p>这里可以将电池系统的需求列出来</p><ul><li>最大功率</li><li>剩余能量</li><li>安全性</li><li>充电</li><li>寿命</li></ul><p>上面是整车体现出对于电池系统的一个需求，而电池系统是个由电芯、铝排(汇流排)、电池管理系统、热管理、机械零部件等耦合起来的系统，而这篇文章里我们仅关注电池管理系统</p><p>对于上面电池系统中的各个需求我们也可以通过分解拆为电池管理系统的各个功能模块</p><ol><li>最大功率：电池生产出来之后，电池的最大功率其实和它自身的SOC、温度、老化状态等等相关，这个值也是一个时变的值，而我们要及时的去获取这个值，并能去控制最大功率的输出，而这也就是我们的功率控制模块(SOP)</li><li>剩余能量：电池的剩余能量和其SOC、健康状态(SOH)或能量状态(SOE)有关，这就是剩余能量管理</li><li>安全性：可以分为高压安全和通过电池状态的监控来提高电池管理系统的安全性，安全管理功能</li><li>充电：充电管理功能</li><li>寿命：SOH，可靠使用时间还有多久等</li></ol><p>由此我们得到了从整车层面上倒推回来的电池管理系统的最基本的功能，但我们还需要一些更基础的信息去实现这几个功能，这里放一个结构图：</p><p><img src="1.png"></p><p>上图中SOC作为最重要的物理量，在一些不复杂且需求并没有那么高的系统里，仅有SOC就可以满足一定的项目需求了</p><p>基于上图进行详细的展开，从基础量测量开始</p><p><img src="2.png"></p><p>普通的项目包含最左侧基础信息采样即可，后两项为针对电车上的</p><p><img src="3.png"></p><p>中间层，部分项目仅包含SOC即可，通过SOC计算剩余能量，这里左边四个量均解释过，这里就不再赘述</p><p>关于电池温度这里稍微提一下，正常项目采集的电池温度均为电池表面温度，而电池在使用过程中，内部温度会高于表面温度，部分场景中可以看到电池放电停止了，但是表面温度偶尔还会上升的情况，所以对于一些要求严格的产品来说，仅测量电池表面温度是不对的，还要根据电池的热特性模型取计算电池的内部温度</p><p>微短路，在电池生产过程中参杂或是锂富集、刺穿会导致电池产生漏电流，长时间的漏电流会导致电池自身漏电流逐渐增大，会有过热失控的风险</p><p>上述两个技术都不是非常成熟的技术，但相信在不久的将来，这两项技术能真正的行之有效的应用起来</p><p><img src="4.png"></p><p>均衡管理：由于电芯自身内阻、老化时间、焊接工艺等影响，电芯本身放电或充电过程中，能量差距逐渐累积，最终导致不同电芯能量能量差距较大，这对整体电池包来说并不是一件好事，并且长时间处于此种状态下电池会有报废风险，所以这里需要让高电量电芯的能量释放出去或是充给低电量电芯中，前一种是我们说的被动均衡，后一种则是主动均衡，对于主动均衡也存在很多种策略，包括均衡在电芯一致性达到什么样的条件下开启、开启后的持续时、所使用的均衡电流大小、均衡开启通道数等</p><p>热管理低温加热部分，会有另外的文章分析，这里不做赘述</p><p>充放电管理：通过当前温度、SOC、一致性、老化程度等计算出合适的充放电功率，并且上报给车机</p><p>继电器控制：异常状态下的充放电切断，如预充放电(防止大电压直通)、Mos失效等</p><p><img src="5.png"></p><p>通讯分为板内板外，Bms和采集系统如果是一块板，就是板内通讯，如SPI，板件一般是通过CAN或LIN</p><p>故障处理：一般故障分为多级</p><p><img src="6.png" alt="模块关系图"></p><p>其中有一点要注意，部分电池的电流控制是通过外部整车或者整机端来实现的，并非是通过电池本身实现的</p><p><img src="7.png" alt="模块关系图"></p><h1 id="2、BMS数据收集"><a href="#2、BMS数据收集" class="headerlink" title="2、BMS数据收集"></a>2、BMS数据收集</h1><h2 id="2-1、电芯数据"><a href="#2-1、电芯数据" class="headerlink" title="2.1、电芯数据"></a>2.1、电芯数据</h2><p>在BMS开发过程中，所有的功能都需要依赖于原厂提供的电芯数据(或是公司测试的数据，这个一般都会有公司自己测试的数据)</p><p><img src="8.png"></p><p>这里列举所有需求的数据，大体可以分为两类，一类基础数据用于计算SOC、SOE、SOH等数据，另一类高级数据则是用来建模以及提高模型精度的</p><p>接下来会对各个部分所需数据做一个详细的说明：</p><p>充放电截止电压表：</p><p><img src="9.png"></p><p>此表可以让工程师知道高温、低温下电池的截止电压，用于标定或矫正SOC，还可以作为欠压故障或预警的参考值</p><p>表中分为持续电流和脉冲电流两种情况，在复杂系统中，可以根据当前放电状态来查询不同表格获取值</p><p>这里有两个计算公式，并不确定是否是完全正确的：</p><p>Pdsgmax = (ocv - umin) * umin/R        物理量定义：umin最小端电压，R内阻</p><p>Pchgmax = (umax -ocv) * umax/R        物理量定义：umax最大端电压，R内阻</p><p>SOC-OCV关系表：</p><p><img src="10.png"></p><p>此表格只是用于示例的充电表格，还有对应的放电表格</p><p>表格可以将电池各温度各老化程度下的SOC统计出来，最终画出一幅包络曲线或散点图，电池静置合适的时间之后可以通过用当前情况下的开路电压对比SOC-OCV表去获得当前SOC，用于修正目前SOC计算偏差或是直接使用</p><p>SOC = SOCocv + 电流积分/总容量</p><p>一般开机就是以此为基准，求得SOC的，当然这是普通算法的用法，对电池建模的过程中，电池可以等效成一个开路电压源串上一个电阻还有一个电阻和电容的并联形式，而这个电压源就是由SOC-OCV得出的</p><p>当然此表格是非常复杂的，如果只是简单的储能项目或者是家用电器，不用这么麻烦，仅需要一个常温下的SOC表格即可，变温部分用其他办法修正</p><p>电池内部温度可以用这个公式算：Bernadi方程。发热功率q=I<em>（ocv-u）+I</em>T*du/dt    I当前电流，T当前温度，u当前电压，OCV使用SOC查表得到的</p><p>最大充放电电流限制表：</p><p><img src="11.png"></p><p>此表一般是厂家提供，当然也可以自己测试一个，不过不是很准就是了</p><p>充放电最大电流和当前温度SOC还有充放电形式有关，使用过程中及时查表更新</p><p>电池容量特性：</p><p><img src="12.jpg"> </p><p>主要是通过温度充放电倍率、循环次数测得一个容量参数</p><p>自放电率：</p><p><img src="13.png"> </p><p>主要是和SOC、温度、时间有关，用来精确电池自放电内容，提高SOC和SOE的准确度</p><p>一般温度SOC越高，自放电率越大</p><p>如果电池在静置自放电过程中，我们测得的自放电率高于表格中的自放电率就可以判定出是否有微短路或者失效</p><p>以上就是基础的五个数据及对应图表</p><p>HPPC测试原始数据：</p><p><img src="14.png"> </p><p>HPPC数据主要是由脉冲放电以及脉冲充电测得的，一般来说测试一个放电的HPPC就足以满足一些精度不那么高的项目需求</p><p>此原始数据可以使用Matlab中示例程序进行拟合获取模型</p><p><img src="15.png"> </p><p>将红框中的数据内容改为自己的HPPC结果就行，运行即可得到对应的模型数据</p><p><img src="16.png"> </p><p>程序会使用1-3阶等效模型，并通过单次脉冲得到的电压跌落以及恢复稳态图去做局部最优解，然后通过多次局部最优解</p><p><img src="17.png"> </p><p>随后根据获取计算误差调整参数，获得全局最优解，最后输出一个电池的Simulink模型：</p><p><img src="18.png"> </p><p>一般考虑到运算平台的算力以及模型计算结果的重合度，取三阶模型即可</p><p>说回正题，继续来看HPPC图表的内容</p><p>图中的测试，在单个充放过程中，首先会有一个短时的充电脉冲，然后静置一段时间，再有一个放电脉冲，放电脉冲结束后，进行一个小电流充电去调整SOC，然后继续静置————经过这一轮之后就得到了电池的整体动态特性的原始数据</p><p>连续多次之后，就可以的出一个类似SOC-OCV的趋势模型</p><p>放电脉冲过程中，电压表现出来的现象可以由其内阻、感性、容性共同解释，这个后续单开章节描述</p><p>交流阻抗数据：</p><p><img src="19.png"> </p><p>这个测试其实和HPPC测试比较类似，只是HPPC是时域分析数据，交流阻抗则是频域分析</p><p>这里需要注明，交流阻抗测试数据是使用小的交流电，从0.1hz - 100khz类似范围扫频得到的结果，这里这种方式和环路分析仪比较类似，得到的数据包括但不限于阻抗特性图和伯德图等</p><p>为什么要用小的交流电呢，因为电池只有在小交流激励的时候才可以看作是一个线性系统，才可以研究它的输入和输出的相位角、幅值关系</p><p><img src="20.jpg" alt="上面说的这种方法即为电化学阻抗测试也就是EIS"> </p><p>这里列举一下阻抗的定义，给被测系统G(w)输入一个扰动函数X，我们会得到一个响应信号Y，将公式写出可以得到：</p><p>Y = G(w)X</p><p>我们这里测试输入的是正弦电流信号，所以输出的Y也是正弦电势信号，此时G(w)就是频响函数，即为系统的阻抗用Z来表示，当然如果X为正弦电势信号，那么Y就是正弦电流信号，此时G(w)就是被测系统的导纳，用Y来表示<br>导纳和阻抗统称为阻纳，用G表示，阻抗于导纳为倒数关系，Z=1/Y</p><p>由于G是一个随w变化的函数(w为角频率，通常取w=2Πf)，所以我们通常用复变函数表示：</p><p><img src="21.jpg"> </p><p>回到我们这节开头的图，左边这张交流阻抗侧视图，越往右边，频率越小，越往左边频率越大，图像与横轴的交点为电池的欧姆阻抗，这张图其实有很多的看法，这里举个标准的例子<br><img src="22.jpg"> </p><p>这张标准图谱非常详细的描述了各种阻抗，其中：</p><ul><li>横坐标Zre为阻抗的实部，Zim为阻抗的虚部</li><li>第一部分超高频部分，阻抗与横轴的交点为欧姆阻抗Rb</li><li>第二部分高频部分，半圆指的是锂离子通过电解质阻抗Rsei</li><li>第三部分中频部分，半圆指的是电荷的传递阻抗，也称电极极化阻抗Rct</li><li>第四部分低频部分，45°直线指的是锂离子扩散阻抗，也成为浓差极化阻抗W</li></ul><p>最终电池的阻抗测试结果可以等效出来一个等效电路模型</p><p><img src="23.jpg"> </p><p>这里为防止混淆，对几个关键变量的内容做一个详细说明</p><p>Cdl：工作电极于电解质之间电容</p><p>Csei：界面电容通常每个界面都会存在一个电容</p><p>CPE：相位角原件，主要包括，扩散阻抗W、电感L等</p><p>这里没找到合适的伯德图</p><p>增益和相位常常用来描述系统的稳定性，而在电池的伯德图中</p><p>增益代表：增益描述系统输入输出之间的信号比例关系，表示输出信号经过系统之后的放大或衰减程度，增益越大和越小都会影响系统的稳定，增益过大系统容易出现震荡，增益过小系统容易出现误差，增益越大系统的响应速度越快，反之越慢；适当的增益可以抑制干扰</p><p>相位代表：相位描述系统的输出是否同步，通常相位角为0时系统的输出与输入同步，相位角不为零代表系统输出会有超前或滞后现象；描述系统的稳定性时，通常会用相位裕度一词来特指能够容忍的相位差，相位裕度越大，系统对外部干扰和参数变化的鲁棒性就越强，一般采取相位角-90°为宜；</p><p>这里举两个关于电池的增益和相位对系统的输出关系例子：</p><p>增益：这个很好理解，增益越大，表现出来越像是放大器，增益越小表现出来越像一个衰减器，增益等于零类似于传输线路或者连接器</p><p>相位：当相位角越大时，对应输出信号有很大的相位延迟，代表电池往往更加呈现出电感性质，电感对电流的变化响应有一定滞后</p><p>当相位角越小时，对应输出信号有较小的相位延迟或超前，代表电池往往呈现出电容性质或电导性质，电容对电流的响应速度较快</p><p>当相位角趋于零或等于零时，输入输出信号没有相位差，代表电池往往呈现出电阻的心智，没有电感和电容的影响</p><p>暂时先分析到这里</p><p>除此之外，它还有一个非常重要的部分，不同温度、SOC、老化情况下，电池表现出来的阻抗特性曲线是不一样的，这里有一个小的猜想，如果再BMS上集成一个用来测量交流阻抗的小模块或设备，就可以通过阻抗测试结果来倒推我们的SOC、老化次数、温度</p><p>充放电温升特性数据：</p><p><img src="24.png"> </p><p>左图是脉冲充放电过程中的一个变化，后面是恒流恒压充放电过程中，前充电，后放电</p><p>深蓝色内部温度，浅蓝色外部温度，差距接近10℃</p><p>从图中可以看出工况不一样的时候温升变化不同</p><p>脉冲充放电会最终达到一个热平衡，而恒压充放电也会，但可能这个热平衡的温度会很高很高，所以可以看成不会热平衡</p><p>这次测试是通过测试极耳温度来近似测试的，但是实际上内部温度会比极耳温度更高</p><p>如何使用呢，用热特性数据建立成热模型，然后再将其中参数等效成热阻之类的，最终变成电特性模型，可以用来计算电池内部温度，来为电池的安全服务</p><p>普通项目中使用表面温度看成内部温度即可，用于温度修正或安全相关</p><p>以上就是所有的需求数据，高级数据一般都是原始数据并且不能直接使用，只能应用在模型中用来修正计算出的SOC、SOH、SOP等内容</p><h1 id="3、硬件环境"><a href="#3、硬件环境" class="headerlink" title="3、硬件环境"></a>3、硬件环境</h1><h2 id="3-1、硬件系统种类"><a href="#3-1、硬件系统种类" class="headerlink" title="3.1、硬件系统种类"></a>3.1、硬件系统种类</h2><p>一般分为分布式和集中式系统</p><p>首先可以看一下分布式的系统</p><h3 id="3-1-1、分布式系统"><a href="#3-1-1、分布式系统" class="headerlink" title="3.1.1、分布式系统"></a>3.1.1、分布式系统</h3><p><img src="25.png"> </p><p>整体分为局部控制器和整体控制器，或CMU和BCU名称不同而已</p><p>早期通讯方式是RS485，现在已经变成CAN，图中连接方式是普通并行网络，现在还有一种菊花链，就是每个模块首尾相连，最终由最后一个局部控制和主控相连</p><p>LECU：主要负责采样，如单体电压、温度的采集，以及单体均衡控制</p><p>CECU：电流采样、总体电压采样，对整体系统进行管理，还有一些绝缘电阻、高压回路监控等等；主要是负责整体电池组的管理和控制</p><h3 id="3-1-2、集中式系统"><a href="#3-1-2、集中式系统" class="headerlink" title="3.1.2、集中式系统"></a>3.1.2、集中式系统</h3><p><img src="26.png"> </p><p>所有的功能由单一的ECU实现，线束非常复杂，没有内部通讯，适用于电池比较少的应用，如平衡车滑板车之类的项目上</p><h2 id="3-2、常见输入输出接口"><a href="#3-2、常见输入输出接口" class="headerlink" title="3.2、常见输入输出接口"></a>3.2、常见输入输出接口</h2><p><img src="27.png"> </p><p><img src="28.png"> </p><p><img src="29.png"> </p><p>这个在做功能安全里会用到，并且里面冗余的部分也是功能安全要求的</p><h2 id="3-3、均衡设计"><a href="#3-3、均衡设计" class="headerlink" title="3.3、均衡设计"></a>3.3、均衡设计</h2><p>在充电和放电的过程中，会出现个别电芯先充满或放空，而其余电芯仍需要充电或仍存在一定能量，这时候我们就需要做一些均衡措施，保证电芯电量一致，防止出现安全问题或是减缓电池老化</p><h3 id="3-3-1、被动均衡"><a href="#3-3-1、被动均衡" class="headerlink" title="3.3.1、被动均衡"></a>3.3.1、被动均衡</h3><p>被动均衡的原理通常是通过均衡电阻将最多电芯的能量通过电阻加热去耗散出去，这种设计需要考虑均衡电阻的功率还有发热问题</p><p><img src="30.png"> </p><h3 id="3-3-1、主动均衡"><a href="#3-3-1、主动均衡" class="headerlink" title="3.3.1、主动均衡"></a>3.3.1、主动均衡</h3><p>主动均衡通常是通过计算电芯能量差距，通过均衡电路，将高电量电芯能量冲入低电量电芯中，达到最终能量一致的情况，这种方法的能量损失更少</p><p><img src="31.png"> </p><p>整体方案对比</p><p><img src="32.png"> </p><h1 id="4、软件环境"><a href="#4、软件环境" class="headerlink" title="4、软件环境"></a>4、软件环境</h1><h2 id="4-1、软件框架"><a href="#4-1、软件框架" class="headerlink" title="4.1、软件框架"></a>4.1、软件框架</h2><p><img src="33.png"> </p><p>一般软件里是这样的，通常都会采用分层结构，分为硬件抽象层(寄存器驱动封装)、服务层、应用层</p><p>Bms还存在Bootloader，用于程序刷新或下载，重启后第一时间运行此模块，而后检测无故障开始刷新程序</p><p>随着现在技术和流程的迭代更新，有Autosar、MBD等根据模型开发的方式，通过Matlab去建模通过测试后生成代码，运行在硬件平台上</p><p><img src="34.png"> </p><p>上图是电池管理系统的和核心算法结构，通过有限的采样数据来计算出我们需要的数据</p><h2 id="4-2、SOC估计模块设计"><a href="#4-2、SOC估计模块设计" class="headerlink" title="4.2、SOC估计模块设计"></a>4.2、SOC估计模块设计</h2><p><img src="35.png"> </p><p>上图使用的是最简单的SOC估计算法，SOC就等于SOC0加上电流的积分除总容量，</p><p>这个算法需要注意</p><p>温度对SOC的影响、电芯一致性的影响、末端的修正(保证充电末端以最高电芯为准充满，放电末端以最低电芯为标准放空)、电池故障(单体欠压就得让SOC等于零，与末端修正类似，但这里是单电芯存在故障时)</p><p>这里面的delta SOC为此次行车过程中的消耗量</p><p><img src="36.png"> </p><p>这里将其中的一个模块拿出来看看，SOC仲裁模块就是用来做末端修正用的，SPCrordEN SOC记录模块，关机时SOC时间等信息的记录</p><p><img src="37.png"> </p><p>将初始化模块拿出来，详细分析</p><p>静置时间主要是用来判断，是否是达到了开路电压所需时间，如果达到了就可以使用开路电压，没达到就使用保存的数据来初始化</p><p>滞回因子是SOC和OCV之间再充放过程中不是一条单独的线，即使是三元电池也不是，两条线首尾相同中间相交，他和上一次累积的SOC变化量有关</p><p>由于SOC不能跳变，所以显示SOC要向着真实SOC去趋近</p><p><img src="38.png"> </p><p>温度和老化对SOC的影响主要在容量上，所以在进入此模块的时候就要对他的总容量进行修正</p><p>根据工作电流，每一步都算一次SOC变化量，这里如果是简单项目，只需要单独做电流积分然后加上就可以，没必要每一步都计算</p><p>考虑完上述两项之后，这里要对电芯一致性做一些处理，主要是对最大单体和最小单体SOC做一个处理</p><p>通过一致性的数据来处理整包的SOC，这里可以通过电流方向做一个处理，当充电的时候，拟合一条向着最大SOC趋近的曲线，而放电的时候则也是通过同样的曲线向着放电SOC的值去趋近，如果是简单项目不用考虑这么多，充电取高，放电取低就行<br>最后，进行SOC仲裁，显示SOC和真实SOC分离</p><p>SOC本身不是一个科学问题，尤其是在电池包的级别上，无法获取精确值，谈精度是没有意义的，只需要让显示SOC让用户看着合理即可</p><p><img src="39.png"></p><p>记录模块很简单就不多赘述了</p><h2 id="4-3、SOP估计部分"><a href="#4-3、SOP估计部分" class="headerlink" title="4.3、SOP估计部分"></a>4.3、SOP估计部分</h2><p><img src="40.png"></p><p>首先，SOP是通过在线内阻计算来获得的</p><p>P = (umin)(ocv - umin)/r</p><p>可以通过瞬时放电的delta u和delta i来计算出来瞬时内阻，最终算出来一个瞬时SOP，当然这里可以使用等效模型的方法来计算</p><p>这个模块需要考虑三点一个是温度、一个是故障限功率还有一个一致性的问题</p><p><img src="41.png"></p><p>SOP调度模块、内阻计算模块、最大电流计算模块、降功率模块、功率预测模块</p><p><img src="42.png"></p><p>调度模块图</p><p><img src="43.png"></p><p>内阻计算模块图</p><p><img src="44.png"></p><p>功率预测模块</p><p>其余SOH之类内容后续在讨论，这里就就不做过多讲解了</p><h2 id="4-4、均衡模块"><a href="#4-4、均衡模块" class="headerlink" title="4.4、均衡模块"></a>4.4、均衡模块</h2><p><img src="45.png"></p><p>这里是均衡模块策略，主要是均衡模块何时开启，开启哪几个通道，均衡具体时常等信息</p><p><img src="46.png"></p><p>模块内部细分</p><p><img src="47.png"></p><p>根据当前状态去判定是否开启均衡，包括温度、最大最低单体电压、系统运行状态、充放电电流</p><p><img src="48.png"></p><p>计算均衡的目标电压，图中无序列表里的第一条最高应该改成最低</p><p>上面这些参数根据项目具体情况来选取，</p><h2 id="4-5、预充预放回路"><a href="#4-5、预充预放回路" class="headerlink" title="4.5、预充预放回路"></a>4.5、预充预放回路</h2><p>此部分在储能设备、电车上使用比较多，由于电池如果瞬间开启，输出端电容电压较低时，一瞬间会有非常大的瞬时电流，所以为保证器件正常工作以及安全考虑，在使用过程中尽量使用预充预防回路，这里就不多赘述了</p><h2 id="4-6、标定量"><a href="#4-6、标定量" class="headerlink" title="4.6、标定量"></a>4.6、标定量</h2><p><img src="49.png"></p><p>主要是用于BMS正常工作所需内容，包括电芯本身特性(电压电流容量等)，保护参数以及恢复参数，电池计算算法所需数据</p><p><img src="50.png"></p><p>这里如果不是使用模型去计算SOC，而是通过普通开路电压法和安时积分法来计算的话，最好还是需要末端修正参数等参数，使得SOC表现出较为正常的内容，同样的均衡内容也是类似的，需要对应的均衡设计参数</p><h2 id="4-7、故障类别"><a href="#4-7、故障类别" class="headerlink" title="4.7、故障类别"></a>4.7、故障类别</h2><p>一般除了为了安全考虑的故障外，还存在为了系统能正常运行而存在的失效故障检测</p><p><img src="51.png"></p><p><img src="52.png"></p><p><img src="53.png"></p><p>失效一般包括：采样传感器故障(电压电流温度采样失效等)、控制器本身故障(寄存器数据异常、Flash单bit反转、栈溢出、时钟频偏、死机等)、电池系统故障、通讯总线故障(CAN、485、Lin等)</p><p>为了应对并保证系统能最大程度上的持续运行，一般会对故障进行分级</p><p><img src="54.png"></p><p><img src="55.png"></p><p>故障计时和其置位恢复逻辑，可以从上面的图中看到，故障的计时是会根据条件逐级计时，只有故障真实保持时间达到了，才会报警</p><p>故障检测的架构</p><p><img src="56.png"></p><h2 id="4-8、硬件拓扑"><a href="#4-8、硬件拓扑" class="headerlink" title="4.8、硬件拓扑"></a>4.8、硬件拓扑</h2><p><img src="57.png"></p><p>特点</p><p>成本更低</p><p>线束复杂，线束成本高</p><p>灵活性更低</p><p>可靠性需求更高</p><p><img src="58.png"></p><p>特点，</p><p>分工明确，节点清晰</p><p>整个系统的成本较高</p><p>线束可以简化</p><p>灵活性更高</p><p>可靠性需求更低</p><p><img src="59.png"></p><p>主控主要完成软件部分的内容，包括状态估计、功率能量管理</p><p>其中高压模块变成了个新的控制器，包括很多高压检测继电器等控制</p><h2 id="4-9、内部通讯"><a href="#4-9、内部通讯" class="headerlink" title="4.9、内部通讯"></a>4.9、内部通讯</h2><p><img src="60.png"></p><p>这里分为两种通讯方式，一种CAN主从式总线方案，另一种SPI菊花链自上而下传输数据的方式，但是其本身稳定性有待商榷，所以又引入了最右侧总线方案</p><p>总线节点过多时菊花链本身可靠性不高</p><p>CAN总线的可靠性高，但成本高</p><h2 id="4-10、硬件关键器件"><a href="#4-10、硬件关键器件" class="headerlink" title="4.10、硬件关键器件"></a>4.10、硬件关键器件</h2><p><img src="61.png"></p><p>早期都是使用分立元件做电池采样的，不过随着技术进步，分立元件的方案在采样时间、精度、还有本身成本上已经不占据优势了</p><p><img src="62.png"></p><p><img src="63.png"></p><h2 id="4-11、软件架构"><a href="#4-11、软件架构" class="headerlink" title="4.11、软件架构"></a>4.11、软件架构</h2><p><img src="64.png"></p><p><img src="65.png"></p><p><img src="66.png"></p><h2 id="4-12、核心算法"><a href="#4-12、核心算法" class="headerlink" title="4.12、核心算法"></a>4.12、核心算法</h2><h3 id="4-12-1、SOC估计算法演变"><a href="#4-12-1、SOC估计算法演变" class="headerlink" title="4.12.1、SOC估计算法演变"></a>4.12.1、SOC估计算法演变</h3><p><img src="67.png"></p><p><img src="68.png"></p><p><img src="69.png"></p><p><img src="70.png"></p><h3 id="4-12-2、SOC估计基于模型的算法"><a href="#4-12-2、SOC估计基于模型的算法" class="headerlink" title="4.12.2、SOC估计基于模型的算法"></a>4.12.2、SOC估计基于模型的算法</h3><p><img src="71.png"></p><p><img src="72.png"></p><p><img src="73.png"></p><p><img src="74.png"></p><p><img src="75.png"></p><p><img src="76.png"></p><p><img src="77.png"></p><h3 id="4-12-3、SOC建模及状态估计"><a href="#4-12-3、SOC建模及状态估计" class="headerlink" title="4.12.3、SOC建模及状态估计"></a>4.12.3、SOC建模及状态估计</h3><p>电池在实际工作的时候，在一定的工作环境下，电池放出电流过程中会产生对应的响应，这些响应决定了他的温度、电压发生变化</p><p>我们的电池模型在同种工况和电流下，会产生对应的电压和温度数据，而我们去测量电池当下时刻的电压和温度数据，就可以得到我们模型和实际工况下的误差，而这个误差可以用来修正模型的参数和输出状态量</p><p><img src="78.png"></p><p>电池模型主要分为三类：电特性模型、热特性模型、老化（寿命）特性模型</p><p><img src="79.png"></p><p>电池电特性模型可以分为两类</p><p>第一类是电池的机理模型：从电池内部的工作过程以及原理，来描述电池在放电过程中内部的一个变化，包括锂离子电子运动的过程，从固相里面扩散到界面表面处发生化学反应得失电子，再到电子通过外电路到达另外一极，离子通过电解液通过隔膜到达另外一极，离子和电子在另外一极的固液项的界面处发生电化学反应，在嵌入到另外一极固态颗粒里面去的扩散过程，所以描述的就是一个物理和化学的过程，它把电池简化为正极、负极、隔膜、电解液的结构，活性颗粒简化为一个个圆形的颗粒，活性的li就是在这个圆形颗粒里达到扩散的过程 ，模型的精度较高，可以分析出电池在充放电过程中内部的变化过程，包括电导率、颗粒半径、电动势对内部的影响，或是老化积锂等</p><p>第二类是电池的等效电路模型(ECM)：经验模型，主要描述电池的VI特性(外部模型)，在一定的电流下，模型输出的端电压要和电池的端电压保持一致；主要拟合好在某个电流下的端电压响应，理论上说RC环节越多他计算出的精度就越高，后续再详细分析</p><p>右侧Uw，韦伯阻抗，上面的模型不加韦伯阻抗是线性模型，加了是非线性模型</p><p><img src="80.png"></p><p>两个模型其实有一定的对应关系</p><ul><li>比如正负极离子浓度决定了正负极的电动势，电动势之差就是端电压、</li><li>固相里的离子浓度和SOC有关</li><li>欧姆阻抗主要是和离子在电解液中的迁移、电子通过集流体和电解液形成的阻抗有关</li><li>活性锂在界面处得失电子发生化学反应的过程、离子在电解液中的扩散、离子在固相颗粒里的扩散共同形成了极化内阻也就是RC环节，而RC其对应的时间常数也不相同，时间常数较小的描述得失电子过程，低频阻抗对应时间常数比较大的环节，如固相颗粒里扩散的过程（严格意义上来说，RC环节是不能完全描述出这个扩散过程的，所以需要加上韦伯阻抗，而韦伯阻抗是非线性的，描述它的时域表达式是比较麻烦的，所以一般都是近似拿掉的，而模型所产生的误差有部分来源于此）</li></ul><h4 id="4-12-3-1、电化学模型"><a href="#4-12-3-1、电化学模型" class="headerlink" title="4.12.3.1、电化学模型"></a>4.12.3.1、电化学模型</h4><p><img src="81.png"></p><p>这个模型是详细描述充放电、静置过程中内部的一系列的物理和化学过程，简单来说大部分都是物理的过程，而化学部份主要在界面处得失电子这样的部分，其他的都是迁移和扩散，真正描述电化学反应的只有一个过程，其他的要么是电荷守恒的，要么是质量守恒的</p><p>这一系列的过程都是通过偏微分方程描述的</p><p><img src="82.png"></p><p>上面的理论方程来源于多孔电极理论，………….(施工完善中)</p><h4 id="4-12-3-2、等效电路模型-ECM"><a href="#4-12-3-2、等效电路模型-ECM" class="headerlink" title="4.12.3.2、等效电路模型(ECM)"></a>4.12.3.2、等效电路模型(ECM)</h4><p><img src="83.png"></p><p>模型中第一部分是我们的开路电压(OCV)，而开路电压一般存在一个滞回特性(Hysteresis)，这里图中不加滞回特性的OCV和SOC是一一对应的，而正常使用过程中，是要加上滞回特性的OCV，加上之后其和SOC并不是一一对应的关系，这个后续介绍</p><p>可以通过这个模型可以反推SOC，但是一般输出的模型是有一定误差的，所以一般会将其和电流累计合在一起</p><p>阻抗特性模型由欧姆阻抗加上RC环节的极化阻抗，这些阻抗在电流脉冲下会有一个直流内阻，两个RC环节表现出来的电阻值会和当前电流的持续时间有关，而这个直流内阻可以用来计算电池的功率特性，同样的，电池在使用的过程中存在一定的老化，老化后电池的最大容量输出功率也会下降，而这个下降也是由于内阻的变化导致的，我们可以通过这个模型将阻值算出来也可以反推SOH</p><p>模型为线性模型且计算量较少结构简单易于实现，如果参数都是不变的他就是一个线性时不变系统，虽然模型简单，但应用较为清晰</p><p>对于时间尺度上来讲，瞬态下、相对稳态、整个生命周期上</p><p>瞬态(Transient)主要指的就是它的SOC、功率特性的变化，这些和当前的充放电电流有很大的关系，描述主要靠阻抗特性来描述</p><p>相对稳态(Long Term)和电流的历史工况的累计有关，既然是累计那算是一个积分的过程，如果把电流的累计和电池的自放电，得到的就是电池的SOC</p><p>整个生命周期(Life time)电池在使用的过程中，和他的充放电历史温度等等决定的是电池的老化，可以用来做SOH的内容</p><p><img src="84.png"></p><p>左边这幅图横轴是SOC，纵轴是开路电压，上面是锰酸锂，下面是磷酸铁锂的，理想状态下，只要测到一个开路电压就有一个唯一对应的SOC，但实际情况下并非如此</p><p>右图是一个滞回特性的相关图，图片中两条线，上面是每充电5%停下来的电压曲线，下面是每放电5%停下来的曲线，从这个图可以清晰地看出来，充电和放电的开路电压是不一样的，这个对应的误差就是滞回特性</p><p>如果只是固定的滞回特性算是非常简单的，但实际情况下，如果冲到某个SOC之后开始放电，他并不是直接掉到下面那条线的样子，而是像放大图片中的样子，会经过一个过程，如果我放电的过程中突然停下来，我是不知道他停在哪一个地方了，它在这个区间内的任何一个点都有可能，他和之前的历史数据有关系，这个算是磷酸铁锂电池做SOC估计非常困难的原因之一，还有一个就是开路电压非常平坦，它还有很强的滞回特性</p><p>这个滞回现象和磁滞回现象非常相似，在建模的时候可以参考</p><p><img src="85.png"></p><p>其中两个RC环节的表达式书写的过程是一样的，对于一个任意的RC环节，他的阻抗就是R和1/Cs并联，计算化简一下就是R/(1+RCs)，这样就得到了电压和电流的关系，Udl和Udiff其实就是某一个电流激励下它的电压响应，这里书写的是传递函数的表达式，在时域中还要考虑它的初始状态</p><p><img src="86.png"></p><p>这个模型是否合理，我们可以根据时域和频域两个角度来分析</p><p>横轴实部阻抗纵轴虚部阻抗</p><p>时域中在电流施加的一瞬间，端电压会有一个响应，这个响应会有一个瞬时变化U1，其次在电流持续过程中，电压有一个持续的变化U2<br>U1为欧姆阻抗，U2长得很像指数变化，在线性系统中，描述指数变化的一节网络为A/(1+TAOs)，TAO为时间常数，此环节就是RC环节，实际上这里的应该是非常多的RC环节累加在一起，考虑到模型的性能要求一般情况下我们就采用两到三阶RC环节</p><p>频域中对电池进行一个扫频激励，Z(jw) = u(jw) / I(jw)，上面是电压响应，下面是电流激励，左图为测试出来的奈奎斯特图，越往右频率越低，越往左频率越高，中频段呈现出一个半圆形，从系统的层面上讲，一阶系统呈现出来的就是半圆形，也就是A/(1+TAOs)，传递函数为A/(1+TAO(jw))，我们用一个一阶RC环节描述这个半圆，低频部分其实也是一个半圆，不过他的时间常数比较大，这里我们可以用一个时间常数比较大的RC环节来拟合，虽然时间常数比较大，但是也不能做到无穷大，所以实际拟合出来的参数还是有一定差异的，而左侧有一个虚部为零的点，也就是我们的欧姆阻抗，再往左有一个接近九十度的线，其实这个是我们的电感，用来描述高频特性，实际上我们在使用电池的过程中，是不可能达到这么高的(忽略)，但是在某些情况下是会达到的(高频自加热)</p><p>通过上面的分析将时域模型和频域模型结合起来的，不过如果用频域方法和时域方法分别得到其模型的参数，最终会有一定的差异，差异的原因</p><ul><li>其中一个是欧姆阻抗，频域中确定出来的参数一般比时域中小，是因为在时域中，电流不可能是完美突变上去的，所以有一个斜率和采样周期问题，时间的延迟导致算出来的欧姆阻抗会偏大，其中会包含一些低频阻抗</li><li>第二个原因是在时域做脉冲测试的时候，往往给的电流比较大，这种情况下并不算是一个完美的线性系统，已经脱离了线性的工作条件，线性系统就是我给他施加一个频率的激励，他会有一个同频率的响应输出，所以这里得到的一个系统是一个近似线性系统</li></ul><p><img src="87.png"></p><p>下面我们来看如果我们要将这个系统在时域中该如何实现</p><p>我们定义电流放电为正，根据电流规律和电压规律我们可以得到他的时域中的写法，电容电压等于并联的电阻上的电压，总电流等于各个并联电路之和或串联电路电流</p><p><img src="88.png"></p><p>我们可以将上面的方程再次简化，可以得到两个RC环节在某个电流激励下的电压，对于上面一个式子中依然存在我们不想要的一部分，我们可以再次化简</p><p><img src="89.png"></p><p>对于所有的线性所有的线性系统来讲，他最终的输出实际上是由两部分构成的，一部分为零输入响应(电流等于0，由电容的电压维持，电容和电阻行程回路)，一个是零状态响应(只有初始条件为零的时候，电容电压等于零，电流乘以整体的阻抗)</p><p><img src="90.png"></p><p>有了时域上的模型，我们就可以将模型应用起来 ，在这里其实有一个疑问，就是如果我们的电池参数辨识的不好，或者模型用的不好会怎么样，下面我们来看如何尽可能的提高模型的精度</p><p>多时间尺度效应指的就是频率有一个大的跨度，高中低频</p><p>Rct和Cdl主要代表传荷过程和双电层效应(Cdl)（发生过程较快秒级毫秒级），Rdiff和Cdiff扩散过程（持续时间较长十秒级百秒级，由于是在固相颗粒里面进行的）</p><p>如果是混合效应：如瞬时放电充电等</p><p>如果是持续效应：如持续放电持续充电，那么RC环节就会体现出来</p><p><img src="91.png"></p><p>仍需要注意的是，由于不通工况下电池系统辨识出来的参数也是不同的，和其温度、SOC老化、电流大小都有一定的关系，所以不变参数的模型表现出来的误差就会比较大</p><p>从图上可以看到欧姆阻抗还有RC环节的变化都是比较复杂的</p><p>如果实在需要，我们可以通过离线的实验将参数的变化规律找出来，指定成相应的表格，通过查表的方式得到各种工况下的参数，但是这种方法工作量太大，而且工况的复杂度也较高容易漏</p><p>另一种方法是通过在线的参数辨识方法得到对应的参数，这个等到后面参数辨识的时候再讲</p><p><img src="92.png"></p><p>上图是一个参数已经调的非常好的模型，做HPPC测试的效果图，这里实际上有些不清楚，右图其实是模型输出和实际输出的两条线，线间误差非常小</p><p>(实际上手测试数据施工中)</p><p><img src="93.png"></p><p>上图为模型优缺点</p><p>物理意义不清晰这里可以解释一下，就是用不同的工况去辨识同样的一个电池模型得到的参数是不一样的，如果不去区分模型的内部过程，用不同工况测试得到的欧姆内阻可能近似，但其他的会相去甚远(RC环节)</p><p>还有在低温、大电流、老化等因素下，精度会受影响较大</p><p>低温下电化学模型也有同样的问题，大电流下由于是非线性的所以会有很大误差</p><h4 id="4-12-3-3、电池热特性模型"><a href="#4-12-3-3、电池热特性模型" class="headerlink" title="4.12.3.3、电池热特性模型"></a>4.12.3.3、电池热特性模型</h4><p><img src="94.png"></p><p>内部机理模型其实就是电化学和热耦合的模型，分析其中每一个步骤的产热，这实际上是将电池看作小的颗粒组成的，包括一些求解域可以在COMSOL中实现</p><p>外特性模型，博纳利方程、Q=I^2 R等</p><p>模型形式：考虑不同位置电池的产热、电流密度等都有所不同考虑这种分布特性，集总参数将电池视为一个理想整体，各项导热系数是各向异性的，但是导热是均匀的</p><p><img src="95.png"></p><p>在做热特性模型的时候实际上也是利用了一个相似特性，我们将热的特性描述和电的特性描述做了个对应关系，这里左边的是热特性右边是电特性，我们将其一一对应，我们可以将电池的热特性网络用一个电特性网络来描述，</p><p><img src="96.png"></p><p>假定电池均匀发热、假定最高温度在电池中心位置、假定各向异性(导热均匀)</p><p>上图中电芯中的电路模型和电池表面相交部分为电池表面温度，电池内部三个电阻为对应的热阻，发热功率可以用等效的恒流源来代替，也就是左上角红色的Q，一部分会给电池加热，另一部分会往外传导，也就是一部分去了热容C里让电池温度升高，另一部分导热传到外壳，电池外部三个电阻为换热电阻，换热电阻外边近似接地的为环境温度，接地点为参考温度为T0，一般情况下，我们可以认为外部环境温度为参考温度</p><p>这样我们就将电池的热特性模型转化成了一个比较复杂的电特性网络，整理一下得到A B两图</p><p>Cc内部热容，Tis为中心最高温度点，如果这是一个铝壳电池，那么我们可以认为它的导热性能很好，表面温度基本相同，于是就可以将三个面的环境温度连接到一起Tss，外壳对应的热容Cs，一般来说外壳的热容都比较小，可以忽略</p><p>由于热阻是并联关系，所以我们都可以将其简化成B图</p><p>我们可以写出其状态空间方程，和其最终的内容<br>输入u=Q即我们的发热功率，输出y则是电池的表面温度</p><p>公式推导如下：</p><p>Q = Cc*(dTis/dt)+(Tis-Tss)/Ri<br>(Tis-Tss)/Ri = Cs*(dTss/dt)+Tss/Ro</p><p>y = x(2)</p><p>其和输入量无关，所以D=0</p><p><img src="97.png"></p><p>如果我们要在Simulink中搭建这样一个模型我们要将其做拉普拉斯变换、化简</p><p><img src="98.png"></p><p><img src="99.png"></p><p>我们就得到了电池的内部最高温度和他的发热功率之间的关系</p><p>我们令G(s) = Tis(s)/Q(s)就得到了最终的结果</p><p>输入电流通过博纳利方程转化成Q(s)，然后输入到G(s)中，就可以获得电芯内部最高温度了</p><p>如果要实现到嵌入式中，我们要将其离散化，变成差分方程</p><p><img src="100.png"></p><p>df/dt = f(k+1) - f(k)/Δt，Δt就是单位采用周期</p><p>图中最上面的式子就是内部温度和Q的关系</p><p><img src="101.png"></p><p>试验记录，误差±1度的误差</p><p>由此可以看出这个模型可以用于在线估计电池的产热</p><p>(Matlab模型手动实现，待施工完善中)</p><p>有限元模型</p><p><img src="102.png"></p><p><img src="103.png"></p><p><img src="104.png"></p><p><img src="105.png"></p><p><img src="106.png"></p><p><img src="107.png"></p><h4 id="4-12-3-4、电池的老化特性模型"><a href="#4-12-3-4、电池的老化特性模型" class="headerlink" title="4.12.3.4、电池的老化特性模型"></a>4.12.3.4、电池的老化特性模型</h4><h4 id="4-12-3-5、模型参数辨识"><a href="#4-12-3-5、模型参数辨识" class="headerlink" title="4.12.3.5、模型参数辨识"></a>4.12.3.5、模型参数辨识</h4><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> BMS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BMS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MBD环境搭建</title>
      <link href="/2023/05/21/mbd-environment/"/>
      <url>/2023/05/21/mbd-environment/</url>
      
        <content type="html"><![CDATA[<h1 id="1、环境说明"><a href="#1、环境说明" class="headerlink" title="1、环境说明"></a>1、环境说明</h1><blockquote><p>软件及对应版本</p><p>Matlab：2023a</p><p>开发板：TI Piccolo 280049C LaunchPad</p><p>配套开发软件：Code Composer Studio 11.1.0</p><p>C2000Ware：C2000Ware_4_01_00_00（官方推荐版本：C2000Ware_4_00_00_00）</p></blockquote><h1 id="2、配置过程"><a href="#2、配置过程" class="headerlink" title="2、配置过程"></a>2、配置过程</h1><h3 id="首先"><a href="#首先" class="headerlink" title="首先"></a>首先</h3><p>打开Matlab，点击上方标题栏中的附加功能，选择获取硬件支持包：</p><p><img src="0.png"></p><p>在弹出的界面中搜索C2000安装第一个即可，可能在其他教程中会让搜索Embedded coder support package for TI C2000等，但是在Matlab 2023a中，C2000 Microcontroller Blockset即为官方推荐版本</p><p><img src="1.png"></p><p>耐心等待下载完成后，可以根据相应提示自动安装C2000Ware等软件</p><p>随后可以新建工程或是直接通过此界面根据提示操作</p><p><img src="2.png"></p><p>在Matlab命令窗口运行</p><p><code>open_system('c28069_blink.slx');</code></p><p><img src="3.png"></p><p>输入完成回车后，会弹出以上界面，根据自身开发板对Hardware Board进行修改，我这里使用的是官方TI Piccolo 280049C LaunchPad开发板，所以将开发版修改成280049C LaunchPad</p><p>修改完成后要确认LED的IO和仿真环境下的IO是否一致，不是的话要根据需求更改，我这里IO口是GPIO 23</p><p><img src="4.png"></p><p>更改完成后，点击Run on board即可将程序下入开发板中，可以观察到开发板的LED灯已经开始闪烁，第一次运行的时候会比较慢，需要等他编译一会儿</p><p>如果你不慎关闭了安装完成后的提示界面，也可以直接使用simulink来搭建，只需要三步即可</p><p>一、</p><p>新建一个空的工程，然后在元件库中搭建出所需逻辑，并修改对应IO口</p><p><img src="5.png"></p><p>搭建完成后，点击标题栏中的模型设置，在弹出窗口中硬件实现界面里设置好自己的开发板即可</p><p><img src="6.png"></p><p>设置完成后，点击编译部署和启动，这里可能会有些慢，需要等待一段时间，第一次运行时会进入Debug模式，此时下方会出现计时，开发板也会跟着计时运作</p><p><img src="7.png"></p><p>以上便是最简单的MBD开发环境的搭建，今后也会更新更多的模块模型搭建。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MBD </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MBD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github无法clone问题</title>
      <link href="/2021/02/20/gittimeout/"/>
      <url>/2021/02/20/gittimeout/</url>
      
        <content type="html"><![CDATA[<p>换了电脑之后发现，github虽然能挂梯子访问但怎么都clone不下来东西，试过网上CSDN等的一堆方法之后，依然无法访问<br>遂想起，ping一下github.com试试，果不其然，ping不通<br>总算想起来为啥不能clone了，dns污染</p><p>于是通过下面网页</p><p><a href="https://ping.chinaz.com/assets-cdn.github.com">https://ping.chinaz.com/assets-cdn.github.com</a></p><p>输入对应网址进行ping检测，但是发现大陆域名也可以访问，但是我的电脑却无法访问，可能和当下的网络环境有关<br>于是找到德国对应的ip地址，在Hosts文件中做修改即可</p><p>最下面一行增加以下内容，根据ping的ip替换即可</p><pre><code>140.82.121.3 github.com140.82.121.9 nodeload.github.com140.82.121.5 api.github.com151.101.1.194 github.global.ssl.fastly.net185.199.108.153 assets-cdn.github.com</code></pre><p>写入之后通过命令行，执行</p><pre><code>ipconfig/flushdns</code></pre><p>更新后，ping一下能ping通即可进行无魔法上网也能直连github</p><p>对了，如果Win11电脑中，hosts文件内容是空的，需要运行以下命令去重新生成hosts文件</p><pre><code>for /f %P in ('dir %windir%\WinSxS\hosts /b /s') do copy %P %windir%\System32\drivers\etc &amp;amp; echo %P &amp;amp; Notepad %P</code></pre><p>命令需要在管理员模式下才能进行</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> git相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git相关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Opencv基础知识</title>
      <link href="/2020/10/13/cv1/"/>
      <url>/2020/10/13/cv1/</url>
      
        <content type="html"><![CDATA[<p>常识</p><p>Opencv读取格式是BGR</p><p>BGR三通道值对应颜色深度0-255</p><p>灰度图只有一个通道表示亮度</p><p>图像大小用矩阵表示</p><p>w h，表示像素点多少</p><p>1.14M图片=720×547×3×8 bit/8(B)</p><p>PNG图片除了RGB外还有个alpha通道，alpha是透明度信息</p><p>函数及示例</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token comment" spellcheck="true">#读取图片</span>img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'当前路径'</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#读入图像,0灰度图,1参数图片</span><span class="token comment" spellcheck="true">#img:dtype=uint8,[h,w,c],格式ndarray</span>img<span class="token punctuation">.</span>shape<span class="token comment" spellcheck="true">#导出高宽通道数</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'image'</span><span class="token punctuation">,</span>img<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#显示图像窗口名image</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#等待函数，这里按下空格即可结束等待</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#销毁所有窗口</span><span class="token comment" spellcheck="true">#保存图片</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'名称.jpg'</span><span class="token punctuation">,</span>img<span class="token punctuation">,</span><span class="token punctuation">[</span>cv2<span class="token punctuation">.</span>IMWRITE_JPEG_QUALITY<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token operator">-</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#有损压缩，范围0-100，当然也有PNG格式的</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'名称.png'</span><span class="token punctuation">,</span>img<span class="token punctuation">,</span><span class="token punctuation">[</span>cv2<span class="token punctuation">.</span>IMWRITE_COMPRESSION<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#对于JPG格式,数字越小压缩比越高，质量越差，对于PNG来说，数字越小，压缩比越低</span><span class="token comment" spellcheck="true">#灰度图</span>img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'当前路径'</span><span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>IMREAD_GRAYSCALE<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#读入图像</span>cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span><span class="token string">'路径名字'</span><span class="token punctuation">,</span>img<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#保存图片</span>img<span class="token punctuation">.</span>size<span class="token comment" spellcheck="true">#像素点数量</span>img<span class="token punctuation">.</span>dtype<span class="token comment" spellcheck="true">#数据类</span><span class="token comment" spellcheck="true">#读取视屏</span>vc<span class="token operator">=</span>cv2<span class="token punctuation">.</span>VideoCapture<span class="token punctuation">(</span><span class="token string">'路径名字'</span><span class="token punctuation">)</span><span class="token keyword">if</span> vc<span class="token punctuation">.</span>isOpened<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#是否能打开视频</span>    open<span class="token punctuation">.</span>frame <span class="token operator">=</span> vc<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#vc.read一帧一帧的读取视频</span><span class="token keyword">else</span><span class="token punctuation">:</span>    open <span class="token operator">=</span> <span class="token boolean">False</span><span class="token keyword">while</span> open<span class="token punctuation">:</span>    ret<span class="token punctuation">.</span>frame <span class="token operator">=</span> vc<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> frame <span class="token keyword">is</span> None<span class="token punctuation">:</span>        <span class="token keyword">break</span>    <span class="token keyword">if</span> ret <span class="token operator">==</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        gray <span class="token operator">=</span> cv2<span class="token punctuation">.</span>cvtColor<span class="token punctuation">(</span>frame<span class="token punctuation">.</span>cv2<span class="token punctuation">.</span>COLOR_BGR2GRAY<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#转为灰度</span>        cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'result'</span><span class="token punctuation">,</span>gray<span class="token punctuation">)</span>        <span class="token keyword">if</span> cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xFF</span> <span class="token operator">==</span> <span class="token number">27</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#27对应ESC键按下退出，等10ms播放一帧</span>            <span class="token keyword">break</span>vc<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyALLWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#截取图像部分数据</span>img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'当前路径'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#读入图像</span>cat<span class="token operator">=</span>img<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">200</span><span class="token punctuation">]</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'cat'</span><span class="token punctuation">,</span>cat<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#显示图像窗口名cat</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#等待函数，这里按下空格即可结束等待</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#销毁所有窗口</span><span class="token comment" spellcheck="true">#颜色通道提取</span>b<span class="token punctuation">,</span>g<span class="token punctuation">,</span>r<span class="token operator">=</span>cv2<span class="token punctuation">.</span>split<span class="token punctuation">(</span>img<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#....处理过程</span>img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>merge<span class="token punctuation">(</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span>g<span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#合并通道值</span><span class="token comment" spellcheck="true">#只保留R；G，B同理</span>cur_img <span class="token operator">=</span> img<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>cur_img<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>cur_img<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'cur_img'</span><span class="token punctuation">,</span>cur_img<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#显示图像窗口名cur_img</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#等待函数，这里按下空格即可结束等待</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#销毁所有窗口</span><span class="token comment" spellcheck="true">#边界填充</span>top_size<span class="token punctuation">,</span>bottom_size<span class="token punctuation">,</span>left_size<span class="token punctuation">,</span>right_size <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#上下左右的填充大小值</span>replicate <span class="token operator">=</span> cv2<span class="token punctuation">.</span>copyMakeBorder<span class="token punctuation">(</span>img<span class="token punctuation">,</span>top_size<span class="token punctuation">,</span>bottom_size<span class="token punctuation">,</span>left_size<span class="token punctuation">,</span>right_size<span class="token punctuation">,</span>borderType<span class="token operator">=</span>cv2<span class="token punctuation">.</span>BORDER_REPLICATE<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#复制法，复制最边缘的元素</span>reflect <span class="token operator">=</span> cv2<span class="token punctuation">.</span>copyMakeBorder<span class="token punctuation">(</span>img<span class="token punctuation">,</span>top_size<span class="token punctuation">,</span>bottom_size<span class="token punctuation">,</span>left_size<span class="token punctuation">,</span>right_size<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>BORDER_REFLECT<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#反射法对感兴趣的像素两边进行复制</span>reflect101 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>copyMakeBorder<span class="token punctuation">(</span>img<span class="token punctuation">,</span>top_size<span class="token punctuation">,</span>bottom_size<span class="token punctuation">,</span>left_size<span class="token punctuation">,</span>right_size<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>BORDER_REFLECT_101<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#反射法，以最边缘像素为轴对称</span>wrap <span class="token operator">=</span> cv2<span class="token punctuation">.</span>copyMakeBorder<span class="token punctuation">(</span>img<span class="token punctuation">,</span>top_size<span class="token punctuation">,</span>bottom_size<span class="token punctuation">,</span>left_size<span class="token punctuation">,</span>right_size<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>BORDER_WRAP<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#外包装法cdefgh|abcdefgh|abcdefg</span>constant <span class="token operator">=</span> cv2<span class="token punctuation">.</span>copyMakeBorder<span class="token punctuation">(</span>img<span class="token punctuation">,</span>top_size<span class="token punctuation">,</span>bottom_size<span class="token punctuation">,</span>left_size<span class="token punctuation">,</span>right_size<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>BORDER_CONSTANT<span class="token punctuation">,</span>value<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#常量法，常数值填充</span><span class="token comment" spellcheck="true">#数值计算</span>img_cat <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'cat.jpg'</span><span class="token punctuation">)</span>img_cat2 <span class="token operator">=</span> img_cat <span class="token operator">+</span> <span class="token number">10</span><span class="token comment" spellcheck="true">#所有像素点全部加十,当数值大于255时会对255取余</span><span class="token punctuation">(</span>img_cat <span class="token operator">+</span> img_cat2<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#255取余</span>cv2<span class="token punctuation">.</span>add<span class="token punctuation">(</span>img_cat<span class="token punctuation">,</span>img_cat2<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#大于255取255</span><span class="token comment" spellcheck="true">#注当shape值不同，不能直接相加，转化方法：</span>img_1 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>resize<span class="token punctuation">(</span>img_1<span class="token punctuation">,</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span>w<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#当然h，w也可以为零</span>img_1 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>resize<span class="token punctuation">(</span>img_1<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>fx<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span>fy<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#相当于倍数增加</span>res <span class="token operator">=</span> cv2<span class="token punctuation">.</span>addWeighted<span class="token punctuation">(</span>img1<span class="token punctuation">,</span><span class="token number">0.4</span><span class="token punctuation">,</span>img2<span class="token punctuation">,</span><span class="token number">0.6</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#0.4,0.6权重，0提亮度</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> tensorflow <span class="token keyword">as</span> tfdata1 <span class="token operator">=</span> tf<span class="token punctuation">.</span>constant<span class="token punctuation">(</span><span class="token number">2.5</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#常量</span>data2 <span class="token operator">=</span> tf<span class="token punctuation">.</span>Varoable<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span>name<span class="token operator">=</span><span class="token string">'var'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>data1<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>data2<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#直接打印</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础</title>
      <link href="/2020/05/20/linux/"/>
      <url>/2020/05/20/linux/</url>
      
        <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><h2 id="1-1-Linux内核"><a href="#1-1-Linux内核" class="headerlink" title="1.1 Linux内核"></a>1.1 Linux内核</h2><h3 id="1-1-1-简介"><a href="#1-1-1-简介" class="headerlink" title="1.1.1 简介"></a>1.1.1 简介</h3><p>Linux 是全球最受欢迎的开源操作系统。它是一个由 C 语言编写的，符合 POSIX 标准 的类 UNIX 系统。</p><ul><li>POSIX： 是 Portable Operating System Interface 的缩写，表示可移植操作系统接 口，它规定了操作系统应该为应用编程提供的接口标准。</li><li>UNIX：是一个强大的多用户、多任务分时操作系统，支持多种处理器架构，于 1969 年在 AT&amp;T 的贝尔实验室开发。UNIX 是商业操作系统，需要收费。</li></ul><p>Linux 遵循 GPL 协议，允许任何人对代码进行修改或发行，包括商业行为。只要其遵守 该 GPL 协议，所有基于 Linux 的软件也必须以 GPL 协议的形式发表，并提供源代码。</p><ul><li>GPL：是 GNU General Public License 的缩写，非正式中文翻译为“GNU 通用公共许 可证”。只有 GPL 英文原版才具有法律效力。 在软件中采用了使用 GPL 协议的产品，该软件产品也必须采 用 GPL 协议，即必须开源，这是 GPL 所谓的“传染性”。</li></ul><p>获取 Linux 内核源码的网址为：<a href="http://www.kernel.org,在这里能够/">http://www.kernel.org，在这里能够</a> 下载各版本的内核源码，包括测试版和最新稳定版。 Linux 的吉祥物是一只名叫 Tux 的企鹅，看起来像穿了一件晚礼服 的企鹅。</p><p>Linux 吉祥物创作于 1996 年，据说 Linus 被澳大利亚国家动物园的一只小企鹅轻轻咬 了一下，于是就有了用企鹅做吉祥物的想法。</p><h3 id="1-1-2-特点"><a href="#1-1-2-特点" class="headerlink" title="1.1.2 特点"></a>1.1.2 特点</h3><p>1.<strong>Linux内核的重要特点</strong></p><ul><li>Linux 是一个一体化内核；(“一体化内核”是也称“宏内核”，是相对于“微内核”而言的。几乎所有 的嵌入式和实时系统都采用微内核，如 VxWorks、uC/OS-II、PSOS 等。)</li><li>可移植性强。尽管 Linus 最初只为在 X86 PC 上实现一个“类 UNIX”，后来随 着加入者的努力，Linux 目前已经成为支持硬件平台最广泛的操作系统；(目前已经在 X86、IA64、ARM、MIPS、AVR32、M68K、S390、Blackfin、M32R 等众多架构处理器上运行。)</li><li>是一个可裁剪操作系统内核。Linux 极具伸缩性，内核可以任意裁剪，可以大至 几十或者上百兆，可以小至几百 K，运行的设备从超级计算机、大型服务器到 小型嵌入式系统、掌上移动设备或者嵌入式模块，都可以运行；</li><li>模块化。Linux 内核采用模块化设计，很多功能模块都可以编译为模块，可以在 内核运行中动态加载/卸载而无需重启系统；</li><li>网络支持完善。Linux 内核集成了完整的 POSIX 网络协议栈，网络功能完善；</li><li>稳定性强。运行 Linux 的内核的服务器可以做到几年不用复位重启；</li><li>安全性好。Linux 源码开放，由众多黑客参与 Linux 的开发，一旦发现漏洞都能 及时修复；</li><li>支持的设备广泛。Linux 源码中，设备驱动源码占了很大比例，几乎能支持任何 常见设备，无论是很老旧的设备还是最新推出的硬件设备，几乎都能找到 Linux 下的驱动。</li></ul><p>2.<strong>Linux操作系统的特点</strong></p><p>以 Linux 内核为核心的操作系统具有如下特点：</p><ul><li><strong>开放性</strong>：遵循世界标准规范，特别是遵循开放系统互连（OSI）国际标准。凡遵循国际标准所开 发的硬件和软件，都能彼此兼容，可方便地实现互连。</li><li><ul><li>OSI 是 Open System Interconnection 的缩写，意为开放系统互联，该模型由 ISO （国际标准化组织）制定。模型把网络通信分为 7 层：物理层、数据链路层、网络层、 传输层、会话层、表示层和应用层。</li><li>ISO 是 International Organization for Standardization 的缩写，即国际标准 化组织，该组织是由国家标准化机构组成的世界范围的联合会，现有 140 个成员国。ISO 中央办事机构设在瑞士的日内瓦。</li></ul></li><li><strong>多用户</strong>：Linux 操作系统是一个真正的多用户操作系统；系统资源可以被不同用户各自拥有使用， 即每个用户对自己的资源有特定的权限，互不影响。(经常有初学者将 Linux 的多用户与 Windows 的多用户弄混淆，实际上两者的差别是 很大的。Windows 桌面同一时刻只允许一个用户登录，其余用户必须锁定；而 Linux 则允许多个用户同时登录。)</li><li><strong>多任务</strong>：多任务是现代计算机的最主要的一个特点。它是指计算机同时执行多个程序，而且各个 程序的运行互相独立。Linux 系统调度每一个进程平等地访问处理器。(多任务实际上很常见，例如我们在编写文档的时候，还可以一边听歌，甚至还可以 从网上下载资料。这至少就有文档处理、音乐播放和网络下载三个任务，相互互不 影响，并且是同时运行的。)</li><li><strong>良好的用户界面</strong>：Linux 向用户提供了两种界面：用户界面和系统调用。</li><li><ul><li>Linux 的传统用户界面是基于文本的命令行界面，即 Shell，它既可以联机使用，又 可存在文件上脱机使用。Shell 有很强的程序设计能力，用户可方便地用它编制程 序，从而为用户扩充系统功能提供了更高级的手段。</li><li>Linux 还为用户提供了图形用户界面。它利用鼠标、菜单、窗口、滚动条等设施， 给用户呈现一个直观、易操作、交互性强的友好的图形化界面。</li><li>系统调用是提供给用户编程时使用的界面。用户可以在编程时直接使用系统提供的 系统调用。系统通过这个界面为用户程序提供低级、高效率的服务。</li></ul></li><li><strong>设备独立性</strong>：Linux 操作系统把所有外部设备统一当作成文件来看待，只要安装它们的驱动程序，任 何用户都可以像使用文件一样，操纵、使用这些设备，而不必知道它们的具体存在形式。 Linux 的设备独立性使得它具有高度适应能力，能够适应随时增加支持新设备。</li><li><ul><li>设备独立性主要是对应用程序开发者来说的。例如，对应用开发者来说，系统自带的串口与 USB 串口的操作方式是一样的，都是串口设备，而不用关心这个串口设备 实际对应的物理硬件是什么。</li></ul></li><li><strong>完善的网络功能</strong>：Linux 内置完整的 POSIX 网络协议栈，在通信和网络功能方面优于其它操作系统。Linux 为用户提供了完善的、强大的网络功能；</li><li><ul><li>支持 Internet。Linux 免费提供了大量支持 Internet 的软件，使得用户能用 Linux 与 世界上的其他人通过 Internet 网络进行通信。</li><li>网络文件传输。用户能通过一些 Linux 命令完成内部信息或文件的传输。</li><li>远程访问功能。Linux 系统既允许本身通过网络访问远程的系统，也允许远程系统 通过网络访问自身。</li></ul></li><li><strong>可靠的系统安全</strong>：Linux 采取了许多安全技术措施，包括对读、写进行权限控制、带保护的子系统、审计 跟踪、核心授权等，为网络多用户环境中的用户提供了必要的安全保障。</li><li><strong>模块化</strong>：运行时可以根据系统的需要加载程序而无需重启系统。Linux 的模块化极大地提高了 Linux 的可裁剪性和灵活性。</li><li><strong>良好的可移植性</strong>：Linux 是一种可移植的操作系统，能够在从微型计算机到大型计算机的任何环境和任何 平台上运行。目前已经成为支持平台最广泛的操作系统。(Linux 内核移植分 3 个层次：体系结构级别移植、处理器级别移植和板级移植。对 大多数开发者而言，只需进行板级移植。)</li></ul><h3 id="1-1-3-内核版本号"><a href="#1-1-3-内核版本号" class="headerlink" title="1.1.3 内核版本号"></a>1.1.3 内核版本号</h3><p>Linux 内核版本由 Linus 所领导的内核开发小组控制，版本号有严格规定。 Linux 内核版本号通常由 3 个数字组成，以 2.6.28 为例，2 为主版本号，6 为次版本号， 28 为修订号。次版本号为偶数则表示这是一个稳定版本，如 2.6.17，为奇数则表示是一个开 发版本，有可能是不稳定的，如 2.5.6。 另外，还可能见到如 2.6.27.8 这样的版本号，末尾的.8 表示这是 2.6.27 版本的第 8 个升 级版本，也是可用的稳定版本。</p><h3 id="1-1-4-组成部分"><a href="#1-1-4-组成部分" class="headerlink" title="1.1.4 组成部分"></a>1.1.4 组成部分</h3><p>Linux 内核由 5 个主要子系统组成，分别是：内存管理、进程管理、进程间通信、虚拟 文件系统和网络，各子系统之间的关系如图</p><p><img src="0.png"></p><ol><li><p><strong>进程管理</strong></p><p>进程管理负责控制进程对 CPU 的访问，如任务的创建、调度和终止等。任务调度是进 程管理最核心的工作，由 Linux 内核调度器来完成。Linux 内核调度器根据一定算法来选择 最值得运行的进程。</p><p>进程状态：</p><ul><li>运行态——已经获得了资源，并且进程正在被 CPU 执行。进程既可运行在内核 态，也可运行在用户态。</li><li><ul><li>内核态，内核和驱动所运行时的状态，程序处于特权阶级，能够访问系统的任 何资源，好比社会的统治者。</li><li>用户态，用户程序运行的状态，处于非特权阶级，不能随意访问系统资源，必须通过驱动程序方可访问，用户态程序可通过系统调用进入内核态。用户态程 序有如社会的被统治者，处于被管理的非特权阶级，只有通过某种途径才能进 入特权阶级。</li></ul></li><li>就绪态——当系统资源已经可用，但由于前一个进程还没有执行完而释放 CPU， 准备进入运行状态。</li><li>可中断睡眠状态——当进程处于可中断等待状态时，系统不会调度该程序执行。 当系统产生一个中断或者释放了进程正在等待的资源，或者进程收到一个信号， 都可以被唤醒进入就绪状态或者运行态。</li><li>不可中断睡眠状态——处于中断等待状态，但是该进程只能被使用 wake_up() 函数明确唤醒的时候才可进入就绪状态。</li><li>暂停状态——当进程收到 SIGSTOP、SIGSTP、SIGTTIN 或者 SIGTTOU 就会进 入暂停状态，收到 SIGCONT 信号即可进入运行态。</li><li>僵死态——进程已经停止运行，但是其父进程还没有询问其状态。</li></ul><p>各种状态转化关系和条件如图：</p><p><img src="1.png"></p><p>进程和状态的转换有点抽象，用生活中一个比较接近的例子类比一下，或许能有助于理 解。Linux 内核调度器好比是生产线的主管，而进程则好比是生产线上的工人。主管 24 小 时不间断的工作，工人的工作时间是朝九晚五，其余时间在等待区排队等候。</p><p>早上工人到达工厂，还没到 9 点上班时间，工人可以在等待区休息，这个状态可以称之 为“就绪态”；但是 9 点一到，工人则必须上生产线工作，这个工作状态可称之为“运行态”； 下午 5 点一到，到了工人下班时间，工人离开生产线又回到等待区排队等候，处于“就绪态”。</p><p>如果工人上班的时候，收到主管的命令，说是“你暂时不用工作了，到休息室休息等待”， 工人此时的这个状态，可以称之为“暂停”状态，过了一段时间，主管通知工人说是“休息 结束，要准备工作了”，工人不能直接回生产线岗位，而是必须先到等待区排队等待，轮到后才上生产线工作。</p><p>如果有一天工人精神状态不好，向主管申请要睡觉休息，理由可以是“某种配件不到，我无法工作”，也可以是“我就是困了，想睡觉”，工人最后可能得到两种批准结果：一是主管批准了，但是附加了一个条件说“等我叫醒你，你必须醒来上班”，然后工人就去享受他的安稳觉了，工人进入“不可中断睡眠”状态；另一种是主管也批准了，但是附加了另一个 条件，说“在你睡觉的时候，如果配件到了，你就得立马给我起来上班”，工人也去睡觉去了，但此时工人睡得并不安心，因为这不是一个安稳觉，是“可中断睡眠”。无论工人睡得 是安稳觉，还是不安稳觉，醒来都不能直接上生产线，而是回到等待区，等待轮值。</p><p>还有一种情况，工人干完活到点下班了，但主管对他不闻不问，也不安排新的工作，这 是一种非正常状况，工人进入了“僵死态”。</p></li><li><p><strong>内存管理</strong></p><p>内存管理的主要作用是控制和管理多个进程，使之能够安全的共享主内存区域。当 CPU 提供内存管理单元（MMU）时，内存管理为各进程实现虚拟地址到内存物理地址的转换。 在 32 位系统上，Linux 内核将 4G 空间分为 1G 内核空间（3<del>4G）和 3G（0</del>3G）用户空间， 通过内存管理，每个进程都可以使用 3G 的用户空间。</p></li><li><p><strong>文件系统</strong></p><p>Linux 内核支持众多的逻辑文件系统，如 Ext2、Ext3、Ext4、btrfs、NFS、VFAT 等。 VFS 则是 Linux 基于各种逻辑文件系统抽象出的一种内存中的文件系统，隐藏了各种硬件设 备细节，为用户提供统一的操作接口，是用户访问各种不同文件系统和设备时，不用区分具 体的逻辑文件系统。例如，Linux 下硬盘上使用的文件系统通常是 Ext3/4 格式，而 U 盘通常 是 FAT32 格式，但是用户在使用中根本感觉不到差异，也不用区分文件系统的具体差别。</p></li><li><p><strong>网络接口</strong></p><p>Linux 对网络支持相当完善，网络接口提供了对各种网络标准的存取和各种网络硬件的 支持，接口可分为网络协议和网络驱动程序。网络协议部分负责实现每一种可能的网络传输 协议。网络设备驱动程序负责与硬件设备通讯，每一种可能的硬件设备都有相应的设备驱动 程序。</p></li><li><p><strong>进程间通信</strong></p><p>支持进程间各种通信机制，如管道、命名管道、信号、消息队列、内存共享、信号量和套接字等。</p><ul><li>管道通常用于具有亲缘关系的父子进程或者兄弟进程间通信，是半双工的，数据只能往一个方向流动，先入先出，与自来水管很相似。如果双方互通时，需要建立两个管道。</li><li>命名管道则突破了进程间的亲缘关系限制，即非父子、兄弟进程之间也可相互通信。</li><li>信号是软件中断，用于在多个进程之间传递异步信号。日常生活中信号的例子很多了，如一对很亲密的哑巴情侣，在很多时候只需要一个简单的眼神，对方就能知道 他（她）需要什么，并做出回应，这个眼神，就是一个“信号”。</li><li>信号能传递的信息有限，而消息队列则正好弥补了这点。例如情侣的一个眼神，对 方可能能知道情侣的需求，但是如果情侣有一大堆需求，仅仅靠一个眼神就比较费 力了。情侣就把自己的需求写在了一张纸条上，递交给对方，对方根据纸条的内容， 逐一满足情侣的需求。</li><li>共享内存常用于不同进程间进行大量数据传递。Linux 下每个进程都有自己的独立 空间，各自都不能直接访问其它进程的空间。好比这对情侣都有自己的小金库，有 时候需要给对方一部分钱用，但他们不能直接相互转账，必须先将前存到他们俩合 开的一个公共账户上面，然后再使用。这个公共账户就是这对情侣的“共享内存”。</li><li>信号量用于进程同步。只有获得了信号量的进程才可以运行，没有获得信号量的进程则只能等待。就像十字路口的红绿灯，只有在绿灯亮（获得了绿灯）的时候才能 通行，否则只能等待。</li><li>套接字（Socket）起源于 BSD，也常称“BSD 套接字”，用于多个进程间通信，可以 基于文件，也可基于网络。Socket 本意是“插座”，套接字设计就是通过某些参数 设定，然后将一个“插座”与另外一个“插座”连接起来。可能还有点抽象，看一 个例子可能就好理解了。把套接字理解为固定电话的插口，现在要打电话出去，必 须要知道打给谁，往哪里打；另外电话另一端必须有人在听才可以通话，否则也不 能打电话。</li></ul></li></ol><h2 id="1-2Linux发行版"><a href="#1-2Linux发行版" class="headerlink" title="1.2Linux发行版"></a>1.2Linux发行版</h2><p>由 Linus 主持开发的 Linux 仅仅是一个内核，提供硬件抽象层、磁盘及文件系统控制、多任务等功能，并不是一个完整的操作系统。一套基于 Linux 内核的完整操作系统叫作 Linux 操作系统，也称 GNU/Linux。据不完全统计，目前大大小小应用于不同场合的 Linux 发行版 已经超过 400 余种，桌面/服务器上常见的也就十来种，如 Redhat、Mandriva、Fedora、SuSe、 Debian、Ubuntu 等。</p><p>一个完整的Linux 发行版，是以Linux 内核为基础，外加众多外围应用程序和文档组成，一个典型的 GNU/Linux 发行版基本系统结构如图所示。不同软件厂商发布的 Linux 发 行版各自包含的外围软件也不一样，发布版的镜像大小差别也很大。</p><p><img src="2.png"></p><p>Linux 内核为一些软件厂商提供了内核，促使了发行版的诞生；发行版的流行使得 Linux 更加广为人知，并吸引更多的黑客参与 Linux 应用开发，甚至内核开发，促进了内核的快速 发展。不同发行版之间功能定位、用户群体都有差异，几乎每个发行版都拥有相当大数量的 固定的用户群或者忠实追随者。Linux 社区各大发行版之间的争论一直没有停止过，甚至有 时候还有不同发行版用户之间的口水战，但是这并不妨碍 Linux 内核的发展。</p><p>Linux 发行版的版本号是发行厂商自定义的代号，与 Linux 内核版本号没有任何直接关 系，并且各发行版的命名规则也各不相同，如 Fedora 20、Ubuntu 14.04 等。常见的 Linux 发 行版有：</p><p><img src="3.png"></p><p><img src="4.png"></p><p><img src="5.png"></p><p><img src="6.png"></p><p><img src="7.png"></p><p><img src="8.png"></p><p><img src="9.png"></p><p><img src="10.png"></p><p><img src="11.png"></p><h2 id="1-3-嵌入式Linux"><a href="#1-3-嵌入式Linux" class="headerlink" title="1.3 嵌入式Linux"></a>1.3 嵌入式Linux</h2><h3 id="1-3-1-嵌入式Linux的特点"><a href="#1-3-1-嵌入式Linux的特点" class="headerlink" title="1.3.1 嵌入式Linux的特点"></a>1.3.1 嵌入式Linux的特点</h3><p>嵌入式 Linux 是对运行在嵌入式设备上的 Linux 的统称，严格说来，每种不同应用的嵌 入式 Linux 都可以称为是一个发行版。嵌入式 Linux 往往针对于某个特殊领域，专门为实现 某些特定的功能而开发，一般说来，嵌入式 Linux 所运行的程序相对来说比较单一，功能定 位也比较明确，如嵌入式网关、路由器等。</p><p>将标准 Linux 应用到嵌入式领域，往往是根据实际需要裁减内核，内核一般从几百 K 到几兆字节不等。所使用的文件系统也不是桌面 Linux 这样复杂庞大的软件包，一般也是用 源码或者其它工具定制，文件系统的大小也可以从几兆到几十兆，或者上百兆不等。</p><p>Linux 在嵌入式领域的分化，一般是两个方向，小型化和实时化。 </p><p><strong>小型化</strong>一般就是根据需要将不需要的功能和服务去掉，尽可能的减小内核和系统的体积， 以节省硬件资源和成本，如 ETLinux、uLinux、ThinLinux 等。 </p><p><strong>实时化</strong>一般是通过修改源代码，为 Linux 内核增加比校准内核更好的实时性，以满足一 些对实时性有要求的特定领域的应用，如 RTLinux、RTAI 等。</p><h3 id="1-3-2嵌入式Linux的产品形态"><a href="#1-3-2嵌入式Linux的产品形态" class="headerlink" title="1.3.2嵌入式Linux的产品形态"></a>1.3.2嵌入式Linux的产品形态</h3><p>与其它嵌入式系统产品一样，嵌入式 Linux 产品在物理形态上与普通 Linux 设备有很大 差异，不同产品之间物理形态也是各不相同。与桌面 Linux 相比，嵌入式 Linux 产品往往没有硕大的显示器，或者鼠标键盘这样的外设。 </p><p>嵌入式 Linux 产品既可以作为一个独立形态的产品出现，如手持机、交换机、路由器等， 也有可能以某种特殊功能设备的形式出现，通过某种通信接口参与系统集成，例如协议转换器，或者甚至以电路板或者模块的形式出现在某种设备的电路板上，如嵌入式工业交换机模 块。无论如何，它们的共性都是运行了经过高度裁剪的、具备特定功能的嵌入式 Linux 操作系统。图列举了生活中一些常见的嵌入式 Linux 产品。</p><p><img src="12.png"></p><p>无论最终产品以何种形态出现，在开发阶段，串口和网口几乎是必不可缺的外设接口。 嵌入式 Linux 的默认终端通常是调试串口，系统输出信息通过串口输出，也通过串口接收各 种命令。而网口则常用于数据传输和程序调试，特别是在内核开发阶段以及应用程序开发阶 段，网络几乎也是必须的。</p><h1 id="2-安装Linux操作系统"><a href="#2-安装Linux操作系统" class="headerlink" title="2. 安装Linux操作系统"></a>2. 安装Linux操作系统</h1><h2 id="2-1简述三种方式"><a href="#2-1简述三种方式" class="headerlink" title="2.1简述三种方式"></a>2.1简述三种方式</h2><p>学习 Linux，必须先获得一个 Linux 主机环境，通常情况下，可以通过以下三种方式获 得 Linux 环境。</p><ul><li><strong>双系统安装</strong></li><li><ul><li>如果没有闲置的计算机，或者现有 Windows 系统的计算机有足够的硬盘空间，可以考 虑划分一部分硬盘空间，用于安装 Linux 操作系统，最终形成双系统计算机。 </li><li>优点：经济实惠，且对计算机硬件要求不太高。 </li><li>缺点：安装双系统比较危险，一不小心有可能造成整个硬盘数据丢失；在开发过程使 用到 Windows 工具时，需进行系统切换，不是很方便。</li></ul></li><li><strong>全新硬盘安装</strong></li><li><ul><li>如果有足够的计算机可用，可以选择一台计算机全新安装 Linux 操作系统。 </li><li>优点：不用考虑多系统并存的问题，且对计算机硬件硬件要求不太高。 </li><li>缺点：在嵌入式开发过程中，通常还会用到 Windows 下的工具，还需另外一台计算机 安装 Windows 系统。</li></ul></li><li><strong>安装虚拟机</strong></li><li><ul><li>如果计算机配置较高，可以考虑虚拟机方案。在 Windows 下安装虚拟机软件，然后通 过虚拟机软件创建一台虚拟电脑，最后在虚拟电脑中安装 Linux 操作系统；也可以安装 Linux， 在 Linux 中安装虚拟机再安装 Windows。 </li><li>常用的虚拟机软件有 VMware、Virtual Box 和 Virtual PC 等，不同虚拟机软件的使用方 法稍有不同。下文以 VMware 为例进行介绍。</li><li>优点：安装和使用 Linux 都很方便；还可同时使用 Windows 系统。 </li><li>缺点：对计算机硬件要求高，特别是内存，推荐 4GB 及以上。 在 Windows 下使用虚拟机，除了可以继续使用 Windows 下的工具之外，还有下列好处：</li><li><ul><li>一台电脑可以同时存放多台虚拟机，这样就可以存在多个不同版本的 Linux 系统；</li><li>在硬件允许的情况下，甚至可以同时运行多台虚拟机；</li><li>安装好的虚拟机可以任意复制和拷贝，方便在不同电脑之间迁移和扩散。</li></ul></li></ul></li></ul><h2 id="2-2-发行版本选择和ISO下载"><a href="#2-2-发行版本选择和ISO下载" class="headerlink" title="2.2 发行版本选择和ISO下载"></a>2.2 发行版本选择和ISO下载</h2><p>首先要考虑该发行版的流行度，越流行的发行版，用户越多，遇到问题寻求技术支持也 很方便，如果选择小众的发行版，寻求技术支持就不那么方便了。</p><p>其次要考虑该发行版使用的难易程度，通常来说，越简单易用的发行版越流行。</p><p>进行嵌入式 Linux 开发，还必须考虑嵌入式 Linux 开发工具的问题。最好选择处理器半 导体厂商以及开发平台厂商所选择的发行版，这样能够直接使用半导体或者开发平台原厂提 供的各种工具，减少开发过程中的障碍。</p><p>基于以上 3 个理由，我们选择了 Ubuntu 发行版，下面的安装和使用都以 Ubuntu 为例进 行介绍。Ubuntu 本身又有很多版本，我们选择的确切版本是 Ubuntu 12.04.5，是目前来说最 适合于嵌入式 Linux 开发的 Ubuntu LTS（长期支持）版本</p><p> Ubuntu 12.04 下载地址：<a href="http://www.ubuntu.com/download/alternative-downloads">www.ubuntu.com/download/alternative-downloads</a></p><p>建议选择 Desktop 版本，到底是 32-bit 版本还是 64-bit 版本，需要根据计算机硬件来定，在硬件允许的情况下，推荐选择 64-bit 版本。</p><p>下载 ISO 文件后，如果进行虚拟安装，则可以直接使用 ISO 文件；如果进行物理实体 安装，则可将 ISO 刻成启动光盘，或者用 unetbootin-windows 软件制作成 USB 启动盘备用。</p><p>用从 Ubuntu 官网下载的 ISO 镜像，安装后只能得到纯净的 Ubuntu 系统，如果从 <a href="http://www.zlg.cn/linux">www.zlg.cn/linux</a> 下载经过重新打包的 Ubuntu 镜像，安装后将会得到已经构建好嵌入式 Linux 开发环境的 Ubuntu 系统。</p><h2 id="2-3-VMware-Player软件"><a href="#2-3-VMware-Player软件" class="headerlink" title="2.3 VMware Player软件"></a>2.3 VMware Player软件</h2><h3 id="2-3-1-下载和安装"><a href="#2-3-1-下载和安装" class="headerlink" title="2.3.1 下载和安装"></a>2.3.1 下载和安装</h3><p>打开VMware官方网站(<a href="http://www.vmware.com),进入下载专区,下载非商用的vmware/">www.vmware.com)，进入下载专区，下载非商用的VMware</a> Player 软件。在下载页面中选择下载 VMware Player for Windows 32-bit and 64-bit 软件。</p><p>文件下载完成后，得到 VMware-player-6.0.2-1744117.exe 程序安装文件（具体文件名以 实际下载到的文件为准）。双击该程序安装文件，在弹出的对话框中选择“下一步”，直至安装完成即可。</p><h3 id="2-3-2-设置虚拟化支持"><a href="#2-3-2-设置虚拟化支持" class="headerlink" title="2.3.2 设置虚拟化支持"></a>2.3.2 设置虚拟化支持</h3><p>对于大多数 PC 而言，主板设置默认支持虚拟化，无需进行这步操作，但是对于一些笔 记本电脑，默认关闭了虚拟化支持，需要使能才能正常使用虚拟机。</p><p>设置虚拟化支持，需要进入系统 BIOS 进行操作。不同品牌的笔记本进入 BIOS 的方法 也存在差异，有的是在刚启动时持续按 F2 键进入 BIOS，有的是 F10 键，具体请参考对应 品牌电脑的主板说明。</p><p>当进入 BIOS 系统，找到 Intel Virtualization Technology 选项，将其配置为 Enable，不同 PC 的 BIOS 中对应的选项位置及描述可能不同，请以实际情况为准。</p><p>设置好虚拟化支持后，保存并退出 BIOS，重启电脑。</p><h2 id="2-4-使用现成的虚拟机"><a href="#2-4-使用现成的虚拟机" class="headerlink" title="2.4 使用现成的虚拟机"></a>2.4 使用现成的虚拟机</h2><p>前面已经提到过，虚拟机可以在不同电脑之间迁移和扩散。如果觉得安装 Linux 操作系 统麻烦，或者暂时不想安装，可以直接使用已经安装好的虚拟机镜像。打开 <a href="http://www.zlg.cn/linux%EF%BC%8C%E4%B8%8B%E8%BD%BD%E5%B7%B2%E7%BB%8F%E5%AE%89%E8%A3%85%E5%A5%BD%E7%9A%84">http://www.zlg.cn/linux，下载已经安装好的</a> Ubuntu 12.04 虚拟机镜像，存放到有足够空闲空 间（建议 40GB 以上）的硬盘解压，将得到我们已经安装好的虚拟机。</p><p>下载页面同时提供了 64 位和 32 位虚拟机文件，请根据计算机硬件具体情况选择：32 位处理器的计算机只能使用 32 位镜像；而对于 64 位处理器的计算机，无论安装了 32 位还 是 64 位操作系统，都可以任意选择。 </p><p>打开 WMware Player 软件，点击“打开虚拟机”，选择打开已有的虚拟机。</p><p>安装过程就不多赘述了，详细可以百度，这里只提几点设置</p><p>虚拟网卡三种模式</p><ul><li><strong>桥接模式</strong>：在这种模式下，VMWare 虚拟出来的操作系统就像是局域网中的一台独立的主机，它可 以访问网内任何一台机器。在桥接模式下，虚拟系统和宿主机器的关系，就像连接在同一个 Hub 上的两台电脑。 用户需要手工为虚拟系统配置 IP 地址、子网掩码，而且还要和宿主机器处于同一网段，这 样虚拟系统才能和宿主机器进行通信。同时，由于这个虚拟系统是局域网中的一个独立的主 机系统，那么就可以手工配置它的 TCP/IP 配置信息，以实现通过局域网的网关或路由器访问互联网。</li><li><ul><li>在进行嵌入式 Linux 开发，要目标板通过 NFS 挂载虚拟机的 NFS 共享目录的话，必 须将虚拟网卡配置为桥接模式。</li></ul></li><li><strong>NAT 模式</strong> ：使用 NAT 模式，就是让虚拟系统借助 NAT（网络地址转换）功能，通过宿主机器所在 的网络来访问公网，也就是说，使用 NAT 模式可以实现在虚拟系统里访问互联网。NAT 模 式下的虚拟系统的 TCP/IP 配置信息是由 VMnet8(NAT)虚拟网络的 DHCP 服务器提供的，虚 拟机无法正常对主机所连网络中的其它主机提供普通的网络服务，如 TFTP、NFS 和 FTP 等。 采用 NAT 模式最大的优势是虚拟系统接入互联网非常简单，用户不需要进行任何其它 的配置，只需要宿主机器能访问互联网即可。</li><li><strong>仅主机模式</strong>：在某些特殊的网络调试环境中，要求将真实环境和虚拟环境隔离开，这时用户就可采用 仅主机（Host-Only）模式。在 Host-Only 模式中，所有的虚拟系统是可以相互通信的，但虚 拟系统和真实的网络是被隔离开的。</li></ul><h2 id="2-5-初识Ubuntu"><a href="#2-5-初识Ubuntu" class="headerlink" title="2.5 初识Ubuntu"></a>2.5 初识Ubuntu</h2><h3 id="2-5-1-Ubuntu桌面"><a href="#2-5-1-Ubuntu桌面" class="headerlink" title="2.5.1 Ubuntu桌面"></a>2.5.1 Ubuntu桌面</h3><p>Ubuntu 启动后，进入桌面系统，在桌面的右上角显示的是输入法、时间、登录用户名的信息。</p><p>桌面的左侧是任务栏。在任务上，可以看到 Ubuntu 为用户准备了一些常用的软件：</p><ul><li>火狐浏览器，上网用</li><li>文件浏览器，用于浏览计算机上的文件</li><li>文档处理处理软件，类似 Windows Office 的 Word 软件</li><li>表格处理软件，类似 Windows Office 的 Execl 软件</li><li>演示文稿软件，类似 Windows Office 的 PowerPoint</li><li>软件中心，为用户提供海量的软件下载、安装</li><li>系统设置</li></ul><h3 id="2-5-2-打开终端"><a href="#2-5-2-打开终端" class="headerlink" title="2.5.2 打开终端"></a>2.5.2 打开终端</h3><p>在 Dash 的搜索输入框输入“terminal”，即可搜索到终端程序。在实际应用中，并不需 要写全，输入前面即可字母，系统就能自动列出相关软件，如输入“te”，即可出现包含终 端在内的程序。</p><p>点击终端图标即可打开终端的窗口。按“Ctrl+Alt+T”组合键也可以打 开终端窗口。终端窗口的大小，可以由用户用鼠标拖伸，或最大化。</p><p>按“Ctrl+Shift+T”键可以在终端窗口再打开一个终端的标签。按“Alt+1” 或“Alt+2”切换终端标签。</p><h3 id="2-5-3-安装软件"><a href="#2-5-3-安装软件" class="headerlink" title="2.5.3 安装软件"></a>2.5.3 安装软件</h3><p>在 Ubuntu 一般使用 apt-get 命令安装软件。但前提是电脑需要连接到互联网。apt-get 命 令在执行时会在网上下载指定的软件包，然后完成安装。 </p><p>例如，安装 vim 的方法是：</p><pre class=" language-shell"><code class="language-shell">$ sudo apt-get install vim</code></pre><p>若要卸载安装好的 vim 方法是：</p><pre class=" language-shell"><code class="language-shell">$ sudo apt-get remove vim</code></pre><p>当然也可以通过软件中心来下载。</p><h2 id="3-1-Linux-Shell"><a href="#3-1-Linux-Shell" class="headerlink" title="3.1 Linux Shell"></a>3.1 Linux Shell</h2><h3 id="3-1-1-Shell是什么？"><a href="#3-1-1-Shell是什么？" class="headerlink" title="3.1.1 Shell是什么？"></a>3.1.1 Shell是什么？</h3><p>前面已经提到过，Linux 系统为用户提供了多种用户界面，包括 Shell 界面、系统调用 和图形界面。其中 Shell 界面是 UNIX/Linux 系统的传统界面，也可以说是最重要的用户界 面，无论是服务器、桌面系统还是嵌入式应用，都离不开 Shell。</p><p>Shell，英文本意是外壳，Linux Shell 就是 Linux 操作系统的外壳，为用户提供使用操作 系统的接口，是 Linux 系统用户交互的重要接口。登录 Linux 系统或者打开 Linux 的终端， 都将会启动 Linux 所使用的 Shell。</p><p>Linux Shell一个命令解释器，是 Linux 下最重要的交互界面，从标准输入接收用户命令， 将命令进行解析并传递给内核，内核则根据命令，作出相应的动作，如果有反馈信息，则输 出到标准输出上，示意过程如图所示。嵌入式 Linux 的标准输入和输出都是串口终端。</p><p><img src="13.png"></p><p>Shell 既能解释自身的内建命令，也能解释外部命令，如系统某个目录下的可执行程序。 Shell 首先判断是否是自己的内建命令，然后再检查是不是系统的应用程序，如果不是内建 命令，在系统也找不到这个应用程序，则提示错误信息，如果找到了应用程序，则应用程序 调入系统调用时陷入内核。</p><p>Shell 也是一种解释型的程序设计语言，并且支持绝大多数高级语言的程序元素，如变 量、数组、函数以及程序控制等。Shell 编程简单易学，任何在 Shell 提示符中输入的命令都 可以放到一个可执行的 Shell 程序文件中。Shell 文件其实就是众多 Linux 命令的集合，也称 为 Shell 脚本文件。</p><h3 id="3-1-2-Shell的种类和特点"><a href="#3-1-2-Shell的种类和特点" class="headerlink" title="3.1.2 Shell的种类和特点"></a>3.1.2 Shell的种类和特点</h3><p>Linux Shell 有多种 Shell，比较通用且有标准的主要分为两类：Bourne Shell（sh）和 C Shell （csh），各自包括几种具体的 Shell。</p><p><img src="14.png"></p><p>Bourne Shell 是 UNIX 最初使用的 shell，在每种 UNIX 上都可以使用。Bourne Shell 的 优点是在 Shell 编程方面很好，缺点是用户的交互不如其他几种 Shell。</p><p>Bourne Again Shell 简称 Bash，是 Bourne Shell 的扩展，与 Bourne Shell 完全向后兼容， 在 Bourne Shell 的基础上增加了很多新特性。Bash 提供了命令补全、命令编辑和命令历史表 等功能，还包含了很多 C shell 和 Korn shell 中的优点，使用灵活，界面友好，编程方便，是 GNU/Linux 操作系统的默认 Shell。</p><p>Korn Shell 由 AT&amp;T 的 Bell 实验室 David Korn 开发，吸收了所有 C Shell 的交互式特性， 并融入了 Bourne shell 的语法，与 Bourne shell 完全兼容。</p><p>C Shell 由 Bill Joy 在 BSD 系统上开发，增强了用户交互功能，并将编程语法变成了 C 语言风格，还增加了命令历史、别名、文件名替换、作业控制等功能。</p><p>在不同发行版中，所采用的默认 Shell 也有所不同，如 Redhat 和 Fedora 中默认 Shell 为 bash，Ubuntu 中用了 dash。无论用哪种 Shell，登录系统后系统将运行一个 Shell 进程。根据 不同用户，Shell 提供不同的命令提示符，root 用户的提示符为“#”，普通用户的命令提示 符为“$”，在命令提示符下输入命令即可与系统进行交互。</p><p>尽管不同发行版的默认 Shell 有可能不同，但是所采用的 Shell 一般都具有如下特性：</p><ul><li>具有内置命令可供用户直接使用；</li><li>支持复合命令：把已有命令组合成新的命令；</li><li>支持通配符（*、?、[]）</li><li>支持 TAB 键补齐；</li><li>支持历史记录；</li><li>支持环境变量；</li><li>支持后台执行命令或者程序；</li><li>支持 Shell 脚本程序；</li><li>具有模块化编程能力，如顺序流控制、条件控制和循环控制等；</li><li>Ctrl+C 能终止进程。</li></ul><h2 id="3-2-Linux常见命令"><a href="#3-2-Linux常见命令" class="headerlink" title="3.2 Linux常见命令"></a>3.2 Linux常见命令</h2><p>对进行嵌入式 Linux 开发经常会用到的一些操作和相关命令，进一步加深对 Linux 的了解。命令是 Linux 最重要的人机交互界面之一，学习和掌握 Linux 命令是学习 Linux 不 可逾越的阶段。在 Shell 下，一些命令加上一些参数，或者几个简单命令进行组合，可以完 成在图形界面下需要经过复杂操作才能完成的功能。“简单就是美”在 Linux 的命令中得到 了很好的体现。 </p><p>Linux 的命令通常会有很多选项和参数，但日常操作中用到的都不多，在这里也仅仅择 取常用的进行介绍，更多或者完整的 Linux 命令请参考 Linux 命令手册或者其它资料。在接 触具体的命令之前，先对 Linux 命令的特点做一个概括，也是使用 Linux 命令的一些注意事项：</p><ul><li>大多数命令都有各种参数和选项；</li><li>大多数命令的参数可以组合使用（相斥参数除外）；</li><li>用“命令 –help”或者“man 命令”可以获取相应命令的详细用法；</li><li>命令/工具不同版本所支持的参数可能会有所差异；</li><li>命令区分大小写，包括参数；</li><li>Shell 支持 TAB 键命令补齐，输入命令开头字母，按 TAB 键能补齐命令。</li></ul><h3 id="3-2-1-导航命令"><a href="#3-2-1-导航命令" class="headerlink" title="3.2.1 导航命令"></a>3.2.1 导航命令</h3><p>打开 Linux 的虚拟终端后，一般都停在用户主目录下。当前目录下有什么？如何进入到 其它目录？进入其它目录后，如何才能知道当前的确切位置？像这类操作通常称之为导航。 Linux 下，能帮助进行导航的命令有 3 个：ls、cd 和 pwd。</p><ul><li><p><strong>查看当前目录的内容</strong>：打开 Linux 虚拟终端后，查看当前目录下的内容，查看当前目录下有什么文件和目录，然后再进行其它操作。查看当前目录下的内容的命令式 ls， 简单的输入 ls 就可以了</p></li><li><ul><li><p>用法：</p><pre class=" language-shell"><code class="language-shell">$ ls [选项]</code></pre><p><img src="15.png"></p><p>说明：</p><p>（1）Linux 区分大小写，在输入的时候需要特别注意； </p><p>（2）各参数可以任意组合，如 ls -la； </p><p>（3）支持通配符*、?等。注：在 Linux 下，隐藏一个文件只需将文件改名为点号（.）开始的文件名即可，而 Windows 下，通常需要修改文件属性。</p></li></ul></li><li><p><strong>切换工作目录</strong>：用法：</p><pre class=" language-shell"><code class="language-shell">$cd 目标路径</code></pre><p><img src="16.png"></p><p>（1）Linux 下目录、计算机名和域名之间都是用斜线（/）分开，而非反斜线（\）； </p><p>（2）Linux 下切换目录，可用相对路径，亦可用绝对路径。</p></li><li><p><strong>查看当前路径</strong>：用法很简单，在 Shell 终端中输入 pwd 即可</p></li></ul><h3 id="3-2-2-目录操作命令"><a href="#3-2-2-目录操作命令" class="headerlink" title="3.2.2 目录操作命令"></a>3.2.2 目录操作命令</h3><ul><li><p><strong>创建目录</strong>：mkdir 用于创建一个或者多个目录，加上选项也可以创建多级目录，这样的快捷性是图 形界面无法做到的。用法：</p><pre class=" language-shell"><code class="language-shell">$mkdir [选项] [参数] 目录</code></pre><p><img src="17.png"></p></li><li><p><strong>删除目录</strong>：如果一个目录不再需要，可以将其删除。Linux 下有两个命令可用于删除目录，rmdir 和 rm。</p></li><li><ul><li><p>用 rmdir 删除空目录：rmdir 命令只能删除空目录，无法删除非空目录。rmdir 也支持参数-p，表示删除某个目录后，如果父目录也成了空目录，则连父目录一 并删除。</p><pre class=" language-shell"><code class="language-shell">$rmdir dir</code></pre></li></ul></li></ul><ul><li><p>用 rm 命令删除：用 rmdir 命令很安全，不会误删数据，但是实际上用的不是很多，更常用的是用 rm 命 令。rm 命令既可以删除文件，也可以删除目录而不管目录是否非空。</p><pre class=" language-shell"><code class="language-shell">$rm [选项] 文件/目录</code></pre><p><img src="18.png"></p></li></ul><h3 id="3-2-3-文件操作命令"><a href="#3-2-3-文件操作命令" class="headerlink" title="3.2.3 文件操作命令"></a>3.2.3 文件操作命令</h3><ul><li><p><strong>创建空文件</strong>：touch 命令可以完成 这个功能能，创建的文件大小为 0，命令如下：</p><pre class=" language-shell"><code class="language-shell">$ touch a</code></pre></li><li><p><strong>创建一个有内容的文件</strong>：</p></li><li><ul><li><p>Linux 下创建文件，可以使用文本编辑器如 vi 等来操作。对于简单的内容，可以用普通 命令来创建文件。用普通命令创建非空文件，需要用到 Linux Shell 重定向机制，首先来了 解一下重定向。</p></li><li><p>Linux Shell 终端启动的时候会打开 3 个标准文件：标准输入（stdin）、标准输出（stdout） 和标准错误（stderr）。Shell 从标准输入（通常是键盘）接收命令，命令执行结果信息打印 到标准输出（通常是终端屏幕）上，如有错误信息，则打印到标准错误（通常是终端屏幕） 上，如图      </p></li><li><p><img src="19.png"> </p></li><li><p>Shell 允许用户对输入输出进行重定向。输出重定向允许将输出信息从标准输出重定向 到其它文件上，也可以重定向到某个设备如打印机上。如图所示是将标准输出重定向到文件的示意图。 </p></li><li><p><img src="20.png"> </p></li><li><p>重定向在 Linux 下用“&gt;”和“&gt;&gt;”表示，“&gt;”表示输出到一个新文件中，而“&gt;&gt;”则 表示输出到现有文件的末尾。如果文件已经存在，则直接操作文件，否则将创建新文件。 </p></li><li><p>echo 命令将内容回显到标准输出，使用 echo 命令加上重定向可以创建一个带内容的非 空文件，用法：</p><pre class=" language-shell"><code class="language-shell">$echo 内容 或者 “内容” #输出到标准输出$echo 内容 或者 “内容” > 文件 #重定向到文件，如果文件不存在则创建新文件</code></pre><p>回显内容如果不加引号，则用单空格替代多个连续空格，如果加了引号，则原封不动回显</p><p>可以看到，第一次输入的内容没有引号，连续空格被单空格替换了，而第二次加了引号， 连续空格依然保留。</p></li></ul></li><li><p><strong>查看文件类型</strong>：</p></li><li><ul><li><p>在 Windows 下，文件都有标准扩展，基本上可以根据文件扩展名来识别和判断文件类 型，如.exe 是可执行文件，.c 是 C 代码文件、.zip 是压缩文件等。</p></li><li><p>Linux 与 Windows 不同，Linux 下的文件并没有标准扩展名，Linux 也不是根据扩展名 来识别文件，而是根据文件头来识别文件类型。</p></li><li><p>尽管在大多数 Linux 发行版中，默认情况下都能以不同颜色显示目录以及不同类型的文 件，但是根据颜色只能简单粗略判断常用类型文件。要准确确定一个文件的类型，必须依赖 于 file 命令。file 命令能读取文件头并识别文件类型，包括目录。用法：</p><pre class=" language-shell"><code class="language-shell">$ file 文件</code></pre><p>说明：只能查看具有可读属性的文件。</p><p>file 命令还可以查看二进制可执行文件的详细信息，包括所运行的处理器体系结构。在 PC 机上用 gcc 编译得到的程序，用 file 命令查看：</p><pre class=" language-shell"><code class="language-shell">vmuser@Linux-host: hello$ file hellohello.x86: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked (uses shared libs), forGNU/Linux 2.6.9, not stripped</code></pre><p>而经过 arm-linux-gcc 交叉编译之后再次查看：</p><pre class=" language-shell"><code class="language-shell">vmuser@Linux-host: hello$ file hellohello: ELF 32-bit LSB executable, ARM, version 1, dynamically linked (uses shared libs), for GNU/Linux 2.6.27,not stripped</code></pre><p>如果运行某个程序出现 cannot execute binary file 这的错误，很有可能是文件编译的目标 体系结构与当前所运行的体系结构不一致，可用 file 这样的命令进行确认。</p></li></ul></li><li><p><strong>查看文件内容</strong></p></li><li><ul><li><p>准确判断文件类型类型后，对于 ASCII 码文件，无需使用特殊软件仅仅用 Linux 的命令 就可以查看，如文本文件、C 代码文件、Shell 脚本文件等。Linux 下可以查看文件内容的命 令命令有好几个，如 more/less、head/tail、cat 等。</p></li><li><p>用 more 和 less 命令查看：more 和 less 两个命令都可用来浏览文本文件，可以分页查看文件内容，空格翻页。文 件浏览完毕，按键盘 q 退出。用法：</p><pre class=" language-shell"><code class="language-shell">$more/less 文件</code></pre><p>相比来说 less 命令更加灵活，支持键盘的 Page Up 和 Page Down 键，可任意向前先后翻 页浏览，并且还支持文本搜索。使用 less 打开文件后，输入/abc 可在文本中搜索字符串 abc， 匹配的字符串高亮显示。</p></li><li><p>用 head/tail 命令查看：head 和 tail 这两个命令可分别查看文件头部和文件尾部，一般用于查看 ASCII 文件。默 认显示 10 行，可加上参数指定显示内容的多少，支持的参数如表所列。用法：</p><pre class=" language-shell"><code class="language-shell">$head/tail [选项][参数] 文件</code></pre><p><img src="21.png"> </p><p>指定显示多少行：</p><pre class=" language-shell"><code class="language-shell">$ head -n 20 install.cf</code></pre><p>指定显示多少字节：</p><pre class=" language-shell"><code class="language-shell">$ head -c 300 install.cf</code></pre></li></ul></li><li><ul><li><p>用 cat 命令查看：cat 命令可以将一个或者多个文件输出到标准输出上，可以用于文件查看。用法：</p><pre class=" language-shell"><code class="language-shell">$ cat 文件</code></pre></li></ul></li><li><p><strong>文件合并</strong></p></li><li><ul><li><p>cat 命令可以将一个或者多个文件输出到标准输出，如果将标准输出重定位到某个文件， 则将多个文件合并一个文件。用法：</p><pre class=" language-shell"><code class="language-shell">$ cat [选项] 文件 1 文件 2 … [>文件 3]</code></pre><p>如果不加选项，则原封不动的显示各个文件，加上一些参数的话，可以对原文件进行一 些处理</p><p><img src="22.png"> </p><p>如果使用重定向符（&gt;）可以将屏幕输出保存到另一个文件中，或者追加符（&gt;&gt;）可以 将屏幕输出添加到某个文件末尾。示例，将 hello.c 和 Makefile 文件增加行号后合并为 test 文件：</p><pre class=" language-shell"><code class="language-shell">$ cat -n hello.c Makefile > test</code></pre><p>（1）重定向符（&gt;）可以将标准输出重定向到其它输出或者文件，文件不存在则会创建新文件； </p><p>（2）追加符（&gt;&gt;）则将标准输出追加到文件末尾，如果文件不存在则创建新文件；</p></li></ul></li><li><p><strong>文件压缩/解压</strong></p></li><li><ul><li><p>tar 是 UNIX 系统的一个文件打包工具，只是连续首尾相连的将文件堆放起来，并不具 备压缩功能，但是加上选项，tar 可以调用其它压缩/解压工具，能够实现文件的压缩和解压。 用法：</p><pre class=" language-shell"><code class="language-shell">$tar [选项] 文件</code></pre><p>tar 工具常用选项</p><p><img src="23.png"> </p></li></ul></li><li><p><strong>文件改名和移动</strong></p></li><li><ul><li><p>在 Linux 下，文件移动和改名都是通过 mv 命令实现的，且移动和改名可以同时实现。用法：</p><pre class=" language-shell"><code class="language-shell">$mv 源文件/目录 目的文件/目录</code></pre><p>若目的路径与源路径不相同，则进行移动操作，如相同则进行改名操作。</p><p>讲删除命令的时候，提到删除的文件不会在回收站暂存，在通用桌面 Linux，一般都设有回收 站，在桌面下删除一般会暂存在回收站，在命令行下若要想将某个文件暂存回收站，只能用 mv 命令，将文 件移动到回收站中。Linux 下的回收站，一般在主目录下，为隐藏文件.Trash，不同发行版回收站的路径 也各不相同。Ubuntu 的回收站目录是“~/.local/share/Trash”。 </p><p>Ubuntu 图形界面下的删除，实际上都是 mv 指令，将“删除”的文件移动到回收站，清空垃圾桶才是 用 rm 命令彻底删除。</p></li></ul></li><li><p><strong>文件复制</strong></p></li><li><ul><li><p>cp 命令用法：</p><pre class=" language-shell"><code class="language-shell">$cp [选项] 源文件/目录 目的文件/目录</code></pre><p><img src="24.png"> </p><p>通过 cp 命令，可以在同一目录下将文件/目录复制为另外一个文件/目录，也可将文件/ 目录复制到其它目录，还可用其它文件名</p></li></ul></li><li><p><strong>创建链接</strong></p></li><li><ul><li><p>链接文件在 Linux 系统中很常见，特别是库文件目录以及/etc 下与启动级别相关的目录。 例如“/etc/rc5.d/S99rc.local”文件，实际上是链接到“/etc/init.d/rc.local”文件的一个软链接。</p></li><li><p>Linux 创建链接的命令为 ln，用法：</p><pre class=" language-shell"><code class="language-shell">$ ln 选项 源文件/目录 目标文件</code></pre><p>Linux 下的链接分软链接和硬链接两种，默认创建硬链接，选项加上-s 则创建软链接。</p><p><strong>硬链接</strong>通过索引节点进行链接，相当于源文件的镜像，占用源文件一样大小的空间，修 改其中任何一个，另外一个都会进行同样的改动。给一个文件创建硬链接后，文件属性的硬 连接数会增加。</p><p>硬链接不能跨文件系统，只能在同一个文件系统内进行链接，且不能对目录文件建立硬 链接。给目录创建硬链接会出错。</p><p><strong>软链接</strong>和硬链接不同，软链接是产生一个新文件，这个文件指向另一个文件的位置，类 似于 Windows 下的快捷方式。通常用的更多的是软链接，软链接可以跨文件系统，且可用 于任何文件，包括目录文件。</p></li></ul></li><li><p><strong>改变文件和目录权限</strong></p></li><li><ul><li><p>Linux 系统是一个真正的多用户操作系统，系统的每个目录和文件对不同用户开放都有 不同的权限。一个普通文件/bin/bash 的 ls -l 输出信息：</p><pre class=" language-shell"><code class="language-shell">vmuser@Linux-host: ~$ ls -l /bin/bash-rwxr-xr-x 1 root root 917888 2010-08-11 04:47 /bin/bash</code></pre><p>其中的 rwxr-xr-x 是权限信息，说明如图 </p><p><img src="25.png"> </p><p>输出信息第一列表示文件访问权限，该示例详细说明 </p><p>第一个字符是-，表示这是一个普通文件，如果是 b 则表示是块设备，是 c 则表示是字 符设备，是 d 则表示是目录，是 l 则表示是链接文件，p 表示命名管道，s 表示 Socket 文件。 </p><p>接下来的 9 个字符 rwxr-xr-x，分成三组</p><p><img src="26.png"> </p><p>权限字符中，ls -l 结果中，用 r/w/x 表示的则表示拥有相应的权限，用“-”表示的则表 示没有相应的权限，拥有权限的用数字表示结果为“读/写/执行”3 个数字相或得到，如 rwx 可用 7 表示，r-x 可用 5 表示，rwxr-xr-x 则可用 755 表示。</p><p>chmod 用于改变或者设置文件/目录的权限。用法：</p><pre class=" language-shell"><code class="language-shell">$chmod [参数] 文件/目录</code></pre><p>设置或者改变文件/目录的权限，可直接用八进制表示，如将 hello 文件设置为任何人都 可以读写并执行</p><pre class=" language-shell"><code class="language-shell">vmuser@Linux-host: hello$ chmod 777 hello</code></pre><p>更常用的是用字符方式设定文件/目录的权限，分别用 u/g/o 表示文件的拥有者/组内用 户/其它用户，用 rwx 分别表示读/写/执行权限，用+/-表示增加或去除某种权限。例如，将 hello 文件的其它用户权限可执行属性去掉：</p><pre class=" language-shell"><code class="language-shell">vmuser@Linux-host: hello$ chmod o-x hello</code></pre><p>如果同时设置 u/g/o，可用 a 表示，例如为 hello 增加全部用户可执行权限：</p><pre class=" language-shell"><code class="language-shell">vmuser@Linux-host: ~$ chmod a+x hello</code></pre><p>拥有可执行权限的文件，在 Linux 终端下通常呈现为绿色。如果在运行程序的时候遇 到 permission dennied 这样的错误提示，可在终端输入 chmod +x file，为将要运行的程序增 加可执行权限。</p></li></ul></li></ul><h3 id="3-2-4-网络操作命令"><a href="#3-2-4-网络操作命令" class="headerlink" title="3.2.4 网络操作命令"></a>3.2.4 网络操作命令</h3><ul><li><p><strong>网络配置</strong></p></li><li><ul><li><p>ifconfig 命令是 Linux 系统配置网卡的命令工具，可用于查看和更改网络接口的地址和 参数，包括 IP 地址、广播地址、子网掩码和物理地址，也可激活和关闭网卡。需root，用法：</p><pre class=" language-shell"><code class="language-shell">$ifconfig 网络接口 [选项] 地址/参数</code></pre><p>参数：</p><p><img src="27.png"> </p></li></ul></li><li><p><strong>ping 命令</strong></p></li><li><ul><li><p>在 Linux 命令行下，可用 ping 命令来检查。用法：</p><pre class=" language-shell"><code class="language-shell">$ping IP 地址</code></pre><p>如果没有进行特殊的路由设置，通常情况下只能 ping 同网段的主机，不能跨网段 ping 操作。</p></li></ul></li><li><p><strong>安装和卸载文件系统</strong></p></li><li><ul><li><p>Linux 允许多个文件系统存在于同一个系统中，也允许用户在系统运行中安装内核所支 持的文件系统。例如，将一个 FAT 格式的 U 盘插入到 Linux 系统中。需root</p><pre class=" language-shell"><code class="language-shell"># mount [-参数] [设备名称] [挂载点]</code></pre><p>mount 命令支持的参数较多</p><p><img src="28.png"> </p><p><img src="29.png"> </p><ul><li>（1）挂载点必须是一个已经存在的目录； </li><li>（2）如果挂载点非空，则挂载后之前的内容将不可用，卸载后方可用； </li><li>（3）一个挂载点可被多个设备/文件重复挂载，只是后一次挂载将覆盖前一次内容，卸载后可用； </li><li>（4）使用多个-o 参数的时候，-o 只用一次，参数之间用半角逗号隔开。</li></ul></li><li><p>假如需要在 Linux 系统中使用 FAT 格式的 U 盘，则需要进行挂载，实现文件系统安装：</p><pre class=" language-shell"><code class="language-shell">#mount –t vfat /dev/sda1 /mnt</code></pre><p>在进行嵌入式 Linux 开发过程中，mount 命令经常被使用，特别是进行 NFS 连接和调试 的时候，通过 NFS 挂载，将远程主机 Linux 的某个共享目录挂载到嵌入式系统本地，当成 本地设备进行操作。NFS 挂载范例：</p><pre class=" language-shell"><code class="language-shell">[root@zlg /]#mount -t nfs 192.168.1.138:/home/chenxibing/lpc3250 /mnt -o nolock</code></pre><p>nolock 表示禁用文件锁，当连接到一个旧版本的 NFS 服务器时常加该选项。 </p><p>此外，嵌入式开发中常用的文件系统还有 cramfs、jffs2、yaffs/yaffs2 以及 ubifs 等，特别是用于 NOR Flash 的 jffs2 和用于 NAND Flash 的 yaffs/yaffs2、ubifs 等，在进行系统操作中通常需要对各设备进行挂载或者卸载，需要在挂载的时候指定正确的文件系统类型。挂载yaffs2 分区的命令示例：</p><pre class=" language-shell"><code class="language-shell">#mount -t yaffs2 /dev/mtdblock2 /mnt</code></pre><p>挂载 ubifs 分区的命令示例：</p><pre class=" language-shell"><code class="language-shell">#mount -t ubifs ubi0:rootfs /mnt</code></pre></li></ul></li><li><p><strong>文件系统卸载</strong></p></li><li><ul><li><p>当不再需要某个文件系统的时候，可以将其卸载。umount 用于卸载已经挂载的设备或 者文件。用法：</p><pre class=" language-shell"><code class="language-shell">#umount 挂载点</code></pre><p>如果已经将 U 盘挂载到/mnt 目录下，用完后的卸载命令为：</p><pre class=" language-shell"><code class="language-shell">[root@zlg /]# umount /mnt</code></pre></li></ul></li><li><p><strong>使用内核模块和驱动</strong></p></li><li><ul><li><p><strong>加载（插入）模块</strong></p></li><li><p>Linux 是一个具有模块化特性操作系统，允许在内核运行中插入模块或者卸载不再需要 的模块。能够动态加载和卸载模块是 Linux 引以为豪的特性之一，如果某些功能平时用不到， 可以不用编进内核，而采取模块方式编译，在需要的时候再插入内核，不再需要的时候卸载， 这样可以精简内核，提高效率，并提高系统的灵活性。Linux 中最常见的模块是内核驱动， 掌握模块的加载和卸载，也是使用 Linux 必须掌握的方法之一。</p></li><li><p>通过 insmod 命令可以往正在运行中的内核插入某些模块而无需重启系统。用法：</p><pre class=" language-shell"><code class="language-shell"># insmod [选项] 模块 [符号名称=值]</code></pre><p>insmod 常用选项介绍</p><p><img src="30.png"> </p><p>插入和卸载模块需要 root 权限。插入模块比较简单，如需要往系统插入 beep.ko 驱动模 块，可用：</p><pre class=" language-shell"><code class="language-shell">[root@zlg beep]# insmod beepdrv.ko</code></pre></li><li><p><strong>查看系统已经加载的模块</strong></p></li><li><p>如果想要知道某个模块是否已经插入系统，或者想知道系统加已经载了哪些模块，可用 lsmod 命令查看。Lsmod 命令用法：</p><pre class=" language-shell"><code class="language-shell">vmuser@Linux-host: ~$lsmod</code></pre><p>lsmod 命令结果实际上就是列出/proc/modules 的内容</p></li><li><p><strong>卸载驱动模块</strong></p></li><li><p>当某个内核模块或者驱动不再需要被使用，则可以将其从系统中卸载，以释放所占用的 资源。卸载模块用 rmmod 命令，用法：</p><pre class=" language-shell"><code class="language-shell"># rmmod [选项] 模块</code></pre><p>rmmod 命令常用可选项</p><p><img src="31.png"> </p><p>如果一个模块正在被另外一个模块所依赖，或者正在被某个应用程序使用，则一般情况 下无法卸载这个模块。如果内核支持强制卸载模块功能，加上-f 可以卸载，但是不要轻易使 用，否则有可能会带来严重错误。假定系统的 beep.ko 不再需要，卸载命令：</p><pre class=" language-shell"><code class="language-shell">[root@zlg beep]# rmmod beepdrv.ko</code></pre></li><li><p><strong>自动处理可加载模块</strong></p></li><li><p>前面提到的 insmod/rmmod 分别用于加载和卸载模块，但是每次只能加载/卸载一个模块， 如果一个模块依赖于多个模块，则需要进行多次操作，比较繁琐。modprobe 命令集加载/卸载功能于一身，并且可以自动解决模块的依赖关系，将某模块所依赖的其它模块全部加载。 用法：</p><pre class=" language-shell"><code class="language-shell"># modprobe [选项] 模块 [符号=值]</code></pre><p>modprobe 也支持很多选项，常用选项如</p><p><img src="32.png"> </p><p>modprobe 处理模块时忽略模块的路径，这要求系统模块和驱动是按照 make modues_install 方式安装的，即模块必须放在/lib/modules/$(uname -r)目录下，并且有正确的 /lib/modules/$(uname -r)/modules.dep 文件，modprobe 根据该文件来寻找和解决依赖关系。</p></li><li><p><strong>创建设备节点</strong></p></li><li><p>如果系统不能自动创建设备节点，加载驱动后，则需要为驱动建立对应的设备节点，否则无法通过驱动来操作设备。只有 root 用户才能创建设备节点，命令为 mknod，用法：</p><pre class=" language-shell"><code class="language-shell">#mknod 设备名 设备类型 主设备号 次设备号</code></pre><p>如需要创建一个字符设备 led，主设备号为 231，次设备号为 0，则命令如下：</p><pre class=" language-shell"><code class="language-shell">#mknod /dev/led c 231 0</code></pre></li></ul></li></ul><h3 id="3-2-5-重启和关机"><a href="#3-2-5-重启和关机" class="headerlink" title="3.2.5 重启和关机"></a>3.2.5 重启和关机</h3><p>重启系统用 reboot 命令，关机用 poweroff 命令，两者都需要 root 权限。</p><h3 id="3-2-6-其它命令"><a href="#3-2-6-其它命令" class="headerlink" title="3.2.6 其它命令"></a>3.2.6 其它命令</h3><ul><li><p><strong>临时获取 root 权限</strong></p></li><li><p>在普通用户权限下，Linux 下很多命令都是不能使用的，一般在/sbin 和/usr/sbin 目录下 的命令，执行都需要 root 权限。sudo 命令则可以临时获取 root 权限，需要输入密码。用法：</p><pre class=" language-shell"><code class="language-shell">$ sudo 命令</code></pre><p>例如，当前登录用户是普通用户，想挂载一个新的文件系统，则可以这样操作：</p><pre class=" language-shell"><code class="language-shell">$ sudo /sbin/mount [参数]</code></pre><p>根据发行版的不同，普通用户无法搜索 root 用户的搜索目录，所以最好指定命令所在的绝对路径。</p><p>另外，通过普通命令还可操作只有 root 才能操作的文件。假定文件 root.ini 只有 root 用户才能修改，现在普通用户想修改，可以这样操作：</p><pre class=" language-shell"><code class="language-shell">$ sudo vim root.ini</code></pre><ul><li>（1）sudo 只能临时获取 root 权限，通常一段时间之内，如 5 分钟之内再次使用 sudo，无需输入密码，超过这段时间则需再次输入密码。 </li><li>（2）使用 sudo 命令需要管理员将用户添加到 sudoer 组中，一般在/etc/sudoers 文件中修改。</li><li>另外 su 命令则是切换到 root 用户，只要不用 exit 退出，将都处在 root 权限下，这样比较危险，一般不推荐使用 su 命令。</li></ul></li><li><p><strong>文件同步</strong></p></li><li><p>经常会遇到这样的情形：刚刚修改了某个文件，突然断电，重启后发现刚刚做的修改并没有保存，或者被修改的文件已经损坏。这是由于 Linux 中，对文件的操作都是先保存在缓存中，并没有立即写入磁盘，经系统调度后方可写入磁盘。如果修改了缓存，还没来得及写到磁盘就断电，自然会造成文件改变丢失。 </p></li><li><p>要避免这种情况发生，就是修改文件后，立即强制进行一次文件同步操作，将缓存的内 容写入磁盘，确保文件系统的完整性。能完成这样功能的命令是 sync。只需在关闭文本编 辑器后在 Shell 输入 sync 即可。</p></li><li><p><strong>文件搜索</strong></p></li><li><p>find 是 Linux 下很常用的查找命令，功能很强大，用法也很复杂，这里仅仅介绍常用的简单用法。find 命令基本语法：</p><pre class=" language-shell"><code class="language-shell">$find 路径 –选项 其它</code></pre><p>最常用的是根据文件名来查找，加上-name 参数就可以了，还可以支持通配符，进行模糊搜索。例如只大概知道内核源码“arch/arm”目录下有文件名以 mux 开头的文件，但不知道确切文件名，可用下列命令搜索：</p><pre class=" language-shell"><code class="language-shell">$find arch/arm/ -name mux*.c</code></pre></li><li><p><strong>字符串搜索</strong></p></li><li><p>grep 是 Linux 系统中一个强大的文本搜索工具，用法很多很复杂，这里也仅仅介绍简单 的常用用法。语法格式：</p><pre class=" language-shell"><code class="language-shell">$grep 选项</code></pre><p>只要提供查找的关键字，用 grep 命令就可以完成查找。例如，想知道 pcf8563 这个关键字在“arch/arm”目录下哪些地方用到了，可以输入下列命令：</p><pre class=" language-shell"><code class="language-shell">$grep ―pcf8563‖ -R arch/arm</code></pre><p>关键字最好加上双引号，特别是包含空格的关键字，对于单个关键字倒是可以不用引号。“-R”表示进行递归查找，而不是仅仅在指定的目录下查找。</p></li></ul><h2 id="3-3-Shell文件"><a href="#3-3-Shell文件" class="headerlink" title="3.3 Shell文件"></a>3.3 Shell文件</h2><p>Shell 文件是以某种方式将一些命令放在一起得到的文件，常称为 Shell 脚本。Shell 文 件通常以“#!/bin/sh”开始，#!后面指定解释器，如下是一个简单的 Shell 文件的内容：</p><pre class=" language-shell"><code class="language-shell">#!/bin/shecho ―hello, I am shell script‖</code></pre><p>假定此文件名为 a.sh，增加可执行权限后，在 Shell 中即可运行，将在终端打印“hello, I am shell script”字符串。</p><pre class=" language-shell"><code class="language-shell">$chmod +x a.sh$./a.shhello, I am shell script</code></pre><p>执行 Shell 脚本有多种方式： </p><p>（1）点+斜线+文件名，这种方式要求文件必须有可执行权限； </p><p>（2）点+空格+文件名，这种方式不要求文件一定具有可执行权限。 </p><p>（3）sh+空格+文件名，这种方式不要求文件一定具有可执行权限。 </p><p>（4）source+空格+文件名，这种方式不要求文件一定具有可执行权限。</p><h2 id="3-4-Linux环境变量"><a href="#3-4-Linux环境变量" class="headerlink" title="3.4 Linux环境变量"></a>3.4 Linux环境变量</h2><h3 id="3-4-1-环境变量"><a href="#3-4-1-环境变量" class="headerlink" title="3.4.1 环境变量"></a>3.4.1 环境变量</h3><p>Linux 是一个多用户操作系统，每个用户都有自己专有的运行环境。用户所使用的环境由一系列变量所定义，这些变量被称为环境变量。系统环境变量通常都是大写。</p><p><img src="33.png"> </p><p>在 Shell 下通过美元符号（$）来引用环境变量，使用 echo 命令可以查看某个具体环境变量的值。例如，查看 TERM 的值：</p><pre class=" language-shell"><code class="language-shell">$echo $TERM</code></pre><p>使用 env 或者 printenv 命令可以查看系统全部的环境变量设置。</p><h3 id="3-4-2-修改环境变量"><a href="#3-4-2-修改环境变量" class="headerlink" title="3.4.2 修改环境变量"></a>3.4.2 <strong>修改环境变量</strong></h3><p>登录用户可以根据需要修改和设置环境变量。Linux 下修改环境变量既可以在终端通过Shell 命令修改，也可以通过修改系统的配置文件来进行。</p><p>（1）通过 Shell 命令设置环境变量，常用于临时设置环境变量，一旦关闭当前终端或者新开一个终端，所设置的环境变量都将丢失。可直接用等号（=）为变量赋值，或者用export命令为变量赋值，用法：</p><pre class=" language-shell"><code class="language-shell">$ 变量=$变量:新增加变量值$ export 变量=$变量:新增加变量值</code></pre><p>新增加的变量值既可以放在变量原有值的末尾（$变量:新变量值），也可以放在原有变量值的开头（新变量值:$变量）。</p><p>如：</p><pre class=" language-shell"><code class="language-shell">vmuser@Linux-host: ~$ echo $PATH/usr/lib/qt-3.3/bin:/usr/kerberos/bin:/usr/local/ruby/bin:/opt/mysql5/bin:/usr/lib/ccache:/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin[chenxibing@fedora ~]PATH=$PATH:/opt/usr/bin[chenxibing@fedora ~]echo $PATH/usr/lib/qt-3.3/bin:/usr/kerberos/bin:/usr/local/ruby/bin:/opt/mysql5/bin:/usr/lib/ccache:/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/opt/usr/bin</code></pre><p>（2）修改系统配置文件。修改系统配置文件，可以达到永久改变环境变量的目的。修改某个配置文件后，在 Shell 下运行该文件即可使新的设置生效，或者重新登录使用新的变量。运行文件可用“source 文件”的方式操作。通常修改/etc/profile 文件或者<del>/.bashrc（有 的发行版上为</del>/.bash_profile）文件：</p><ul><li>修改/etc/profile 文件会影响使用本机的全部用户；</li><li>修改~/.bashrc 则仅仅影响当前用户；</li><li>推荐修改~/.bashrc 文件。</li></ul><h1 id="4-Linux文件系统"><a href="#4-Linux文件系统" class="headerlink" title="4.Linux文件系统"></a>4.Linux文件系统</h1><h2 id="4-1-Linux目录结构"><a href="#4-1-Linux目录结构" class="headerlink" title="4.1 Linux目录结构"></a>4.1 Linux目录结构</h2><p>Linux 文件系统对文件的管理包括两方面，一方面是文件本身，另一方面是目录管理。先从目录入手，会显得比较直观和更加容易理解一些。</p><h3 id="4-1-1-Linux目录树"><a href="#4-1-1-Linux目录树" class="headerlink" title="4.1.1 Linux目录树"></a>4.1.1 Linux目录树</h3><p>Linux 整个文件系统以根目录（/）为最顶层目录，下面包含众多和多级其它目录，形成 了一个拓扑结构，整个目录结构看起来就像一棵倒挂着的树，称之为“Linux 目录树”，如图，整个 Linux 有且只有这样一棵树。</p><p><img src="34.png"> </p><p>这个目录树实际上是一个虚拟的概念，并不与任何文件、任何介质绑定，也没有容量，甚至连读写规则都没有。只有将某个介质如磁盘或者光驱挂载（mount）到这棵树的某个目录后，这个目录下面才有文件。但是，此时这个目录依旧没有容量的概念，看到的容量仅仅是这个磁盘或者光驱这个设备的容量属性，并不是文件系统的属性。</p><p>由于这棵树是虚拟的，没有任何限制，所以很容易进行扩展。</p><h3 id="4-1-2-Linux目录树标准"><a href="#4-1-2-Linux目录树标准" class="headerlink" title="4.1.2 Linux目录树标准"></a>4.1.2 Linux目录树标准</h3><p>理论上，Linux 目录树的目录结构是可以随意安排的，事实上很多 Linux 系统开发人员也这么做，但这就带来了不同开发人员之间不统一的情况存在，很容易出现混乱。后来这样的问题得到了重视，文件层次标准（FHS，Filesystem Hierarchy Standard）就在这种情况下出台的。FHS 对 Linux 根文件系统的基本目录结构做了比较详细的规定，尽管不是强制标准，但事实上，大部分 Linux 发行版都遵循这个标准。 </p><p>Linux 目录树下各子目录的简单说明如表</p><p><img src="35.png"> </p><p><img src="36.png"> </p><h2 id="4-2-Linux的文件"><a href="#4-2-Linux的文件" class="headerlink" title="4.2 Linux的文件"></a>4.2 Linux的文件</h2><h3 id="4-2-1-Linux文件结构"><a href="#4-2-1-Linux文件结构" class="headerlink" title="4.2.1 Linux文件结构"></a>4.2.1 Linux文件结构</h3><p>文件是数据的一种组织形式，是具有文件名的一组相关信息的集合，是文件系统中存储数据的一个命名的对象。Linux 下一切都是文件，无论程序、文档、数据库这样的普通文件，还是链接文件和目录这样的特殊文件，甚至于连硬件设备都用文件来描述。Linux 下所有文件的描述结构都是相同的，包含索引节点和数据。</p><p><img src="37.png"> </p><p><strong>索引节点</strong>：又称 I 节点，是 Linux 文件系统用来记录文件信息的一种数据结构，信息包括包括文件名、文件长度、文件权限、存放位置、所属关系、创建和修改时间等。文件系统维护了一个索引节点的数组，每个文件都与索引节点数组中的唯一元素对应，索引节点在数组中的索引号，称为索引节点号。每个文件都有一个索引号与之对应，而一个索引节点号，可以对应多个文件。</p><p><strong>数据</strong>：文件的实际内容。可以是空的，也可以非常大，并且拥有自己的结构。 一个文件的索引节点、文件大小、属主等信息，在 Shell 下可用 ls 命令加上参数-i 查看</p><pre class=" language-shell"><code class="language-shell">chenxibing@gitserver-zhiyuan:~$ ls -li examples.desktop785326 -rw-r--r-- 1 chenxibing root 179 2010-10-15 09:07 examples.desktop</code></pre><p>各信息说明</p><p><img src="38.png"> </p><p>文件数据信息则需要用相关的编辑器或者软件才能查看。</p><h3 id="4-2-2-Linux文件名称"><a href="#4-2-2-Linux文件名称" class="headerlink" title="4.2.2 Linux文件名称"></a>4.2.2 Linux文件名称</h3><p>Linux 的文件名保存目录文件中，命名应当遵循以下规则</p><ul><li>区分大小写；</li><li>不能以“+”和“-”开头；</li><li>不能包含&lt; &gt; ；| ` ―‘ $! % &amp;*?\ () []等在 Shell 中有特殊含义的字符；</li><li>不能包含空格；</li><li>长度不能超过 255 个字符</li></ul><p>Linux 系统中，文件名以点号(.)开始的文件是隐藏文件，用 ls 命令不加参数-a 将看不到在这类文件。“同名”的隐藏文件与非隐藏文件是不同的，如.file 与 file 是两个不同的文件。</p><h3 id="4-2-3-文件类型"><a href="#4-2-3-文件类型" class="headerlink" title="4.2.3 文件类型"></a>4.2.3 文件类型</h3><p>Linux 系统中的文件可以分为如下几类：普通文件、目录文件、设备文件和符号链接文 件。</p><ul><li><p><strong>普通文件</strong></p></li><li><ul><li><p>普通文件又称常规文件，包含各种长度的字符串。常见的 C 程序文件、脚本文件、数据库文件等都是文件。普通文件在 Linux Shell 下用 ls 命令查看，得到的信息中，第一个字 符是“-”。如：</p><pre class=" language-shell"><code class="language-shell">-rw------- 1 chenxibing member 10732 2011-01-08 13:28 .bash_history</code></pre></li></ul></li><li><p><strong>目录文件</strong></p></li><li><ul><li><p>目录文件是一种特殊文件，利用它可以构成文件系统的分层树形结构。在 Linux Shell下用 ls 命令查看，第一个字符用 d 表示。如：</p><pre class=" language-shell"><code class="language-shell">drwxr-xr-x 3 chenxibing member 4096 2010-11-27 14:02 abingdrwxr-xr-x 4 chenxibing member 4096 2010-10-19 14:00 git</code></pre></li></ul></li><li><p><strong>设备文件</strong></p></li><li><ul><li><p>设备是一种特别文件，除了存放在文件 i 节点中的信息外，它们不包含任何数据。有效地设备文件与相应的设备对应，通过设备文件，可以操作与之对应的硬件设备。</p></li><li><p>设备文件包括字符设备和块设备文件。字符设备文件按照字符操作设备, 如键盘、终端 等;块设备文件以块为单位操作设备，如磁盘、光盘等。Linux 系统的设备文件都放在/dev 目录下，用 ls –la 命令可以查看各设备的属性：</p><pre class=" language-shell"><code class="language-shell">crw-rw-rw- 1 root root 1, 8 2011-01-08 15:12 randomcrw-r--r-- 1 root root 10, 135 2011-01-08 15:12 rtcbrw-rw---- 1 root disk 8, 0 2011-01-08 15:12 sdabrw-rw---- 1 root disk 8, 1 2011-01-08 07:12 sda1</code></pre><p>输出信息中，以第一个字符用 b 表示的是块设备，用 c 表示的是字符设备。</p></li></ul></li><li><p><strong>符号链接文件</strong></p></li><li><ul><li><p>链接文件是一种特殊文件，提供对其它文件的参照，它的数据是它所链接的文件的路径名。用 ln 命令可以创建一个文件的软硬链接或者一个目录的软连接。链接文件常用于不同目录下的文件共享。链接文件按在 ls 命令下输出结果中第一个字符为字母 l, 并显示为“文 件-&gt;目标”的方式，如链接文件 git 链接到/var/server/repo-git/chenxibing，查看结果为：</p><pre class=" language-shell"><code class="language-shell">lrwxrwxrwx 1 chenxibing root 31 2010-10-22 08:37 git -> /var/server/repo-git/chenxibing</code></pre></li></ul></li></ul><h3 id="4-3-Linux文件系统"><a href="#4-3-Linux文件系统" class="headerlink" title="4.3 Linux文件系统"></a>4.3 Linux文件系统</h3><p>Linux 最初是基于 X86 设计的 ，保存文件的物理设备是磁盘或者磁带。Linux 最初用于管理磁盘文件的文件系统是基于 Minix 的，存在文件管理效率不高的问题；后来在 Minix 的基础上进行了扩展，设计了专门用于 Linux 的 Ext 扩展文件系统（Extended file system），并添加到内核中，并成为了 Linux 事实上的标准文件系统，Linux 的发布和安装都基于 Ext 文件系统。</p><p>Ext2 属于非日志型文件系统，而 Ext3/4 文件系统是日志型文件系统。日志型文件系统用独立的日志文件跟踪磁盘内容的变化，比传统文件系统安全。</p><h3 id="4-3-1-Ext3文件系统特点"><a href="#4-3-1-Ext3文件系统特点" class="headerlink" title="4.3.1 Ext3文件系统特点"></a>4.3.1 Ext3文件系统特点</h3><p>Ext3 从 Ext2 发展而来，并且完全兼容 Ext2 文件系统，且比 Ext2 可靠。在文件大小、数量和文件名方面有如下限制：</p><ul><li>最大文件大小：2TB；</li><li>最大文件数量：可变；</li><li>最长文件名限制：255 字节；</li><li>最大卷大小：16TB；</li><li>文件名允许的字符数： 除 NUL 和“/”外的所有字节。</li></ul><p>整体上，Ext3 具有下面的一些特点：</p><p>1.<strong>高可用性</strong></p><p>使用了 Ext3 文件系统后，即使在非正常关机后，系统也不需要检查文件系统。即使发生了宕机，也只需要数十秒钟即可恢复 Ext3 文件系统。</p><p>2.<strong>数据的完整性</strong></p><p>Ext3 文件系统能够极大地提高了文件系统的完整性，避免意外宕机对文件系统的破坏。 Ext3文件系统为用户提供了 2 种模式来保证数据的完整性。其中一种是“同时保持文件系统及数据的一致性”模式。如果采用这种方式，用户永远不会看到由于非正常关机而存储在磁盘上的垃圾文件。</p><p>3.<strong>文件系统的速度</strong></p><p>尽管使用 Ext3 文件系统时，有时在存储数据时可能要多次写数据，但是，从总体上看来，Ext3 比 Ext2 的性能还要好一些。因为 Ext3 的日志功能对磁盘的驱动器读写头进行了优化，所以，文件系统整体读写性能并没有降低。</p><p>4.<strong>数据转换</strong></p><p>Ext3 兼容 Ext2，从 Ext2 文件系统转换成 Ext3 文件系统非常容易，只需要简单地键入两条命令即可完成整个转换过程，用户不用花时间备份、恢复、格式化分区等。并且 Ext3 文件系统可以不经任何更改，而直接加载成为 Ext2 文件系统。</p><p>5.<strong>多种日志模式</strong></p><p>Ext3 有多种日志模式，系统管理人员可以根据系统的实际工作要求，在系统的工作速度与文件数据的一致性之间作出选择：</p><ul><li>一种工作模式是对所有的文件数据及 metadata（定义文件系统中数据的数据，即数据的数据）进行日志记录（data=journal 模式），这种模式数据一致性好；</li><li>另一种工作模式则是只对 metadata 记录日志，而不对数据进行日志记录，就是所谓的 data=ordered 或者 data=writeback 模式，这种模式工作速度快。</li></ul><h3 id="4-3-2-Ext4文件系统特点"><a href="#4-3-2-Ext4文件系统特点" class="headerlink" title="4.3.2 Ext4文件系统特点"></a>4.3.2 Ext4文件系统特点</h3><p>Ext4 在 Ext3 的基础上进行了改进，修改了一部分重要的数据结构。Ext4 在性能和可靠性方面都有更好的表现，功能方面也更加丰富。</p><p>Ext4 兼容 Ext3，从 Ext3 迁移到 Ext4，无需格式化磁盘或者重装系统。</p><p>与 Ext3 相比，Ext4 具有下列特点：</p><p>1.<strong>支持更大的文件系统和文件</strong></p><p>Ext3 支持最大的文件系统是 16TB，Ext4 支持到了 1EB（1,048,576TB， 1EB=1024PB，1PB=1024TB）；Ext3 支持的最大文件是 2TB，而 Ext4 支持到了 16TB。</p><p>2.<strong>无限数量的子目录</strong></p><p>Ext3 只支持 32,000 个子目录，而 Ext4 支持无限数量的子目录。</p><p><strong>3.Extents</strong></p><p>Ext3 采用间接块映射，当操作大文件时，效率极其低下。比如一个 100MB 大小的文件，在 Ext3 中要建立 25,600 个数据块（每个数据块大小为 4KB）的映射表。而 Ext4 引入了现代文件系统中流行的 extents 概念，每个 extent 为一组连续的数据块，上述文件则表示为“该文件数据保存在接下来的 25,600 个数据块中”，提高了不少效率。</p><p>4.<strong>多块分配</strong></p><p>当写入数据到 Ext3 文件系统中时，Ext3 的数据块分配器每次只能分配一个 4KB 的块，写一个 100MB 文件就要调用 25,600 次数据块分配器，而 Ext4 的多块分配器“multiblock allocator”（mballoc）支持一次调用分配多个数据块。</p><p>5.<strong>延迟分配</strong></p><p>Ext3 的数据块分配策略是尽快分配，而 Ext4 和其它现代文件操作系统的策略是尽可能地延迟分配，直到文件在 cache 中写完才开始分配数据块并写入磁盘，这样就能优化整个文件的数据块分配，与前两种特性搭配起来可以显著提升性能。</p><p>6.<strong>快速fsck</strong></p><p>以前执行 fsck 第一步就会很慢，因为它要检查所有的 inode，而现在 Ext4 给每个组的 inode 表中都添加了一份未使用 inode 的列表，今后 fsck Ext4 文件系统就可以跳过它们而只去检查那些在用的 node 了。</p><p>7.<strong>日志校验</strong></p><p>日志是最常用的部分，也极易导致磁盘硬件故障，而从损坏的日志中恢复数据会导致更多的数据损坏。Ext4 的日志校验功能可以很方便地判断日志数据是否损坏，而且它将Ext3的两阶段日志机制合并成一个阶段，在增加安全性的同时提高了性能。</p><p>8.<strong>无日志模式（No Journaling）</strong></p><p>日志总归有一些开销，Ext4 允许关闭日志，以便某些有特殊需求的用户可以借此提升性能。</p><p>9.<strong>在线碎片整理</strong></p><p>尽管延迟分配、多块分配和 extents 能有效减少文件系统碎片，但碎片还是不可避免会产生。Ext4 支持在线碎片整理，并将提供 e4defrag 工具进行个别文件或整个文件系统的碎片整理。</p><p>10.<strong>inode 相关特性</strong></p><p>Ext4 支持更大的 inode，较之 Ext3 默认的 inode 大小 128 字节，Ext4 为了在 inode 中容纳更多的扩展属性（如纳秒时间戳或 inode 版本），默认 inode 大小为 256 字节。Ext4 还支持快速扩展属性（fast extended attributes）和 inode 保留（inodes reservation）。</p><p>11.<strong>持久预分配（Persistent preallocation）</strong></p><p>P2P 软件为了保证下载文件有足够的空间存放，常常会预先创建一个与所下载文件大小相同的空文件，以免未来的数小时或数天之内磁盘空间不足导致下载失败。 Ext4 在文件系统层面实现了持久预分配并提供相应的 API（libc 中的 posix_fallocate()），比应用软件自己实现更有效率。</p><p>12.<strong>默认启用 barrier</strong></p><p>磁盘上配有内部缓存，以便重新调整批量数据的写操作顺序，优化写入性能，因此文件系统必须在日志数据写入磁盘之后才能写 commit 记录，若 commit 记录写入在先，而日志有可能损坏，那么就会影响数据完整性。Ext4 默认启用 barrier，只有当 barrier 之前的数据全部写入磁盘，才能写 barrier 之后的数据。</p><h3 id="4-3-3-其他文件系统"><a href="#4-3-3-其他文件系统" class="headerlink" title="4.3.3 其他文件系统"></a>4.3.3 其他文件系统</h3><p>Linux 支持多种文件系统，且同时存在于一个运行的系统中。查看“/proc/filesystems”文件，可以看到系统支持的全部文件系统。</p><pre class=" language-shell"><code class="language-shell">vmuser@Linux-host: ~$ cat /proc/filesystemsnodev sysfsnodev rootfsnodev ramfsnodev bdevnodev procnodev cgroupnodev cpusetnodev tmpfsnodev devtmpfsnodev debugfsnodev securityfsnodev sockfsnodev pipefsnodev anon_inodefsnodev devpts      ext3      ext2      ext4nodev hugetlbfs       vfatnodev ecryptfs       fuseblknodev fusenodev fusectlnodev pstorenodev efivarfsnodev mqueuenodev rpc_pipefsnodev binfmt_miscnodev nfsnodev nfs4nodev nfsd</code></pre><p>可以看到，Linux 支持很多种文件系统，这里不再一一介绍，仅对其中两个个很具有代表性的 proc 文件系统和 sysfs 文件系统进行简单说明。</p><p>1.<strong>proc 文件系统</strong></p><p>proc 是 Linux 系统中的一种特殊文件系统，是内核和内核模块用来向进程发送消息的机 制，只存在与内存中，实际上是一个伪文件系统。用户和应用程序可通过/proc 获得系统的 信息，还可以改变内核的某些参数。/proc 子目录和所包含的内容说明</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代控制理论</title>
      <link href="/2020/05/11/control/"/>
      <url>/2020/05/11/control/</url>
      
        <content type="html"><![CDATA[<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h1><p>如何像Engineer一样思考</p><p>举个例子：</p><p>假设你想要为某人准备一杯咖啡，但你并不知道这个人什么时候出现，所以你需要一个带着开关可以加热水的设备，使得水能够保持着一个合适的温度</p><p>我们来分析一下这个系统：</p><ul><li>系统的输入Input：电功率<ul><li>是通过控制开关来控制的</li></ul></li><li>系统的输出Output：水的温度<ul><li>希望保持在合适的值上</li></ul></li></ul><p>在这个系统中还有许多其他的因素在影响着，如：</p><blockquote><ul><li>水的质量</li><li>水的比热</li><li>空气温度</li><li>空气流速</li><li>传热效率</li><li>…..</li></ul></blockquote><p>如果我们完全掌握了这些量，那么这个系统就是完全可知的，但事实并不是如此，我们可以知道水的质量与水的比热，但是剩下的量并不能很好的获取</p><p>因此我们可以引入反馈系统(Feedback System)</p><p>引入变量E：</p><p>误差：Error,e            e=Twd - Tw=目标值-实际值</p><p>所以我们的系统加上反馈之后的电功率就变成了一个误差函数：</p><p>Ps = U(e)</p><p>那我们如何寻找U(e)呢？这个问题我们留到后面再讲</p><p>这里我们先来了解一些别的东西：</p><p>一些常用英语在系统中的含义</p><blockquote><ul><li>Gain→增益</li><li>Chaos→混沌</li><li>M→Mass</li><li>T→Temp</li><li>C_p→Heat capacity</li><li>E→Error</li></ul></blockquote><h1 id="2-状态空间"><a href="#2-状态空间" class="headerlink" title="2.状态空间"></a>2.状态空间</h1><p>先来看一个例子<strong>弹簧阻尼系统</strong>：</p><p><img src="0.png"></p><p>我们对质量块进行受力分析：外力f(t)、弹簧力f_k、阻尼力f_b</p><p>根据胡克定律：</p><p><img src="1.png"></p><p>根据牛顿第二定律：F=ma</p><p>我就可以得到：</p><p><img src="2.png"></p><p>在经典控制理论中，我们会用拉氏变换来找到系统的传递方程</p><p><img src="3.png"></p><p>在现代控制理论中，我们会用另一种方式也就是状态空间，状态空间可以想象成一个集合，它包含了输出、输入、状态状态变量，然后用一阶微分方程把他们表达出来</p><hr><p>回到我们的系统里，我们有一个二阶项，这显然是不对的，我们需要选择状态变量消除高阶项</p><p>我们选择系统的两个状态并化简系统：</p><p><img src="4.png"></p><p>写成紧凑的线性代数形式：</p><p><img src="5.png"></p><p>系统的输出y，y就是x就是z_1：</p><p><img src="6.png"></p><p>写成一般形式就是：</p><p><img src="7.png"></p><p>这就是系统的状态空间表达形式，对于我们这个系统来说：</p><p><img src="8.png"></p><p>现在来看看状态空间方程与传递函数之间的关系：</p><p><img src="9.png"></p><p>记住我们最后推导出来的公式，下面我们来将它化简：</p><p><img src="10.png"></p><p>得出的就是传递函数</p><p>现在来看看传递函数的分母部分，传函的分母与|SI-A|是息息相关的，令其为零即可算出一个值S,而这个S是A矩阵的特征值</p><p>对于传递函数来说，分母为零求出的解是它的极点，在经典控制理论中，一个传递函数的极点就决定它的稳定性，而同时A矩阵的特征值也有可能决定系统的稳定性，这点放在后面细讲</p><p>下面来联系一下</p><p>这是一个电力系统：</p><p><img src="11.png"></p><p>我们取两个节点，e1，e2</p><p>根据基尔霍夫电流定律：</p><p><img src="12.png"></p><p>带入化简：</p><p><img src="13.png"></p><p>这样就得到了两个状态变量对时间的倒数方程，顺便写出状态空间方程</p><hr><p>下面总结一下重点：</p><p><img src="14.png"></p><h1 id="3-相图，相轨迹"><a href="#3-相图，相轨迹" class="headerlink" title="3.相图，相轨迹"></a>3.相图，相轨迹</h1><p>这是一种分析微分方程解的方法，这里用控制的角度来理解</p><p>来看一个方程：</p><p><img src="15.png"></p><p>相图如下：</p><p><img src="16.png"></p><p>图中的小箭头代表x1，x2的流动，假设任取一点，最终都会跟着箭头流到一个稳定的点</p><p>下面主要讨论线性系统，这里放个<a href="https://ww2.mathworks.cn/matlabcentral/fileexchange/61636-pplane">网站</a>可以用来绘制这种图，网站中还有MATLAB的插件，下载下来就可以用MATLAB来绘制这种图了</p><p>假设我们有一个函数：</p><p><img src="17.png"></p><p>它与x轴有两个交点</p><p>当你的函数起始点是在x01，x02的时候，这个x就不会有变换</p><p>那么我们分析一下x01，x02周围的点：</p><p>例如：当x&lt;0,X&gt;0时，X会向着x01移动</p><p><img src="18.png"></p><p> 在看一个栗子：</p><p><img src="19.png"></p><p>这个中的点是不稳定点</p><p>对于下面这个系统而言：</p><p><img src="20.png"></p><p>它的特征点有三种情况：源点、鞍点、汇点</p><p><img src="21.png"></p><p>来看一般形式，ABCD都不为零：</p><p><img src="22.png"></p><p><img src="23.png"></p><p>我们再来看一个例子：</p><p><img src="24.png"></p><p><img src="25.png"></p><p>上面第二幅图有个错误，lamda中是没有a的</p><p><img src="26.png"></p><p>在这种情况下x1，x2是在循环往复的</p><p>再来看个例子：</p><p><img src="27.png"></p><p>e^2it和e^-2it是椭圆，e^t是随时间不断增加的</p><p>所以图形是螺旋向外的，这里要搞清楚是顺时针还是逆时针</p><p><img src="28.png"></p><p>所以它的图像是逆时针的</p><hr><p>总结：</p><p>可以通过判断系统的特征值来判断系统：</p><p><img src="29.png"></p><p>虚部带来了什么呢？</p><p>虚部引进了振动：</p><p><img src="30.png"></p><p>虚部转动的方向可以通过坐标上的一个点来判断</p><p>对于系统来说如果想让系统稳定，它一定要lamda1，lamda2小于零或者lamda的实部小于零</p><h1 id="4-关于Phase-Portrait的故事"><a href="#4-关于Phase-Portrait的故事" class="headerlink" title="4.关于Phase Portrait的故事"></a>4.关于Phase Portrait的故事</h1><p>1988Steven strogatz博士后时提出来的，现在是康奈尔大学应用数学系的教授，使用的是莎士比亚笔下的人物Romeo与Juliet</p><p>这里使用两个中文名字，图个方便</p><p>男：与非            Y(t)代表与非对梦寒的爱/恨，Y&gt;0喜欢，Y&lt;0恨</p><p>女：梦寒            M(t)代表梦寒…                         M&gt;0…        M&lt;0…</p><p>这里讨论其中一种形式：</p><p><img src="31.png"></p><p>这里我们深入讨论一下：</p><p>这里解释一下：与非爱，梦寒恨，与非的热情减少</p><p><img src="32.png"></p><p>而当移动到零界点的时候：</p><p>与非恨，梦寒对与非的态度发生了转变，梦寒恨意渐渐开始减少</p><p><img src="33.png"></p><p>而又一次移动到零界点的时候：</p><p>梦寒爱，随着梦寒态度的转变，与非恨意逐渐减少</p><p><img src="34.png"></p><p>又一次到达临界点：</p><p>梦寒爱，与非由恨转爱，但是此时梦寒的热情减少</p><p><img src="35.png"></p><p>他们就这样循环往复下去，虽然你可能觉得，这也太魔幻了点，但现实往往更加魔幻，至少在数学中，你知道她(他)是爱你的，但现实生活中谁有能说得准呢？</p><p>回归正题我们可以发现在这个例子里：</p><blockquote><ul><li>1/4相爱</li><li>1/2一半火焰，一半冰川</li><li>1/4互相看不顺眼</li></ul></blockquote><p>其实来说这是种不错的关系，因为即使是在这1/4互看不顺眼的关系中你也可以把它理解成：**<em>离别不过是换另一种方式的陪伴，这一刻让我凝望你的眼**</em></p><hr><p>让我们来看一下另一种情况：</p><p><img src="36.png"></p><p>我们来分析一下：</p><p>随着时间的推移，最终二人会变成路人</p><p><img src="37.png"></p><p>我们来看看另一种情况：</p><p>最终他们会有两种情况，就是第一和第三象限的模样，这取决一<strong>第一映像</strong>：</p><p><img src="38.png"></p><p>当Y&gt;0与非爱着梦寒，M&lt;0梦寒讨厌与非的时候，有两种情况，一种坚持不懈终成眷属，一种半途而废终成仇人</p><p>我们来讨论一下这种结果：</p><ul><li><input disabled="" type="checkbox"> <strong>|a|&gt;|b|：自我意识大于对方感受，太关注自己的意识，所以最终会成为路人</strong></li><li><input disabled="" type="checkbox"> <strong>|a|&lt;|b|：自我意识小于对方感受，最终会有两种结果，坠入爱河和因爱生恨</strong></li></ul><p>这就验证了很多人宁愿做朋友也不愿意打破平衡</p><p>不认真赢不了，而认真也可能就输了</p><hr><p>总结一下：</p><p><img src="39.png"></p><p><img src="40.png"></p><p>拿数学去描述爱情终究是不行的，现实生活中充满了不确定性，这些不确定性才让我们感觉自己是活着的，无论这不确定是好事坏</p><h1 id="5-系统的可控性-Controllability"><a href="#5-系统的可控性-Controllability" class="headerlink" title="5.系统的可控性(Controllability)"></a>5.系统的可控性(Controllability)</h1><p>假设有这么一个例子：</p><p><img src="41.png"></p><p>我们可以通过控制小车的速度u</p><p>使得小车可以达到我们想要的位置x和x一点</p><p>这时候我们给它加一个拖挂，一个通过弹簧链接的车斗子</p><p>这时候我们是否还能通过u控制x和x一点呢？</p><p><img src="42.png"></p><p>一个系统的可控性它的定义是这样的：</p><p><img src="43.png"></p><p>简单而言：</p><p><img src="44.png"></p><p><img src="45.png"></p><p>也就是说，如果一系统可控，那么Co矩阵的秩一定等于n</p><p>来看一个例子：</p><p><img src="46.png"></p><p>来看另外一个例子：</p><p><img src="47.png"></p><p>可控性是点对点的可控还是轨迹上的可控？</p><p>对于这个系统，如果我们有一个x0，我们希望将他移动到xt：</p><p><img src="48.png"></p><p>那么不能直接由右至左，因为它的速度是向右的，所以我们只能不断减小速度，直到为零时施加向左方向力，让它朝左运动：</p><p><img src="49.png"></p><p>所以这其实是一个点对点的可控，我们不一定可以完全让它按照我们设定的点运动</p><p>我们看一下最开始的那个问题：</p><p><img src="50.png"></p><p>他就可以写成下面的形式：</p><p><img src="51.png"></p><p>我们可以用Matlab求解一下：</p><p><img src="52.png"></p><p>我们惊讶的发现，它竟然是可控的</p><hr><p>总结：</p><p><img src="53.png"></p><p>即使一个系统理论可控，但在实际系统中还需要考虑多种物理因素的约束</p><h1 id="6-稳定性-Stability-Lyapunou"><a href="#6-稳定性-Stability-Lyapunou" class="headerlink" title="6.稳定性(Stability-Lyapunou)"></a>6.稳定性(Stability-Lyapunou)</h1><p>我们看个例子</p><p><img src="54.png"></p><p>当三个小球离开自身位置之后，只有C球可以稳定的回到原点</p><p>我们观察现象之后，可以不严谨的说：稳定系统，离开平衡点后的反应随时间衰减，至少不增加….</p><p>A,C是稳定点，B是不稳定的</p><p>这里我们来看一下严谨的数学定义：</p><p><img src="55.png"></p><p>第一个是lyapunov定义的</p><p>第二个是渐进稳定性</p><p>我们来看一个例子：</p><p>处于小圆外大圆内的两个点</p><p>一个蓝色x</p><p>一个红色x</p><p>蓝色x一直处在大圆内小圆外，这叫做lyapunov稳定</p><p>红色x随着时间的推移回到了平衡点，这叫渐进稳定</p><p>对于高阶系统也一样</p><p>对于线性系统来说：</p><p><img src="56.png"></p><p>对于非线性系统来说：</p><p><img src="57.png"></p><p>非线性系统有两种解法，先做第一种lyapunov解法</p><p>第一种就是求解微分方程的解法</p><p>如果我们能找到一个lyapunov函数V满足上述三种条件，我们就可以将x=0称为稳定的平衡点</p><p>这里就可以引出两个定义</p><ul><li>PSD-Positive semi definit半正定，除了零点以外其他的点都是大于等于零的</li><li>NSD-Negative半负定</li></ul><p>如果是：</p><p><img src="58.png"></p><p>这里我们来看一下一个经典的模型，弹簧阻尼系统：</p><p><img src="59.png"></p><p>我们再来看一下非线性的情况：</p><p><img src="60.png"></p><p>如何寻找lyapunov函数V是一个难点</p><h1 id="7-线性控制器设计-Linear-Controller-Design"><a href="#7-线性控制器设计-Linear-Controller-Design" class="headerlink" title="7.线性控制器设计(Linear Controller Design)"></a>7.线性控制器设计(Linear Controller Design)</h1><p><img src="61.png"></p><p>Acl:闭环状态空间矩阵</p><p>我们可以通过调整K的值来得到我们希望Acl的特征值</p><p>看一个例子：</p><p><img src="62.png"></p><p><img src="63.png"></p><p>再来看一个例子：</p><p><img src="64.png"></p><p><img src="65.png"></p><p>看一个实际应用：</p><p><img src="66.png"></p><p>得到系统的动态方程</p><p>接下来我们可以得到状态空间方程</p><p><img src="67.png"></p><p>不可控，引入u</p><p><img src="68.png"></p><p>求特征值</p><p><img src="69.png"></p><h1 id="8-LQR控制器"><a href="#8-LQR控制器" class="headerlink" title="8.LQR控制器"></a>8.LQR控制器</h1><p><img src="70.png"></p><p><img src="71.png"></p><p><img src="72.png"></p><p>我们来看之前的一个例子</p><p><img src="73.png"></p><p><img src="74.png"></p><p>simulink操作步骤</p><pre><code>首先在命令行中输入参数A矩阵B矩阵Q矩阵,决定响应和速度，前响应后速度R输入大小，在这个例子里决定能耗K=lqr(A,B,Q,R)将得到的K顺序放入Gain中例：A=[0 1;10 0]B=[0;-1]Q=[100 0; 0 1]R=0.01K=lqr(A,B,Q,R)A=[0 1;10 0]B=[0;-1]Q=[50 0; 0 1]R=10K=lqr(A,B,Q,R)将其的到参数分别输入两个系统的Gain中</code></pre><p>simulink模型如下：</p><p><img src="81.png"></p><p>上</p><p><img src="82.png"></p><p>下</p><p><img src="83.png"></p><p>输出图</p><p><img src="84.png"></p><h1 id="8-5轨迹跟踪-Follow-a-Desired-Path"><a href="#8-5轨迹跟踪-Follow-a-Desired-Path" class="headerlink" title="8.5轨迹跟踪(Follow a Desired Path)"></a>8.5轨迹跟踪(Follow a Desired Path)</h1><p><img src="75.png"></p><p>如果我们希望小球停在五度的时候该怎么办呢</p><p><img src="76.png"></p><p><img src="78.png"></p><p>图中Ef=x1d而不是Ef=g/lx1d</p><p><img src="79.png"></p><p><img src="80.png"></p><p>simulink仿真：</p><p>系统框图</p><p><img src="85.png"></p><p>仿真结果</p><p><img src="86.png"></p><p>为什么说是轨迹跟踪呢，我们可以换一个输入</p><p>系统框图</p><p><img src="87.png"></p><p>仿真结果</p><p><img src="88.png"></p><p>我们可以看到他还是能很好的跟上设定轨迹</p><h1 id="9-状态观测器-Linear-Observer-Design"><a href="#9-状态观测器-Linear-Observer-Design" class="headerlink" title="9.状态观测器(Linear Observer Design)"></a>9.状态观测器(Linear Observer Design)</h1><p><img src="89.png"></p><p>下面介绍一下luenberger观测器，线性观测器</p><p><img src="90.png"></p><p><img src="91.png"></p><p>令dotx-dotx^hat=e_x</p><p>e_x误差，就是估计值和实际值之间的误差</p><p>我们希望e_x=0</p><p><img src="92.png"></p><p>举个例子</p><p><img src="93.png"></p><p><img src="94.png"></p><p>Simulink演示</p><p><img src="95.png"></p><p><img src="96.png"></p><h1 id="10-观测性与分离原理-Observability-Separation-Principle"><a href="#10-观测性与分离原理-Observability-Separation-Principle" class="headerlink" title="10.观测性与分离原理(Observability Separation Principle)"></a>10.观测性与分离原理(Observability Separation Principle)</h1><p><img src="97.png"></p><p><img src="98.png"></p><p><img src="99.png"></p><p>如果是非线性的可以等待后续教程</p><hr><p>参考内容：<a href="https://www.bilibili.com/video/BV1yx411u7iX">https://www.bilibili.com/video/BV1yx411u7iX</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 控制理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于FOC的学习笔记</title>
      <link href="/2020/04/08/moter/"/>
      <url>/2020/04/08/moter/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于普通无刷和有刷直流电机总是存在控制精度不够、旋转过程不平滑、扭矩抖动（没通电时转动的颗粒感）等等问题，所以本次主要研究永磁同步电机PMSM</p><p>永磁同步电机是复杂的非线性系统，为了简化模型，实现控制上的解耦，需要建立相应的坐标变换，即Clark变换和Park变换</p><h1 id="1-驱动电路实现"><a href="#1-驱动电路实现" class="headerlink" title="1.驱动电路实现"></a>1.驱动电路实现</h1><p>无刷电机的驱动电路主要使用三项逆变电路来实现：</p><p><img src="0.png"></p><p>所谓<strong>逆变电路</strong>，即把<strong>直流电</strong>变换为<strong>交流电</strong>，或者简单点说就是一个可以产生不同电流流向的电路，通过前面的电机模型分析我们也可以看出，对于无刷电机的驱动是需要在不同时刻施加不同方向的电压（电流）的，因此需要逆变电路。</p><p>而逆变电路具体的实现则一般是采用<strong>半桥MOS电路</strong>来制作的。半桥电路的原型如下，其实很简单，就是两个MOS管组成的<strong>上桥臂</strong>和<strong>下桥臂</strong>，中间引出一条输出线：</p><p><img src="1.png"></p><p>用3个半桥电路就可以组合成三相逆变电路，每个半桥引出的一根输出线跟无刷电机的一根相线相连，就完成了最基本的无刷驱动电路。</p><p>原理方面，MOS管可以看作电压控制的高速电子开关，在MOS管的栅极（上图中的High Drive和Low Drive）施加高电平或者低电平，就可以控制MOS源极和漏极的导通或者关闭。比如在下图中，我们打开第一组半桥的上桥臂、第二组和第三组半桥的下桥臂（其余的关闭），那么就可以让电流<strong>从电源正极流过电机的a相，流经b、c相，然后回到电源负极</strong>：</p><p><img src="2.png"></p><p>于是通过控制三个半桥的不同开关状态，我们可以控制电流在电机中的不同流向了。</p><p><img src="4.gif"></p><p>在坐标系电压满足以下公式：</p><p><img src="5.png"></p><p>上述部分摘自<a href="http://pengzhihui.xyz/2020/07/02/foc/">博客</a></p><h1 id="2-三相电机波形"><a href="#2-三相电机波形" class="headerlink" title="2.三相电机波形"></a>2.三相电机波形</h1><p>在研究模型之前，我们先来观察一下三相电机的三相输出电压（反电动势产生的电压）</p><p>实际上也就是3根相位不同的正弦波：</p><p><img src="3.png"></p><p><em>三相发电机的发电原理就是这样，输出的就是三相幅值为220V的交流电，（线电压为380V，即根号三</em>220V）</p><p>发电机反过来就是电动机，如果对电机输入上面那种三相正弦电压（更换合适的幅值），那么就可以驱动无刷电机平稳高效的运转了</p><p>这就是FOC驱动电机的基本手段，即通过计算所需电压矢量，使用SVPWM技术产生调试型号，驱动三相逆变电路，合成出等效的三相正弦电压驱动电机</p><h2 id="2-1FOC控制原理"><a href="#2-1FOC控制原理" class="headerlink" title="2.1FOC控制原理"></a>2.1FOC控制原理</h2><p>老规矩，在了解之前我们先来看看FOC控制的整个流程图（这是电流环——内环）：</p><p><img src="4.png"></p><p>这个图挺复杂的，这里我来简单的解释一下：</p><p>Iq_Ref是q轴(交轴)电流设定值，Id_Ref是d轴(直轴)电流设定，关于交轴直轴不再介绍，大家自行百度</p><p> Ia, Ib, Ic分别是A相、B相、C相的采样电流，是可以直接通过AD采样得到的，通常直接采样其中两相，利用公式Ia+Ib+Ic=0计算得到第三相，电角度θ可以通过实时读取磁编码器的值计算得到</p><p>在得到三相电流和电角度后，即可以进行电流环的执行了：三相电流Ia, Ib, Ic经过Clark变换得到Iα, Iβ；然后经过Park变换得到Iq, Id；然后分别与他们的设定值Iq_Ref, Id_Ref计算误差值；然后分别将q轴电流误差值代入q轴电流PI环计算得到Vq，将d轴电流误差值代入d轴电流PI环计算得到Vd；然后对Vq, Vd进行反Park变换得到Vα, Vβ；然后经过SVPWM算法得到Va, Vb, Vc，最后输入到电机三相上。这样就完成了一次电流环的控制</p><p>当对PMSM进行速度控制的时候，需要在电流环外面加一个速度环，控制框图如下：</p><p><img src="6.png"></p><p>Speed_Ref是速度设定值，ω是电机的转速反馈，可以通过电机编码器计算得到， 将计算得到的电机速度ω与速度设定值Speed_Ref进行误差值计算，代入速度PI环，计算的结果作为电流环的输入</p><p>比较图二和图一的电流环部分可以发现，图二中d轴电流被设定为零(Id_Ref=0)，因为d轴电流对于驱动电机的转动不会产生输出力，所以通常情况下都会将d轴电流设定为零(但不是总是设定为0的)；当Id_Ref=0时，Iq_Ref就等于了速度环的输出；再结合上面的电流环，就实现了速度电流的双闭环控制</p><p>由于速度环在电子转动速度较慢时控制不精确的原因，我们将速度环改成位置环：</p><p><img src="7.png"></p><p>由于去掉了速度环，这里的位置环我们使用完整的<strong>PID控制</strong>，即把微分项加上（因为位置的微分就是速度，这样可以减小位置控制的震荡加快收敛；积分项的作用是为了消除静态误差）</p><p>这个图中除了PID以外，还有些东西没有解释：</p><ul><li>SVPWM</li><li>Clark</li><li>Park/RevPark</li></ul><h2 id="2-2Clark与Park变换"><a href="#2-2Clark与Park变换" class="headerlink" title="2.2Clark与Park变换"></a>2.2Clark与Park变换</h2><p>上文提到，如果要使得电机能够平稳丝滑的转动，那么就需要生成相位差为120°的三个正弦波，由于我们的MOS管只有开/关两种状态，所以如何生成变化的正弦波呢？</p><p>在PWM技术中有一种SPWM波，生成其的技术很简单，只需要让PWM的脉宽随着sin函数变化就可以，生成的波经过低通滤波器之后，就可以的到一条正弦波，如果用SPWM生成三条存在一定相位差的正弦波那么是不是就可以合成SVPWM呢？</p><p>很显然这种办法十分的麻烦，而且我们并不好在某一个时刻地里的控制电机的三相电压（据大佬说SPWM比SVPWM的利用率要低15%），所以我们要选用一种简单的方法</p><h3 id="2-2-1Clark变换"><a href="#2-2-1Clark变换" class="headerlink" title="2.2.1Clark变换"></a>2.2.1Clark变换</h3><p>根据基尔霍夫电流定律，我们可以得到：</p><p>I_a+I_b+I_c=0</p><p>由此可知，只要我们知道其中两个，就可以根据公式计算出另一个</p><p><img src="8.png"></p><p>上图可以看见，在这个二维坐标系中，三相电流的分布</p><p>我们可以通过一定的变换，将它映射为Iα, Iβ</p><p>这其实就是个简单的投影计算，矩阵式如下：</p><p><img src="9.png"></p><p>变换结果如下：</p><p><img src="10.png"></p><p>动图：</p><p><img src="6.gif"></p><p>现在我们只需要控制Iα, Iβ就可以控制电机旋转了</p><p>但是，要注意的是，当我们实际控制电机的时候，要将Iα, Iβ反变换回去</p><p>这样一来依然很麻烦，因为我们控制的依然还是正弦波，不过是少了一个相的控制</p><p>这里我们可以引入Park变换</p><h3 id="2-2-2Park变换"><a href="#2-2-2Park变换" class="headerlink" title="2.2.2Park变换"></a>2.2.2Park变换</h3><p><img src="11.png"></p><p>上图是变换公式，θ是转子当前角度</p><p>矩阵式：</p><p><img src="12.png"></p><p>由于θ是转子当前角度，所以Park变换之后的坐标系是跟着转子旋转的</p><p>变换之后的变量已经成了一个线性的，甚至是一数，如果我们向编码器输入一个实时角度，经过这一步变换，我们可以看到，一个匀速旋转的向量在这个坐标系下变成了一个定值</p><p>动图：</p><p><img src="7.gif"></p><h3 id="2-2-3SVPWM"><a href="#2-2-3SVPWM" class="headerlink" title="2.2.3SVPWM"></a>2.2.3SVPWM</h3><p>SVPWM的全称是空间矢量脉宽调制(Space Vector Pulse Width Modulation)，是由三相功率逆变器的六个功率开关元件组成的特定开关模式产生的脉宽调制波，能够使输出电流波形尽可能接近于理想的正弦波形。理论基础是平均值等效原理，即在一个开关周期内通过对基本电压矢量加 以组合，使其平均值与给定电压矢量相等</p><p>将母线电压写为三相电压为：</p><p><img src="13.png"></p><p>下面讨论一下空间电压矢量：</p><p><img src="0.png"></p><p>由于三相逆变电路在某一个时刻只会有一个臂导通，所以我们可以得到八种开关方式，其中有六种是非零向量</p><p><img src="14.png"></p><p>由此，我们可以的到一个电压矢量的坐标图：</p><p><img src="15.png"></p><p>和电压矢量表：</p><p><img src="16.png"></p><p>由于这六个扇区只能产生六个方向的力矩，如果需要产生任意方向的力矩，我们需要引入SVPWM</p><p>按照伏秒平衡原则来合成每个扇区内的任意电压矢量，即：</p><p><img src="17.png"></p><p>离散形式：</p><p><img src="18.png"></p><p>式子中的Uref是我们期望得到的电压矢量，T是一个PWM周期。</p><p>Ux,Uy是用于合成Uref的两个空间电压矢量，是六个基向量之中的两个，是哪两个与所在扇区有关</p><p>上面公式的含义就是：<strong>我们可以周期性地在不同空间电压矢量之间切换，只要合理地配置不同基向量在一个周期中的占空比，就可以合成出等效的任意空间电压矢量了</strong></p><p>这与PWM的思想非常相像，也就是它名字的来源SVPWM（空间电压矢量脉宽调制）</p><p>举个例子，当Uref在U4与U6之间：</p><p><img src="19.png"></p><p>现在一个周期内所有状态的持续时间我们都得到了，还差一个顺序，也就是<strong>各个状态切换的顺序</strong>。</p><p>虽然说任意顺序都可以，但是我们需要考虑MOS的损耗问题，所以尽可能的减少MOS管的开关次数，如下图：</p><p><img src="20.jpg"></p><p>上图中可以看出来，在每个状态切换的时候，都只有一个相发生了转变：<strong>000</strong>-&gt;<strong>100</strong>-&gt;<strong>110</strong>-&gt;<strong>111</strong>-&gt;<strong>110</strong>-&gt;<strong>100</strong>-&gt;<strong>000，</strong>这也是所谓的七段式SVPWM调制法</p><p>同时我们通过在合理的位置插入两个零矢量，并且对零矢量在时间上进行了平均分配，以使产生的PWM对称，从而有效地降低了PWM的谐波分量</p><p>同理，我们也可以列出在其他扇区时的切换顺序：</p><p><img src="21.jpg"></p><p>至此，SVPWM的工作完成了，我们得到了每一时刻所需要的空间电压矢量以及它们持续的时间，在处理器中赋值给对应通道的捕获比较寄存器产生相应的三个PWM波形，控制MOS管的开关，进而产生我们期望的电压、电流、力矩</p><p>以上就是对原理的阐述，下面有一些我自己的见解和补充</p><h1 id="3-SVPWM算法原理部分补充"><a href="#3-SVPWM算法原理部分补充" class="headerlink" title="3.SVPWM算法原理部分补充"></a>3.SVPWM算法原理部分补充</h1><p> SVPWM是近年发展的一种比较新颖的控制方法，是由三相功率逆变器的六个功率开关元件组成的特定开关模式产生的脉宽调制波，能够使输出电流波形尽可能接近于理想的正弦波形。空间电压矢量PWM与传统的正弦PWM不同，它是从三相输出电压的整体效果出发，着眼于如何<strong>使电机获得理想圆形磁链轨迹</strong>。SVPWM技术与SPWM相比较，绕组电流波形的谐波成分小，使得电机转矩脉动降低，旋转磁场更逼近圆形，而且使直流母线电压的利用率有了很大提高，且更易于实现数字化（这就是为何SPWM能量损耗高于SVPWM的原因了）</p><p>通俗化理解：把PMSM想象成两块同心的磁铁，两块磁铁是相吸的，因此当用手拨动外面的磁铁绕组圆心转动时，里面的磁铁也会跟着转动，这其实就是PMSM的本质了。PMSM的转子是永磁铁，定子是绕组，我们用电路控制定子绕组产生旋转的磁场，里面的转子磁铁就会跟着转动，这个磁场的大小最好恒定，不然一会儿大一会儿小，转子受到的牵引力也就一会儿大一会儿小，影响运动性能。好了，现在我们知道电机的本质是什么了。接下来，我们需要一个算法来控制定子绕组的输出，使其产生一个恒定的旋转磁场，这个算法就是SVPWM</p><p>要得到一个恒定大小的旋转磁场，可以先来得到一个恒定大小的旋转电压矢量。如下图：</p><p><img src="5.gif"></p><hr><p>在SPWM中，占空比越大，电压越大；占空比越小，电压越小。让占空比呈正弦变化，电压值自然也就呈正弦变化了</p><hr><p>我们如何判断自己在那个扇区呢？</p><p>由于相电压同一时刻不会同为零同为一，所以我们可以用一个式子来判断，令N=4C+2B+A</p><p>A为Ua</p><p>B为Ub</p><p>C为Uc</p><p>通过下表可以的到扇区对应关系</p><p><img src="26.png"></p><hr><p>下面是六个扇区对应的完整版</p><p><img src="23.png"></p><p><img src="24.png"></p><hr><p>所有扇区矢量作用时间</p><p><img src="25.png"></p><hr><p>经过上面的补充，FOC与SVPWM的对接就变成了，先根据N=4<em>C+2</em>B+A判断合成矢量所在扇区，然后查表2-4得出两非零矢量的作用时间，最后得出三相开关管PWM波的占空比，查表让算法更高效</p><hr><p><img src="27.png"></p><p>由此公式可知：</p><p>当两个零电压矢量作用时间为0时，一个PWM周期内非零电压矢量的作用时间最长，此时的合成空间电压矢量幅值最大，由下图可知其幅值最大不会超过图中所示的正六边形边界。而当合成矢量落在该边界之外时，将发生过调制，逆变器输出电压波形将发生失真。在SVPWM调制模式下，逆变器能够输出的最大不失真圆形旋转电压矢量为图2-12所示虚线正六边形的内切圆，其幅值为： (√3/ 2)x(2<em>U**dc</em>/ 3) =√3<em>U**dc</em>/3 。即逆变器输出的不失真最大正弦相电压幅值为√3<em>U**dc</em> /3 ，而若采用三相SPWM调制，逆变器能输出的不失真 最大正弦相电压幅值为<em>Udc</em>/2。显然SVPWM 调制模式下对直流侧电压利用率更高，它们的直流利用率之比为(√3<em>U**dc</em>/ 3) /(<em>U**dc</em>/ 2) =1.1547 ，即SVPWM算法比SPWM算法的直流电压利用率提高了15.47%（这就是上述文章中15%的来源）</p><p><img src="28.png"></p><p>如图当合成电压矢量端点落在正六边形与外接圆之间时，已发生过调制，输出电压将发生失真，必须采取过调制处理，这里采用一种比例缩小算法。定义每个扇区中先发生的矢量用为<em>Tx</em>，后发生的矢量为 <em>Ty</em>。当 <em>Tx+Ty</em>≤<em>TS</em>时，矢量端点在正六边形之内，不发生过调制；当<em>Tx+Ty</em>&gt;<em>TS</em>时，矢量端点超出正六边形，发生过调制。输出的波形会出现严重的失真，需采取以下措施：</p><p>设将电压矢量端点轨迹端点拉回至正六边形内切圆内时两非零矢量作用时间分别为 <em>Tx</em>‘，<em>Ty</em>‘，则有比例关系：</p><p><img src="29.png"></p><p>使用上面的简单比例关系，把两个非零矢量作用时间矫正好</p><p><img src="30.png"></p><p>taon、tbon、tcon的波形呈马鞍形，如下：</p><p><img src="31.png"></p><p>参考：</p><p><a href="https://zhuanlan.zhihu.com/p/147659820">https://zhuanlan.zhihu.com/p/147659820</a></p><p><a href="https://blog.csdn.net/qlexcel/article/details/74787619#comments">https://blog.csdn.net/qlexcel/article/details/74787619#comments</a></p><p>更详细的公式推导请见</p><p><a href="https://zhuanlan.zhihu.com/p/47766452">https://zhuanlan.zhihu.com/p/47766452</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 电机控制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电机控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Opencv学习笔记</title>
      <link href="/2020/04/03/cv-0/"/>
      <url>/2020/04/03/cv-0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>计算机视觉在生活中已经成为了一个不可或缺的部分，下面就来总结一下我过去所学的那些关于Opencv的知识</p><h1 id="1-Opencv环境搭建"><a href="#1-Opencv环境搭建" class="headerlink" title="1.Opencv环境搭建"></a>1.Opencv环境搭建</h1><p>准备工作如下</p><ul><li><p>安装Python</p></li><li><p>安装pip插件</p></li><li><p>安装相关依赖包：numpy等</p></li><li><pre><code>pip install opencv-pythonpythonimport cv2cv2.__version__</code></pre></li></ul><h1 id="2-Opencv教程"><a href="#2-Opencv教程" class="headerlink" title="2.Opencv教程"></a>2.Opencv教程</h1><h2 id="2-1打开摄像头"><a href="#2-1打开摄像头" class="headerlink" title="2.1打开摄像头"></a>2.1打开摄像头</h2><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> cv2capture <span class="token operator">=</span> cv2<span class="token punctuation">.</span>VideoCapture<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#调用电脑默认摄像头</span>capture<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#打开电脑默认摄像头</span><span class="token keyword">while</span><span class="token punctuation">(</span>capture<span class="token punctuation">.</span>isOpened<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    ret<span class="token punctuation">,</span>frame <span class="token operator">=</span> capture<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#ret调用成功或失败，frame获取到的画面是一个numpy数组</span>    cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'frame'</span><span class="token punctuation">,</span>frame<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#展示摄像头所捕获的画面，第一个参数是窗口名</span>    key_<span class="token operator">=</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#每60ms获取按键键值</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>key_<span class="token punctuation">)</span>    <span class="token keyword">if</span> key_ <span class="token operator">==</span> <span class="token number">27</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#这里27是Esc对应的键值</span>        <span class="token keyword">break</span>capture<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#关闭摄像头</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#关闭窗口</span></code></pre><p>上面是一个简单的调用摄像头的案例，其中键盘对应键值与ASCII有关</p><h2 id="2-2调用边缘检测"><a href="#2-2调用边缘检测" class="headerlink" title="2.2调用边缘检测"></a>2.2调用边缘检测</h2><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#边缘检测</span><span class="token keyword">import</span> cv2<span class="token comment" spellcheck="true"># 回调函数，x表示滑块的位置，本例暂不使用</span><span class="token keyword">def</span> <span class="token function">nothing</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">pass</span>capture <span class="token operator">=</span> cv2<span class="token punctuation">.</span>VideoCapture<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>namedWindow<span class="token punctuation">(</span><span class="token string">'frame'</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>createTrackbar<span class="token punctuation">(</span><span class="token string">'MAX'</span><span class="token punctuation">,</span> <span class="token string">'frame'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">,</span> nothing<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>createTrackbar<span class="token punctuation">(</span><span class="token string">'MIN'</span><span class="token punctuation">,</span> <span class="token string">'frame'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">,</span> nothing<span class="token punctuation">)</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    MAX <span class="token operator">=</span> cv2<span class="token punctuation">.</span>getTrackbarPos<span class="token punctuation">(</span><span class="token string">'MAX'</span><span class="token punctuation">,</span> <span class="token string">'frame'</span><span class="token punctuation">)</span>    MIN <span class="token operator">=</span> cv2<span class="token punctuation">.</span>getTrackbarPos<span class="token punctuation">(</span><span class="token string">'MIN'</span><span class="token punctuation">,</span> <span class="token string">'frame'</span><span class="token punctuation">)</span>    ret<span class="token punctuation">,</span> frame <span class="token operator">=</span> capture<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>    edges <span class="token operator">=</span> cv2<span class="token punctuation">.</span>Canny<span class="token punctuation">(</span>frame<span class="token punctuation">,</span> MIN<span class="token punctuation">,</span> MAX<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># canny边缘检测</span>    teer <span class="token operator">=</span> np<span class="token punctuation">.</span>dstack<span class="token punctuation">(</span><span class="token punctuation">(</span>edges<span class="token punctuation">,</span>edges<span class="token punctuation">,</span>edges<span class="token punctuation">)</span><span class="token punctuation">)</span>    cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'frame'</span><span class="token punctuation">,</span> edges<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 展示摄像头所捕获的画面</span>    cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'teer'</span><span class="token punctuation">,</span> teer<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 展示摄像头所捕获的画面</span>    <span class="token keyword">if</span> cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">27</span><span class="token punctuation">:</span>        <span class="token keyword">break</span>capture<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#关闭摄像头</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#关闭窗口</span></code></pre><p>上面是一个自带滑块可调区间的边缘检测程序</p><h2 id="2-3笑脸检测"><a href="#2-3笑脸检测" class="headerlink" title="2.3笑脸检测"></a>2.3笑脸检测</h2><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token comment" spellcheck="true"># 载入人脸检测器、眼睛检测器、微笑检测器三个级联检测器</span>face_cascade <span class="token operator">=</span> cv2<span class="token punctuation">.</span>CascadeClassifier<span class="token punctuation">(</span>cv2<span class="token punctuation">.</span>data<span class="token punctuation">.</span>haarcascades<span class="token operator">+</span><span class="token string">'haarcascade_frontalface_default.xml'</span><span class="token punctuation">)</span>eye_cascade <span class="token operator">=</span> cv2<span class="token punctuation">.</span>CascadeClassifier<span class="token punctuation">(</span>cv2<span class="token punctuation">.</span>data<span class="token punctuation">.</span>haarcascades<span class="token operator">+</span><span class="token string">'haarcascade_eye.xml'</span><span class="token punctuation">)</span>smile_cascade <span class="token operator">=</span> cv2<span class="token punctuation">.</span>CascadeClassifier<span class="token punctuation">(</span>cv2<span class="token punctuation">.</span>data<span class="token punctuation">.</span>haarcascades<span class="token operator">+</span><span class="token string">'haarcascade_smile.xml'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 调用摄像头</span>cap <span class="token operator">=</span> cv2<span class="token punctuation">.</span>VideoCapture<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 获取摄像头拍摄到的画面</span>    ret<span class="token punctuation">,</span> frame <span class="token operator">=</span> cap<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>    faces <span class="token operator">=</span> face_cascade<span class="token punctuation">.</span>detectMultiScale<span class="token punctuation">(</span>frame<span class="token punctuation">,</span> <span class="token number">1.3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>    img <span class="token operator">=</span> frame    <span class="token keyword">for</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>w<span class="token punctuation">,</span>h<span class="token punctuation">)</span> <span class="token keyword">in</span> faces<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 画出人脸框，蓝色，画笔宽度微</span>        img <span class="token operator">=</span> cv2<span class="token punctuation">.</span>rectangle<span class="token punctuation">(</span>img<span class="token punctuation">,</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>x<span class="token operator">+</span>w<span class="token punctuation">,</span>y<span class="token operator">+</span>h<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 框选出人脸区域，在人脸区域而不是全图中进行人眼检测，节省计算资源</span>        face_area <span class="token operator">=</span> img<span class="token punctuation">[</span>y<span class="token punctuation">:</span>y<span class="token operator">+</span>h<span class="token punctuation">,</span> x<span class="token punctuation">:</span>x<span class="token operator">+</span>w<span class="token punctuation">]</span>        <span class="token comment" spellcheck="true">## 人眼检测</span>        <span class="token comment" spellcheck="true"># 用人眼级联分类器引擎在人脸区域进行人眼识别，返回的eyes为眼睛坐标列表</span>        eyes <span class="token operator">=</span> eye_cascade<span class="token punctuation">.</span>detectMultiScale<span class="token punctuation">(</span>face_area<span class="token punctuation">,</span><span class="token number">1.3</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>ex<span class="token punctuation">,</span>ey<span class="token punctuation">,</span>ew<span class="token punctuation">,</span>eh<span class="token punctuation">)</span> <span class="token keyword">in</span> eyes<span class="token punctuation">:</span>            <span class="token comment" spellcheck="true">#画出人眼框，绿色，画笔宽度为1</span>            cv2<span class="token punctuation">.</span>rectangle<span class="token punctuation">(</span>face_area<span class="token punctuation">,</span><span class="token punctuation">(</span>ex<span class="token punctuation">,</span>ey<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>ex<span class="token operator">+</span>ew<span class="token punctuation">,</span>ey<span class="token operator">+</span>eh<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">## 微笑检测</span>        <span class="token comment" spellcheck="true"># 用微笑级联分类器引擎在人脸区域进行人眼识别，返回的eyes为眼睛坐标列表</span>        smiles <span class="token operator">=</span> smile_cascade<span class="token punctuation">.</span>detectMultiScale<span class="token punctuation">(</span>face_area<span class="token punctuation">,</span>scaleFactor<span class="token operator">=</span> <span class="token number">1.16</span><span class="token punctuation">,</span>minNeighbors<span class="token operator">=</span><span class="token number">65</span><span class="token punctuation">,</span>minSize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">,</span>flags<span class="token operator">=</span>cv2<span class="token punctuation">.</span>CASCADE_SCALE_IMAGE<span class="token punctuation">)</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>ex<span class="token punctuation">,</span>ey<span class="token punctuation">,</span>ew<span class="token punctuation">,</span>eh<span class="token punctuation">)</span> <span class="token keyword">in</span> smiles<span class="token punctuation">:</span>            <span class="token comment" spellcheck="true">#画出微笑框，红色（BGR色彩体系），画笔宽度为1</span>            cv2<span class="token punctuation">.</span>rectangle<span class="token punctuation">(</span>face_area<span class="token punctuation">,</span><span class="token punctuation">(</span>ex<span class="token punctuation">,</span>ey<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>ex<span class="token operator">+</span>ew<span class="token punctuation">,</span>ey<span class="token operator">+</span>eh<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>            cv2<span class="token punctuation">.</span>putText<span class="token punctuation">(</span>img<span class="token punctuation">,</span><span class="token string">'Smile'</span><span class="token punctuation">,</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token number">-7</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1.2</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> cv2<span class="token punctuation">.</span>LINE_AA<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 实时展示效果画面</span>    cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'frame2'</span><span class="token punctuation">,</span>img<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 每5毫秒监听一次键盘动作</span>    <span class="token keyword">if</span> cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xFF</span> <span class="token operator">==</span> ord<span class="token punctuation">(</span><span class="token string">'q'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">break</span><span class="token comment" spellcheck="true"># 最后，关闭所有窗口</span>cap<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>上面是一个微笑检测的程序，检测效果一般</p><h2 id="2-4图片处理"><a href="#2-4图片处理" class="headerlink" title="2.4图片处理"></a>2.4图片处理</h2><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token comment" spellcheck="true"># 读入本地图像文件</span>img <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'logo.png'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 在窗口中显示图像</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"Display window"</span><span class="token punctuation">,</span> img<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 获取键盘按键动作，如果按下s键，就将图像保存至本地</span>k <span class="token operator">=</span> cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 0表示永久等待键盘按键，15表示等待15毫秒</span><span class="token keyword">if</span> k <span class="token operator">==</span> ord<span class="token punctuation">(</span><span class="token string">"s"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span><span class="token string">"saved_img.png"</span><span class="token punctuation">,</span> img<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>简单的导入导出图片</p><h2 id="2-5捕获摄像头画面"><a href="#2-5捕获摄像头画面" class="headerlink" title="2.5捕获摄像头画面"></a>2.5捕获摄像头画面</h2><p>下面调用图像和摄像头，这是较为完整严谨的写法</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token comment" spellcheck="true"># 读入本地图像文件</span>img <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'no_exist.png'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 校验图像是否导入成功，如果导入失败，就输出提示</span><span class="token keyword">if</span> img <span class="token keyword">is</span> None<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"未能读入图像，请检查图像文件路径是否正确"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 在窗口中显示图像</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"Display window"</span><span class="token punctuation">,</span> img<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 获取键盘按键动作，如果按下s键，就将图像保存至本地</span>k <span class="token operator">=</span> cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 0表示永久等待键盘按键，15表示等待15毫秒</span><span class="token keyword">if</span> k <span class="token operator">==</span> ord<span class="token punctuation">(</span><span class="token string">"s"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span><span class="token string">"saved_img.png"</span><span class="token punctuation">,</span> img<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>在实际场景中，如果图片路径没有写对，那么会报出错误，所以我们要对其进行一个人性化的处理</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token comment" spellcheck="true"># 捕获摄像头，传入摄像头索引号，默认摄像头索引为0</span>cap <span class="token operator">=</span> cv2<span class="token punctuation">.</span>VideoCapture<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 校验摄像头是否捕获成功，如果未成功则输出提示</span><span class="token keyword">if</span> <span class="token operator">not</span> cap<span class="token punctuation">.</span>isOpened<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"无法打开摄像头"</span><span class="token punctuation">)</span>    exit<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 无限循环，直到触发break跳出</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 获取摄像头捕获的画面帧，返回ret和frame</span>    <span class="token comment" spellcheck="true"># ret的True/False反映是否捕获成功，frame是画面</span>    ret<span class="token punctuation">,</span> frame <span class="token operator">=</span> cap<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 校验画面帧是否正确捕获，如果未成功则输出提示，跳出循环</span>    <span class="token keyword">if</span> <span class="token operator">not</span> ret<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"无法获取画面帧"</span><span class="token punctuation">)</span>        <span class="token keyword">break</span>    <span class="token comment" spellcheck="true"># 对画面帧进行处理</span>    <span class="token comment" spellcheck="true"># 这里是将画面转为灰度图</span>    gray <span class="token operator">=</span> cv2<span class="token punctuation">.</span>cvtColor<span class="token punctuation">(</span>frame<span class="token punctuation">,</span> cv2<span class="token punctuation">.</span>COLOR_BGR2GRAY<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 在窗口中显示处理之后的画面</span>    cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'frame_window'</span><span class="token punctuation">,</span> gray<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 获取键盘按键动作，如果按下q键，就跳出循环</span>    <span class="token keyword">if</span> cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> ord<span class="token punctuation">(</span><span class="token string">'q'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">break</span><span class="token comment" spellcheck="true"># 关闭摄像头</span>cap<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 关闭所有窗口</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>这里将视频内容进行了一个灰度化处理</p><h2 id="2-6打开视频"><a href="#2-6打开视频" class="headerlink" title="2.6打开视频"></a>2.6打开视频</h2><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token comment" spellcheck="true">#打开一个视频,并且逐帧播放</span>capture <span class="token operator">=</span> cv2<span class="token punctuation">.</span>VideoCapture<span class="token punctuation">(</span><span class="token string">'000.mp4'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#判断摄像头或视频是否读取，成功返回Ture</span><span class="token keyword">while</span><span class="token punctuation">(</span>capture<span class="token punctuation">.</span>isOpened<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    temp <span class="token operator">=</span> capture<span class="token punctuation">.</span>get<span class="token punctuation">(</span>cv2<span class="token punctuation">.</span>CAP_PROP_FRAME_COUNT<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#获取视频总帧数</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">:</span>        ret<span class="token punctuation">,</span> frame <span class="token operator">=</span> capture<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token operator">not</span> ret<span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"无法获取画面"</span><span class="token punctuation">)</span>            <span class="token keyword">break</span>        gray <span class="token operator">=</span> cv2<span class="token punctuation">.</span>cvtColor<span class="token punctuation">(</span>frame<span class="token punctuation">,</span> cv2<span class="token punctuation">.</span>COLOR_BGR2GRAY<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#转化为灰度图的形式</span>        cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'frame'</span><span class="token punctuation">,</span> gray<span class="token punctuation">)</span>        temp <span class="token operator">=</span> temp <span class="token operator">-</span> <span class="token number">1</span> <span class="token comment" spellcheck="true">#播放一次帧数减一</span>        <span class="token keyword">if</span> cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span> <span class="token operator">==</span> ord<span class="token punctuation">(</span><span class="token string">'q'</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#30表示暂停时间，越小越快</span>            <span class="token keyword">break</span>    <span class="token keyword">break</span></code></pre><h2 id="2-7录制视频保存"><a href="#2-7录制视频保存" class="headerlink" title="2.7录制视频保存"></a>2.7录制视频保存</h2><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> cv2capture <span class="token operator">=</span> cv2<span class="token punctuation">.</span>VideoCapture<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>outfile <span class="token operator">=</span> cv2<span class="token punctuation">.</span>VideoWriter<span class="token punctuation">(</span><span class="token string">'output.avi'</span><span class="token punctuation">,</span> cv2<span class="token punctuation">.</span>VideoWriter_fourcc<span class="token punctuation">(</span><span class="token operator">*</span><span class="token string">'MJPG'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">25.0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">640</span><span class="token punctuation">,</span> <span class="token number">480</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#第一个参数表示视屏录制之后的位置，第二个参数是指编码格式如mjpg格式   cv2.VideoWriter_fourcc(*'MJPG')   第三个是帧率，第四个帧大小，第五个是否彩色</span>capture<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">while</span><span class="token punctuation">(</span>capture<span class="token punctuation">.</span>isOpened<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    ret<span class="token punctuation">,</span>frame <span class="token operator">=</span> capture<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#ret调用成功或失败，frame获取到的画面是一个numpy数组</span>    outfile<span class="token punctuation">.</span>write<span class="token punctuation">(</span>frame<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#写入文件</span>    cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'frame'</span><span class="token punctuation">,</span>frame<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#展示摄像头所捕获的画面，第一个参数是窗口名</span>    key_<span class="token operator">=</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#每60ms获取按键键值</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>key_<span class="token punctuation">)</span>    <span class="token keyword">if</span> key_ <span class="token operator">==</span> <span class="token number">27</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#这里27是Esc对应的键值</span>        <span class="token keyword">break</span>capture<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#关闭摄像头</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#关闭窗口</span></code></pre><h1 id="3-1Yolo-v1技术概要"><a href="#3-1Yolo-v1技术概要" class="headerlink" title="3.1Yolo v1技术概要"></a>3.1Yolo v1技术概要</h1><p>目前YoLo已经更新到v5版本，而想要读懂YoLo我们需要从最基础的v1来看</p><p>YoLo是把目标检测作为回归问题去解决的</p><p>传统的模型需要先提取候选框，对每一个候选框逐一的甄别进行分类和回归</p><p>以RCNN为例先提取出两千个候选框在逐一的对每个候选框进行甄别，非常的耗时费力</p><p>而YoLo不一样，它是单阶段的，只需要看一次，直接将图片送入网络就可以得出结果</p><p>通过阅读YoLo的论文我们可以知道，YoLo是将一张图片分成一个s*s的网格，如论文上那个狗和自行车的例子，它分成了七乘七的网格，每一个网格又能预测出B个bounding box，如果在训练过程中一个标签落到了哪一个网格，那就由那个网格产生的bounding box去预测这个物体，而究竟是用这B个bounding box中的哪一个去预测呢？就是由这B个bounding box中IOU最大重合度最大的框去负责预测，网络就会产生这么一个结构7×7×（5×B+C），就是每个网格都会产生两个bounding box，每个bounding box都有五个参数分别是（x,y,h,w,c）框线粗细表示C的大小，每一个格子又会产生类别的概率，对得到的值进行后处理，比如非极大值抑制，就能的到我们最终的目标检测结果了，这就是YoLo的整个过程</p><p>论文中展示的过程是正向推断过程，而哪一个框预负责预测某个物体是训练的过程，训练过程是监督学习，有人工标注的矩形框的中点落在哪个格子里，就由哪个格子产生的bounding box去预测这个物体</p><p>YoLo v1的网络结构是一个全卷积网络，全部是由卷积神经网络构成的，中间交替使用了1×1和3×3卷积，总共有24层卷积提取图像特征，再由两个全连接层回归得到一个7×7×30的tensor，7×7意味图像分割成7×7的网格，30表示每一个各自产生两个bounding box，而每一个bounding box有五个元素，每一个格子预测二十个类别就是10+20=30</p><p>由于YoLo是关注图片的全部信息的，而Fast R-CNN只能看到RoI区分背景能力差，经过对比我们可以知道，区分背景和物体的能力强，但精确定位较差，而且YoLo的泛化性特别强，哪怕是在自然界中训练好的模型也能用于艺术品</p><h1 id="3-2YoLo-v5示例"><a href="#3-2YoLo-v5示例" class="headerlink" title="3.2YoLo v5示例"></a>3.2YoLo v5示例</h1><p>进入<a href="github.com/ultralytics/yolov5">YoLo v5</a>的github页面</p><p>将目标下载</p><p>找到下载目录并进入</p><p>使用Win+R打开命令行，cd到对应目录</p><p>运行如下命令</p><pre><code>python detect.py --source 0 --weights weights/yolov5s.pt</code></pre><p>如若报错，根据内容安装对应支持包即可</p><p>如：</p><pre><code>pip install tqdm</code></pre><p>torch包下载不下来可以访问<a href="https://pytorch.org/get-started/locally/#start-locally">官网</a>选择对应的版本系统下载即可</p><p><img src="0.png"></p><p>想要关闭可以按q键退出，注意要将输入法调成英文，检测速度速度由个人电脑配置决定</p><p>这里我们来看一下它的源码的这个地方：</p><p><img src="1.png"></p><p>介绍一下部分参数的作用：</p><p>–weights    权重，可以使用默认权重文件和自己训练好的权重文件</p><p>–source    视频来源</p><p>–output    预测结果存放地址</p><p>–img-size    图片大小</p><p>–conf-thres    目标执行度阈值</p><p>–iou-thres    区域交并比：重叠区域和并集区域的比值</p><p>–device    使用CPU or GPU</p><p>–classes    类别</p><p>下面我们来尝试使用一个视频来做一个演示</p><p>命令如下：</p><pre><code>python detect.py --source 相对路径/文件名.mp4 --weights weights/yolov5s.pt --output 相对路径/文件名.mp4</code></pre><p>这里我们可以看到我们视频已处理帧数和总帧数，并且还有处理每一帧所耗费的时间</p><p><img src="2.png"></p><p>这里我是用CPU去跑的，所以速度很慢，如果想中途中断可以使用Ctrl+C中断，中断之后已处理的图像也会被保存下来，不过会有一些问题</p><h1 id="3-3使用YoLo-v5训练自己的训练集"><a href="#3-3使用YoLo-v5训练自己的训练集" class="headerlink" title="3.3使用YoLo v5训练自己的训练集"></a>3.3使用YoLo v5训练自己的训练集</h1><p>建立自己的数据集，这里举一个简单的栗子</p><p>标注软件建议使用Labelimg</p><p>操作说明，a上一张图，d下一张图，w化框格，可以用鼠标来调整，选择Yolo格式输出</p><p>标签文件：</p><p>第一列类别</p><p>第二列左上角坐标</p><p>第三列框住部分占总图片的比例</p><p>第四列宽度</p><p>第五列高度</p><p>以上都是归一化的值</p><p>每一个TXT都是一个图片上所有框的信息</p><hr><p>图片分为三个文件夹</p><p>训练集：用于模型拟合的数据样本</p><p>验证集：是模型训练过程中单独留出的样本集，它可以用于调整模型的超参数和用于对模型的能力进行初步评估</p><p>测试集：用来评估模最终模型的泛化能力。但不能作为调参、选择特征等算法相关的选择的依据</p><p>比喻一下就是</p><p><strong>训练集</strong>————学生的课本，学生 根据课本里的内容来掌握知识。</p><p><strong>验证集</strong>————作业，通过作业可以知道 不同学生学习情况、进步的速度快慢。</p><p><strong>测试集</strong>———–考试，考的题是平常都没有见过，考察学生举一反三的能力。</p><p>训练使用train.py，同时指定部分参数，data.yaml文件：里面有训练集和验证集图像的位置，类别数量和类别名；模型.yaml文件：需要根据不同训练x、s、m、l文件分别做修改，修改nc类别数，anchors可以使用聚类的方法去修改，当然这里并不建议自己修改</p><p>yaml文件可以使用Notepad++就可以打开和修改，当然也可以使用自带文本编辑器，不过这里不建议使用自带文本编辑器</p><p>总之，嫌麻烦的可以使用别人的训练集</p><p>官网上有相关教程，这里就不做更多介绍了</p><h1 id="4-1关键点检测"><a href="#4-1关键点检测" class="headerlink" title="4.1关键点检测"></a>4.1关键点检测</h1><p>关键点检测多用于检测摔倒、体育动作指导、肢体语言理解、步态身份识别、动作捕捉、动作控制、3D试衣等等场景</p><p>下面只聊一聊简单的关键点检测算法</p><p>人体关键点检测是个回归问题，这个和之前的YoLo有些相似，不过我们人体关键点检测有些限制，比如说一般人是不可能出现两个头啊六条腿之类的</p><p>关键点检测其实和目标追踪有些想像</p><p>这里顺便介绍一下计算机视觉的部分知识</p><p>卷积操作就是将卷积核在元组上滑动并且分别点乘，就会得到卷积后的元组</p><p>多通道的卷积操作就是用多通道的卷积核进行操作</p><p>池化是把大的元组变成小的元组，可以取最大值和平均值分为最大池化和平均池化，池化可以融合汇总特征，防止过拟合，引入平移不变性起到模糊的效果，卷积神经网络就是将卷积层与池化层交替进行最后加上全连接层和输出层构件的既可以二分类也可以多分类</p><p>目标检测方法包括两种</p><p>单阶段方法，速度快准确率低，代表：YoLo、SSD及其变种</p><p>两阶段方法，速度慢需要找出候选框，再在候选框上进行目标检测回归，准确率高，代表：SPP-Net、R-CNN、Fast-R-CNN、Faster-R-CNN及其变种</p><p>单阶段已经介绍过了，两阶段以R-CNN为例，现在目标图片上选出两千个左右的候选框，这两千多个候选框用的是选择性搜索方法，缩放成同样的大小，在分别送入神经网络中进行分类和回归，分类SVMs，回归Bbox reg；这样的速度很慢</p><p><img src="4.png"></p><p>演变过程：</p><p><img src="3.png"></p><p>说回正题</p><p>人体姿态估计技术：提取图像中人体的关节关键点、脸部关键点、手势关键点，构建骨架，识别姿态</p><p>难点：多人、姿态复杂、视频分析、三维重构</p><p>传统的人体姿态估计需要人工构造特征，采用”基于模型“的方法</p><p>深度学习大规模应用后，采用端到端的表示学习，通过数据驱动的方法自动化构建特征</p><p>分为从上倒下：先挑出人，再检测</p><p>从低而上：先把所有关节找出来，在通过一定的准则来区分不同的人</p><p>人体姿态估计的经典解决方案</p><p>卡耐基梅隆大学的<a href="https://arxiv.org/pdf/1812.08008.pdf">OpenPose</a></p><p><a href="https://github.com/CMU-Perceptual-Computing-Lab/openpose">Github源码</a></p><p><a href="https://www.jianshu.com/p/3aa810b35a5d">中文翻译</a></p><hr><p><a href="https://arxiv.org/abs/1511.06645">DeepCut</a></p><p><a href="https://arxiv.org/abs/1612.00137">RMPE</a></p><p><a href="https://arxiv.org/abs/1703.06870">Mask RCNN</a></p><p>暂时先更新到这里，后续再继续补充<del>（由于电脑配置较低实在是有些捉襟见肘）</del></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Opencv </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模糊PID二</title>
      <link href="/2020/03/29/pid-1/"/>
      <url>/2020/03/29/pid-1/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上回我们简略的了解了一下模糊PID与普通PID的一些区别，这会我们来更进一步的了解其在工业领域的应用中会有什么样的表现</p><h1 id="1-控制机械臂"><a href="#1-控制机械臂" class="headerlink" title="1.控制机械臂"></a>1.控制机械臂</h1><p>这里我们来了解一下PID在机械臂控制方面的应用</p><p>在实际应用中，我们的机械臂往往会需要拿起一些重物，而当我们调好空载的PID的时候，我们拿起重物就会发现机械臂并不能很好的打到我们预期的地点，往往会伴随着误差，或者响应缓慢，而当我们调试好负载PID的时候又会出现空载机械臂响应出问题，并且，如果我们每次拿的重物不同我们就要重调PID，那么不是很麻烦么？</p><p>所以这种时候，我们可以试试我们的模糊PID</p><p>我们可以将传递函数的分子调大调小来模拟现实生活中不同机械臂的响应</p><p>我们将分子缩小十倍：</p><p><img src="4.png"></p><p>这里我们可以看见系统变得不稳定了，两种PID的超调量都开始增加，甚至出现了抖动，让我们进一步缩小分子：</p><p><img src="5.png"></p><p>可以看到，传统PID在500s内不能很好的追上期望，而我们的模糊PID虽然稳定下来时并不能很好的锁定在期望值上，但是可以看见模糊PID还是能很快的逼近期望值</p><p>好了，下面我们来增大分母，增大个十倍：</p><p><img src="6.png"></p><p>可以明显的看出来，系统变得稳定了，两种PID的输出都变得十分稳定，这时候，我们在增大分子也没有太大的作用了</p><p>至此上面一个示例再一次证明了模糊PID在应对不同情况下的输入都有良好的响应</p><hr><p>假设我们有一个n轴的机械臂，几轴无所谓，我们只关心其中一个轴的运动就可以了，我们只观察PID在这一个轴中的应用，这里我们打开上次的simulink系统，试着去改一下我们的输入，让它更符合我们实际生活中的控制方式，对于一个机械臂，如果我们只朝着一个方向动就会有使用风险，比如卡死烧坏电机，不能很好的调速等等</p><p>所以我们需要改变控制方式，就以我目前新做的这个系统举例：</p><p><img src="0.png"></p><p>模糊PID和PID的参数并未做修改，只是将期望变成一个随时变化的数：</p><p><img src="1.png"></p><p>上图我们可以看到，这样的控制方式已经很符合机械臂单轴的运作方式了，接下来，让我们将其输入系统中</p><p>得到下面两幅图：</p><p><img src="2.png"></p><p><img src="3.png"></p><p>上面两幅图可以清晰直观的看到，当输入量不断变化的时候，传统PID并不能很好的跟跟随上期望的变化，而且效果十分的差，即使再怎么调试参数，传统PID的响应都不可能迅速的跟上变化的期望，即使我每一个期望值都给了10s，传统PID也不能在10s内达到所期望的数值</p><p>而反观模糊PID，我们可以看到，虽然有些瑕疵，但模糊PID总是能在规定时间内达到期望值，虽然变化曲线有些不美观，达到预期的时间也较长，不过这些都可以修改模糊规则表来达到我们预期的效果，不过这些都是后话了，正是因为大多数控制系统中输入参数并不是固定值，所以我们更需要模糊PID</p><p>这时我们在结合一下之前第一个示例，调大分子看看两种PID的响应状况：</p><p><img src="7.png"></p><p><img src="8.png"></p><p>调小分子看看两种PID的响应状况：</p><p><img src="9.png"></p><p><img src="10.png"></p><p>我们可以看见，无论是如何调整分子，模糊PID却不会有较大的变化，而传统PID却有些许波动</p><p>本次模糊PID仿真到此结束，喜欢的请收藏本站</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> PID </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模糊PID </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模糊PID</title>
      <link href="/2020/03/21/pid/"/>
      <url>/2020/03/21/pid/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在讲解模糊PID之前，我们先来了解一下什么是PID</p><p>PID控制器作为一个比较古老的控制方式，但由于其经典稳定的发挥，在如今也有相当一部分的应用场景，同样也延伸出了相当多的一部分基于PID的改良版控制器</p><p>先从字面意思理解一下PID控制器：</p><ul><li>P就是比例，是输入偏差成算的系数</li><li>I就是积分，就是对输入偏差进行积分运算</li><li>D就是微分，对输入偏差进行微分运算</li></ul><p>这就是PID的简单含义，就是比例、积分和微分控制的简称，当然在实际工业场景中，也有PI控制和PD控制，PID系统是根据被控系统的输入与输出的比较误差，通过对误差的比例、积分、微分计算出控制量进行控制的</p><p>这里放一下传统PID控制器的图：</p><p><img src="0.png"></p><p>其公式可以总结为：</p><p><img src="1.png"></p><p>常用控制方式：</p><p><img src="2.png"></p><p>除此之外，PID控制器在大的方面可以分为位置式和增量式，以上两种控制方式这里就不多介绍了，两种控制方式在一定的条件下其实可以相互转化的</p><p>下面，就让我们来通过一个例子来了解PID的运作方式：</p><p><img src="3.png"></p><p>在上面这个simulink仿真中，我们选取了一个阶跃信号作为期望，反馈为我们的输出信号，对其进行求差，输入我们PID的输入，选取1.5作为P输入，将所求出结果输入传递函数之中，经由传递函数输出到示波器上来查看我们的PID输出波形曲线</p><p>传递函数：描述<a href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F/6814705">线性系统</a>动态特性的基本<a href="https://baike.baidu.com/item/%E6%95%B0%E5%AD%A6%E5%B7%A5%E5%85%B7/903000">数学工具</a>之一，虽然有其部分局限性（不能完全的描述系统的真实状态）但在这里，我们只需要传递函数就够了，通俗的理解就是一个系统总结出来的模型，比如说一个控制电机的系统，我们可以通过对其输入和输出量进行拉氏变换或z变换，然后用输出量变换后的结果比上输入量变换的结果，最终就能得到我们的传递函数</p><p>现在我们来看一下我们的PID波形曲线：</p><p><img src="4.png"></p><p>可以看到的是，我们的PID曲线十分的震荡，要经过很久才能稳定下来，但有个好消息是，我们的PID中值始终落在期望1上，接下来我们调整一下D，让D=9.5</p><p><img src="5.png"></p><p>可以看到我们的PID曲线已经十分平稳，但是有一个问题，我们将Y轴放大一下</p><p><img src="6.png"></p><p>可以看到，最后平稳的曲线并没有真正的追上期望，所以在此我们调整一下I，I=0.001165</p><p><img src="7.png"></p><p>我们来放大看一下：</p><p><img src="8.png"></p><p>误差已经被缩小到零后六位，当然这是在模拟情况下的，如果在实际中并不用将误差缩到这么小</p><p>好了，至此我们来总结一下PID三个参数的效果：</p><p><img src="9.png"></p><p>这只是我们这个期望下的结果，让我们调大一下期望值：</p><p><img src="10.png"></p><p>可以看到初始超调值已经从之前的0.1到了现在的0.6，而我们的静态误差从零后六位降到了零后三位，让我们来继续调大一下期望值</p><p><img src="11.png"></p><p>这时初始超调值已经上升到个位数了，这还只是在一个模拟的系统之中，系统不存在干扰和误差，如果我们加入干扰和误差，那么就不会取得现在这样的效果了</p><p>PID控制的核心技术就是如何整定出PID控制器的三个最优参数，使得PID控制达到所期望的控制效果，另外需要解决的问题就是在面对复杂多变的非线性系统时，PID控制器如何能够实时在线整定控制器的三个特征参数，以适应动态变化的控制环境，这就是PID参数整定和自整定的问题，随着智能控制技术的发展和先进算法研究的深入，多种先进算法被应用于PID控制器，现有智能PID控制器的研究主要有专家系统型PID控制器、模糊PID控制器、神经网络PID控制器和基于遗传算法以及基于蚁群算法的PID控制器等等。PID控制器在实践中不断得到改进，这里我们就开始了解其中一种——模糊PID</p><p>下面我们就进入正题</p><h1 id="1-模糊PID的原理"><a href="#1-模糊PID的原理" class="headerlink" title="1.模糊PID的原理"></a>1.模糊PID的原理</h1><p>模糊PID控制，利用模糊逻辑并根据一定模糊规则对PID的参数进行实时的优化，以克服传统PID参数无法实时调整PID参数的缺点。模糊PID控制包括模糊化，确定模糊规则，解模糊等组成部分</p><p>以小车举例，如何让他能够按照预定轨道正确行驶呢？</p><p>先确定当前轨道距离预定轨道的偏差E以及当前偏差和上次偏差变化EC，根据模糊规则进行模糊推理，最后对模糊参数进行解模糊，输出相应的PID参数</p><p>老规矩先放个控制器的图：</p><p><img src="12.png"></p><h1 id="2-模糊化"><a href="#2-模糊化" class="headerlink" title="2.模糊化"></a>2.模糊化</h1><p>模糊控制的输入依然是我们熟悉的error(t)与error(t-1),步骤可分为模糊化、模糊推理、解模糊三个步骤，现在我们将从模糊化说起</p><p>模糊化是模糊算法非常重要的一步，首先确定对应各语言变量的模糊子集，然后根据量化的结果，我们就可以判断该输入所属的集合并计算出对应的隶属度。计算隶属度的方法有很多，最常用的是使用三角形隶属度函数或梯形隶属度函数等来计算获得</p><p>建立论域：</p><p>例如：{-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6}</p><p>将所的变量量化一下：</p><p><img src="13.png"></p><p>确定隶属度函数，这里取三角隶属度函数，例如这样：</p><p><img src="14.png"></p><h1 id="2-模糊规则"><a href="#2-模糊规则" class="headerlink" title="2.模糊规则"></a>2.模糊规则</h1><p>根据采集回来的E和EC我们可以推理出他们各自所占据的隶属度，此时我们可以根据模糊规则表去找出输出值所对应的隶属度，这里放个模糊规则表的图：</p><p><img src="15.png"></p><p>这个表我们可以自己定制，表中的词也可以自行替换，其中U带入PID三个变量即可获得其对应的模糊规则表</p><p>当然在实际应用中，PID三个表的其中对应规则需要做不同的修改，这里就简单的提一下：</p><ul><li>Kp模糊规则：依据PID的调试经验我们可以知道，在PID控制器中，Kp值的选取决定于系统的响应速度。增大Kp能提高响应速度，减小稳态偏差；但是，Kp值过大会产生较大的超调，甚至使系统不稳定减小Kp可以减小超调，提高稳定性，但Kp过小会减慢响应速度，延长调节时间。因此，调节初期应适当取较大的Kp值以提高响应速度，而在调节中期，Kp则取较小值，以使系统具有较小的超调并保证一定的响应速度；而在调节过程后期再将Kp值调到较大值来减小静差，提高控制精度，我们对上面那张模糊规则表不用做过多的修改，只需要将PB整体左上移动一个单位，NB同理右下一个单位，空余部分用PM，PS和NM，NS填充</li><li>Ki模糊规则：在系统控制中，积分控制主要是用来消除系统的稳态偏差。由于某些原因(如饱和非线性等)，积分过程有可能在调节过程的初期产生积分饱和，从而引起调节过程的较大超调。因此，在调节过程的初期，为防止积分饱和，其积分作用应当弱一些，甚至可以取零；而在调节中期，为了避免影响稳定性，其积分作用应该比较适中；最后在过程的后期，则应增强积分作用，以减小调节静差，我们只需要将模糊规则表关于ZO做一个镜像翻转，将其中内容填入即可，例左上第一个，与右下第一个互换</li><li>Kd模糊规则：微分环节的调整主要是针对大惯性过程引入的，微分环节系数的作用在于改变系统的动态特性。系统的微分环节系数能反映信号变化的趋势，并能在偏差信号变化太大之前，在系统中引入一个有效的早期修正信号，从而加快响应速度，减少调整时间，消除振荡．最终改变系统的动态性能。因此，Kd值的选取对调节动态特性影响很大。Kd值过大，调节过程制动就会超前，致使调节时间过长；Kd值过小，调节过程制动就会落后，从而导致超调增加。根据实际过程经验，在调节初期，应加大微分作用，这样可得到较小甚至避免超调；而在中期，由于调节特性对Kd值的变化比较敏感，因此，Kd值应适当小一些并应保持固定不变；然后在调节后期，Kd值应减小，以减小被控过程的制动作用，进而补偿在调节过程初期由于Kd值较大所造成的调节过程的时间延长，Kd的模糊规则表调整起来不是很容易，所以可以根据自身系统进行微调即可</li></ul><h1 id="3-解模糊化"><a href="#3-解模糊化" class="headerlink" title="3.解模糊化"></a>3.解模糊化</h1><p>就以上述模糊规则表来解释</p><p>当E正好落在PM上，EC正好落在NB上之后，那么我们解模糊化输出的便是ZO</p><p>但一般情况下是EC落在NB-NM之间，E落在PM-PB之间，那么我们不妨假设EC属于NB的隶属度为a（a&lt;1）那么，EC属于NM的隶属度就是1-a，同理可得，E属于PM的隶属度为b（b&lt;1），属于PB的隶属度为1-b</p><p>那么NB与PM所对应的ZO隶属度就为a*b，其余三个分别为：</p><ul><li>NB-PB——ZO为a*(1-b)</li><li>NM-PM——ZO为b*(1-b)</li><li>NM-PB——NS为(1-a)*(1-b)</li></ul><p>总得隶属度加起来刚好是1</p><p>这里我们使用如下公式便可算出：</p><p><img src="16.png"></p><p>其中M为隶属度，F为模糊化值</p><p>当然，如果我们使用的是量化值，我们还需要将其转化为实际值，这里我们用如下公式来算：</p><p><img src="17.png"></p><p>其中∆K为我们所计算得到的值，而α为系数， 通过该公式可分别求出KP，KI，KD</p><h1 id="4-仿真"><a href="#4-仿真" class="headerlink" title="4.仿真"></a>4.仿真</h1><ul><li>第一步，打开matlab输入fuzzy</li><li><img src="18.png"></li><li>在上面那个弹出窗口里点开Edit-Rules，输入四乘四简化版模糊规则</li><li><img src="26.png"></li><li>打开Edit，选择Add Variable…添加输入输出变量</li><li><img src="19.png"></li><li>双击e修改其值Range与Params，这里改成你设定的论域，同理也修改ec、kp、ki、kd</li><li><img src="20.png"></li><li>这里我只建立了简化版的模糊规则，并没有细分</li><li>建立完成确认无误后，点击File-Export-to workspace..</li><li>将这个导入工作区之后，建立simulink模型</li><li><img src="21.png"></li><li>其中调整图中蓝色部分，改为自己fuzzy文件的名字</li><li><img src="22.png"></li><li>运行查看结果：</li><li><img src="23.png"></li><li>图中蓝线为模糊PID的值，黄线为普通PID的值，当然这里模糊PID的值已经是我调试过的，调试方法大致与普通PID有相似之处，不过我并不建议大伙像我一样经验调参，最好是有合理的计算和分析步骤</li><li>现在我们来改变一下阶跃信号的值，也就是我们的期望</li><li><img src="24.png"></li><li>虽然当期望是一的时候我们的超调现象十分明显，但当期望变为100的时候，曲线已经很平稳了，而且无论是期望1还是期望100，模糊PID的响应都要优于普通PID</li><li>当然除此之外，我们还可以通过一些别的方式来看我们所写的模糊PID</li><li>打开View-Rules，在这个图中我们可以通过拖动左边两条红色的细线来查看不同的输出结果，以此达到直观的了解</li><li><img src="25.png"></li><li>打开View-Surface，我们可以得到一个基本曲面图</li><li><img src="27.png"></li></ul><p>至此，本次仿真结束，喜欢的话可以收藏本站</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> PID </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模糊PID </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ECC加密算法</title>
      <link href="/2020/03/02/ecc/"/>
      <url>/2020/03/02/ecc/</url>
      
        <content type="html"><![CDATA[<h1 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h1><p>在ECC中，利用特殊形式的椭圆曲线，其方程如下：</p><p><img src="0.png"></p><p>其中：</p><p><img src="1.png"></p><p>这个是用来排除单数曲线所必须的，其中<em>a</em>和<em>b</em>决定了曲线在坐标系的不同形状。</p><p>在开始之前我们需要引入一个定义——Abel（阿贝尔群）：</p><p>数学上是指定义了二元操作运算并且使用“+”表示的一个集合。必须满足以下要求：</p><p>1、封闭性（closure）：如果<em>a</em>和<em>b</em>都是群成员，那么<em>a</em> + <em>b</em>也应该是群成员。</p><p>2、组合性（associativity）：*(a+b)+c=a+(b+c)*</p><p>3、单位元：0值就是单位元。</p><p>4、逆元：<em>a</em>的逆元就是-<em>a</em>。</p><p>当然阿贝尔群除了上面的性质外还满足交换律公理a<em>b=b</em>a。</p><p>同样在椭圆曲线也可以定义阿贝尔群：</p><p>1、设<em>O</em>为单位元，对曲线上所有的点<em>P</em>都满足P+O=P。</p><p>2、对点<em>P</em>（<em>x</em>，<em>y</em>）有点<em>Q</em>（<em>x</em>，-<em>y</em>）满足<em>P+Q=O</em>，则称点<em>Q</em>为<em>P</em>的逆元，记为-<em>P</em>，在此基础上我们可以定义减法规则：<em>P-Q=P+(-Q)</em> 。</p><p>3、异点相加：对不同且不互逆的点<em>P</em>（<em>x</em>，<em>y</em>）与<em>Q</em>（<em>a</em>，<em>b</em>），即<em>x</em>≠<em>a</em>，Ep（<em>a</em>，<em>b</em>）则：<em>P(x , y)+Q(c , d)=S(i , j)</em></p><p>其中：</p><p><img src="2.png"></p><p>4、倍点原则：对于一个点<em>P</em>（<em>x</em>，<em>y</em>），若<em>P</em>≠-<em>P</em>，即<em>y</em>≠0，Ep（<em>a</em>，<em>b</em>）则有：</p><p><em>P(x,y)+P(x,y)=2P(x,y)=S(i.j)</em></p><p>其中：</p><p><img src="3.png"></p><p>并不是所有的点都可以求倍点，同样也不是所有的点都可以用来建立椭圆曲线系统，所以就引入了有限域椭圆曲线点的阶。</p><p>设<em>P</em>是椭圆Ep（<em>a</em>，<em>b</em>）上的点，若存在最小的正整数<em>n</em>使得：<em>nP=O</em>（O是无穷远的点）则称<em>n</em>为<em>P</em>的阶，若<em>n</em>不存在，则称<em>P</em>是无限阶的。</p><p>若一个群<em>G</em>的每一个元都是<em>G</em>的某一个固定元<em>a</em>的乘方，则称<em>G</em>为循环群记为：</p><p><img src="4.png"></p><p><em>a</em>称为<em>G</em>的一个生成元。</p><p>在某些条件下，椭圆曲线上所有的点构成一个循环群，并且一定存在一个本原元，它的幂值生成了整个群（这就是离散对数问题）。</p><p>给定一个椭圆曲线E，确定本原元<em>P</em>和一个元素<em>T</em>，那么离散对数问题就是找到整数<em>D</em>，满足：<em>P+P+P+….+P=DP=T</em></p><p>在密码体制中，D通常为整数，也是私钥，曲线上的点T是公钥。</p><p>至此，椭圆曲线的原理基本以阐述完毕，总结如下：</p><p>椭圆曲线Ep（<em>a</em>，<em>b</em>）上的点<em>G</em>，<em>n</em>为<em>G</em>的阶*(nG=O∞)<em>，</em>d<em>为小于</em>n<em>的整数。考虑方程：</em>P=dG*</p><p>其中<em>P,G</em>属于<em>E</em>，<em>d</em>为整数。</p><p>由<em>d</em>，<em>G</em>计算<em>P</em>很容易，而有<em>P</em>,<em>G</em>求<em>d</em>计算上是不可行的。</p><p>这就是椭圆曲线密码体制安全的基础，又叫做椭圆曲线的离散对数问题。</p><p>其中点<em>G</em>为基点，<em>d</em>（<em>d</em>&lt;<em>n</em>）为私有密钥，<em>P</em>为公开密钥。</p><h1 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h1><p>取一素数<em>p</em>，两个参数<em>a</em>，<em>b</em>，得到Ep（<em>a</em>，<em>b</em>）。</p><p>利用公式验证所得曲线为可用曲线，判断公式：</p><p><img src="1.png"></p><p>画出椭圆曲线的图，得知隐函数的情况下调用ezplot画出椭圆曲线的图。</p><p>画出曲线的散点图，计算方法与公式如下：</p><p>计算<em>x</em>=0至*x=(p-1)*中，计算：</p><p><img src="5.png"></p><p>其中若能求的整数平方根的数则为有效点，同时计算出:</p><p><img src="6.png"></p><p><img src="7.png"></p><p>取基点<em>G</em>，由<em>G</em>计算出曲线的阶<em>n</em>，计算公式为：*(n-1)G=-G*</p><p>写出-<em>G</em>的计算公式：*-G(x ,z)=G(x ,-1y)mod p = G(x ,p-y)*</p><p>选取私有密钥<em>key</em>（<em>key</em>&lt;<em>n</em>），计算公开密钥<em>K=keyG</em></p><p>有了上述内容，可以着手设计加密解密步骤了。</p><p>加密步骤：输入一个随机数<em>r</em>（<em>r</em>&lt;<em>n</em>）作为加密方的私钥，利用输入的随机数生成点:</p><p><img src="8.png"></p><p> G_r为加密方的公钥，用到的公式如下：</p><p><img src="9.png"></p><p>K_r为共享密钥，计算公示如下：</p><p><img src="10.png"></p><p>将明文转化为密文，利用K_r的x轴坐标作为加密密钥，公式如下：</p><p><img src="11.png"></p><p>解密步骤：利用加密方传回的密文<em>C</em>和G_r求解<em>M</em>，在知道  和己方私钥的情况下求解<em>M</em>是十分容易的，先解出共享密钥K_r，利用其x轴坐标用简单的公式：</p><p><img src="12.png"></p><p>最终得到想要的明文<em>M</em>。</p><p>思维导图如下：</p><p><img src="13.png"></p><h1 id="运行结果演示"><a href="#运行结果演示" class="headerlink" title="运行结果演示"></a>运行结果演示</h1><p>代码见附录，这里只演示。</p><p>请输入a的值：10</p><p>请输入b的值：5</p><p>请输入p的值：23</p><p>请确曲线：1确认，0退出</p><p>1</p><p><img src="14.png"></p><p>椭圆曲线的散列图为：</p><p>22 - - - - - - - - - - 1 - - - - - - - - - - - - </p><p>21 - - - - - - - 1 - - - - - - - - - - - - - - - </p><p>20 - - - - - - - - - - - - - 1 - - - - - - - - - </p><p>19 - 1 - 1 - - - - - - - - - - - - - - - 1 - - - </p><p>18 - - - - - - - - - - - - - - - - - - - - - - - </p><p>17 - - - - - - - - - - - - 1 - - - - - - - - - - </p><p>16 - - - - - - - - - - - - - - - - - - - - - - - </p><p>15 - - - - - - - - - - - - - - - - - - - - - - - </p><p>14 - - - - - - - - - - - - - - - - - - - - - - - </p><p>13 - - - - - - - - - - - - - - - - - - - - - - - </p><p>12 - - - - - - - - - - - - - - - - 1 - - - - - - </p><p>11 - - - - - - - - - - - - - - - - 1 - - - - - - </p><p>10 - - - - - - - - - - - -  - - - - - - - - - - - </p><p>9 - - - - - - - - - - - - - - - - - - - - - - - </p><p>8 - - - - - - - - - - - - - - - - - - - - - - - </p><p>7 - - - - - - - - - - - - - - - - - - - - - - - </p><p>6  - - - - - - - - - - - - 1 - - - - - - - - - - </p><p>5 - - - - - - - - - - - - - - - - - - - - - - - </p><p>4 - 1 - 1 - - - - - - - - - - - - - - - 1 - - - </p><p>3 - - - - - - - - - - - - - 1 - - - - - - - - - </p><p>2 - - - - - - - 1 - - - - - - - - - - - - - - - </p><p>1 - - - - - - - - - - 1 - - - - - - - - - - - - </p><p>0 - - - - - - - - - - - - - - - - - - - - - 1 - </p><p>0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22</p><p>1：在如上坐标系中选一个值为G的坐标</p><p>1：请输入选取的x坐标值：10</p><p>1：请输入选取的y坐标值：1</p><p>1：请输入私钥小key（&lt;9）：8</p><p>2：请输入一个整数k（&lt;9）用于求kG和kQ：7</p><p>2：请输入需要加密的字符串:ECC加密算法</p><p>密文为：(16,11),1104-(16,11),1072-(16,11),1072-(16,11),338432-(16,11),375904-(16,11),506224-(16,11),445776-</p><p>1解密得到明文：ECC加密算法</p><p>结束</p><h1 id="ECC加密算法的优点"><a href="#ECC加密算法的优点" class="headerlink" title="ECC加密算法的优点"></a>ECC加密算法的优点</h1><p>1、安全性高：攻击有限域上的离散对数问题可以使用指数积分法，其运算的复杂度</p><p><img src="15.png"></p><p>其中<em>p</em>是模数（为素数）。而它对于椭圆曲线上的离散对数问题并不有效。目前攻击椭圆曲线上离散对数问题的方法只有适合攻击任何循环群上离散对数问题的大步小步法，其运算复杂度为：</p><p><img src="16.png"></p><p>其中<em>P_max</em>是椭圆曲线所形成的Abel群的阶的最大因子。因此，椭圆曲线密码体制比基于有限域上的离散对数问题的公钥体制更加安全</p><p>2、密钥量小：由攻击两者的算法复杂度可知，在实现相同的安全性能条件下，椭圆曲线密码体制所需的密钥量远比基于有限域上的离散对数问题的公钥体制的密钥量小</p><p>3、灵活性好：有限域GF(q)一定情况下，其上的循环群(即GF(q)-{0})就定了。而GF(q)上的椭圆曲线可以通过改变曲线参数，得到不同的曲线，形成不同的循环群。因此，椭圆曲线具有丰富的群结构和多选择性。</p><p>正是由于椭圆曲线具有丰富的群结构和多种选择性，并可在保持和RSA/DSA体制同样安全性能的前提下，大大缩短了密钥长度(目前160比特足以保证安全性)，因而在密码领域有着广阔的引用前景。下表给出了椭圆曲线密码体制和RSA/DSA体制在保持同等安全的条件下各自所需的密钥长度。</p><p><img src="17.png"></p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><pre class=" language-python"><code class="language-python"><span class="token number">1</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">#-*- codeing = utf-8 -*-  </span><span class="token number">2</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">#@Time : 2020/2/24 11:46  </span><span class="token number">3</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">#@Author : Friats  </span><span class="token number">4</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">#@File : ECC.py  </span><span class="token number">5</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">#@Software : PyCharm  </span><span class="token number">6</span><span class="token punctuation">.</span>    <span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> mp  <span class="token number">7</span><span class="token punctuation">.</span>    <span class="token keyword">from</span> sympy<span class="token punctuation">.</span>parsing<span class="token punctuation">.</span>sympy_parser <span class="token keyword">import</span> parse_expr  <span class="token number">8</span><span class="token punctuation">.</span>    <span class="token keyword">from</span> sympy <span class="token keyword">import</span> plot_implicit  <span class="token number">9</span><span class="token punctuation">.</span>      <span class="token number">10</span><span class="token punctuation">.</span>    <span class="token triple-quoted-string string">""" 11.    变量定义如下 12.    a:椭圆曲线参数a 13.    b:椭圆曲线参数b 14.    p:椭圆曲线参数p 15.    n:曲线的阶n 16.    G_x:基点G的x轴坐标 17.    G_y:基点G的y轴坐标 18.    KEY_x:解密方公钥x轴坐标 19.    KEY_y:解密方公钥y轴坐标 20.    key:解密方私钥 21.    K_G_x:加密方公钥x轴坐标 22.    K_G_y:加密方公钥y轴坐标 23.    K_Q_x:共享密钥x轴坐标 24.    K_Q_y:共享密钥y轴坐标 25.    """</span>  <span class="token number">26</span><span class="token punctuation">.</span>    <span class="token triple-quoted-string string">""" 27.    函数定义如下 28.    get_inverse(): 取逆元 29.    get_gcd():     取最大公约数 30.    get_np():      求解公式Q=np 31.    get_rank():    求曲线的阶n 32.    get_param():   计算p和-p 33.    get_graph():   求解并计算散点图 34.    get_ng():      计算nG 35.    """</span>  <span class="token number">36</span><span class="token punctuation">.</span>      <span class="token number">37</span><span class="token punctuation">.</span>    <span class="token keyword">def</span> <span class="token function">get_inverse</span><span class="token punctuation">(</span>mu<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token number">38</span><span class="token punctuation">.</span>        <span class="token triple-quoted-string string">""" 39.        取逆元 40.        :param mu: 输入参数1 41.        :param p: 曲线的参数p 42.        :return: 参数1的逆元，-1逆元不存在 43.        """</span>  <span class="token number">44</span><span class="token punctuation">.</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token number">45</span><span class="token punctuation">.</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">*</span>mu<span class="token punctuation">)</span><span class="token operator">%</span>p <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>  <span class="token number">46</span><span class="token punctuation">.</span>                <span class="token keyword">return</span> i  <span class="token number">47</span><span class="token punctuation">.</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>  <span class="token number">48</span><span class="token punctuation">.</span>      <span class="token number">49</span><span class="token punctuation">.</span>    <span class="token keyword">def</span> <span class="token function">get_gcd</span><span class="token punctuation">(</span>zi<span class="token punctuation">,</span> mu<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token number">50</span><span class="token punctuation">.</span>        <span class="token triple-quoted-string string">""" 51.        用递归求出最大公约数 52.        :param zi: 输入参数1 53.        :param mu: 输入参数2 54.        :return: 最大公约数 55.        """</span>  <span class="token number">56</span><span class="token punctuation">.</span>        <span class="token keyword">if</span> mu<span class="token punctuation">:</span>  <span class="token number">57</span><span class="token punctuation">.</span>            <span class="token keyword">return</span> get_gcd<span class="token punctuation">(</span>mu<span class="token punctuation">,</span> zi<span class="token operator">%</span>mu<span class="token punctuation">)</span>  <span class="token number">58</span><span class="token punctuation">.</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>  <span class="token number">59</span><span class="token punctuation">.</span>            <span class="token keyword">return</span> zi  <span class="token number">60</span><span class="token punctuation">.</span>      <span class="token number">61</span><span class="token punctuation">.</span>      <span class="token number">62</span><span class="token punctuation">.</span>    <span class="token keyword">def</span> <span class="token function">get_np</span><span class="token punctuation">(</span>x1<span class="token punctuation">,</span> y1<span class="token punctuation">,</span> x2<span class="token punctuation">,</span> y2<span class="token punctuation">,</span> a<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token number">63</span><span class="token punctuation">.</span>        <span class="token triple-quoted-string string">""" 64.        求解公式Q=np 65.        :param x1: 点1的x轴坐标 66.        :param y1: 点1的y轴坐标 67.        :param x2: 点2的x轴坐标 68.        :param y2: 点2的y轴坐标 69.        :param a: 曲线参数a 70.        :param p: 曲线参数p 71.        :return: 返回Q的坐标 72.        """</span>  <span class="token number">73</span><span class="token punctuation">.</span>        flag <span class="token operator">=</span> <span class="token number">1</span>  <span class="token comment" spellcheck="true"># 定义符号位（+/-）  </span><span class="token number">74</span><span class="token punctuation">.</span>      <span class="token number">75</span><span class="token punctuation">.</span>        <span class="token comment" spellcheck="true"># 如果 p=q  k=(3x2+a)/2y1mod p  </span><span class="token number">76</span><span class="token punctuation">.</span>        <span class="token keyword">if</span> x1 <span class="token operator">==</span> x2 <span class="token operator">and</span> y1 <span class="token operator">==</span> y2<span class="token punctuation">:</span>  <span class="token number">77</span><span class="token punctuation">.</span>            zi <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token punctuation">(</span>x1 <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> a  <span class="token comment" spellcheck="true"># 计算分子      【求导】  </span><span class="token number">78</span><span class="token punctuation">.</span>            mu <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> y1    <span class="token comment" spellcheck="true"># 计算分母  </span><span class="token number">79</span><span class="token punctuation">.</span>      <span class="token number">80</span><span class="token punctuation">.</span>        <span class="token comment" spellcheck="true"># 若P≠Q，则k=(y2-y1)/(x2-x1) mod p  </span><span class="token number">81</span><span class="token punctuation">.</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>  <span class="token number">82</span><span class="token punctuation">.</span>            zi <span class="token operator">=</span> y2 <span class="token operator">-</span> y1  <span class="token number">83</span><span class="token punctuation">.</span>            mu <span class="token operator">=</span> x2 <span class="token operator">-</span> x1  <span class="token number">84</span><span class="token punctuation">.</span>            <span class="token keyword">if</span> zi<span class="token operator">*</span> mu <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>  <span class="token number">85</span><span class="token punctuation">.</span>                flag <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true"># 符号0为-（负数）  </span><span class="token number">86</span><span class="token punctuation">.</span>                zi <span class="token operator">=</span> abs<span class="token punctuation">(</span>zi<span class="token punctuation">)</span>  <span class="token number">87</span><span class="token punctuation">.</span>                mu <span class="token operator">=</span> abs<span class="token punctuation">(</span>mu<span class="token punctuation">)</span>  <span class="token number">88</span><span class="token punctuation">.</span>      <span class="token number">89</span><span class="token punctuation">.</span>        <span class="token comment" spellcheck="true"># 将分子和分母化为最简  </span><span class="token number">90</span><span class="token punctuation">.</span>        gcd_value <span class="token operator">=</span> get_gcd<span class="token punctuation">(</span>zi<span class="token punctuation">,</span> mu<span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># 最大公約數  </span><span class="token number">91</span><span class="token punctuation">.</span>        zi <span class="token operator">=</span> zi <span class="token operator">//</span> gcd_value            <span class="token comment" spellcheck="true"># 整除  </span><span class="token number">92</span><span class="token punctuation">.</span>        mu <span class="token operator">=</span> mu <span class="token operator">//</span> gcd_value  <span class="token number">93</span><span class="token punctuation">.</span>        <span class="token comment" spellcheck="true"># 求分母的逆元  逆元： ∀a ∈G ，ョb∈G 使得 ab = ba = e  </span><span class="token number">94</span><span class="token punctuation">.</span>        <span class="token comment" spellcheck="true"># P(x,y)的负元是 (x,-y mod p)= (x,p-y) ，有P+(-P)= O∞  </span><span class="token number">95</span><span class="token punctuation">.</span>        inverse_value <span class="token operator">=</span> get_inverse<span class="token punctuation">(</span>mu<span class="token punctuation">,</span> p<span class="token punctuation">)</span>  <span class="token number">96</span><span class="token punctuation">.</span>        k <span class="token operator">=</span> <span class="token punctuation">(</span>zi <span class="token operator">*</span> inverse_value<span class="token punctuation">)</span>  <span class="token number">97</span><span class="token punctuation">.</span>      <span class="token number">98</span><span class="token punctuation">.</span>        <span class="token keyword">if</span> flag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                   <span class="token comment" spellcheck="true"># 斜率负数 flag==0  </span><span class="token number">99</span><span class="token punctuation">.</span>            k <span class="token operator">=</span> <span class="token operator">-</span>k  <span class="token number">100</span><span class="token punctuation">.</span>        k <span class="token operator">=</span> k <span class="token operator">%</span> p  <span class="token number">101</span><span class="token punctuation">.</span>        <span class="token comment" spellcheck="true"># 计算x3,y3 P+Q  </span><span class="token number">102</span><span class="token punctuation">.</span>        <span class="token triple-quoted-string string">""" 103.            x3≡k2-x1-x2(mod p) 104.            y3≡k(x1-x3)-y1(mod p) 105.        """</span>  <span class="token number">106</span><span class="token punctuation">.</span>        x3 <span class="token operator">=</span> <span class="token punctuation">(</span>k <span class="token operator">**</span> <span class="token number">2</span> <span class="token operator">-</span> x1 <span class="token operator">-</span> x2<span class="token punctuation">)</span> <span class="token operator">%</span> p  <span class="token number">107</span><span class="token punctuation">.</span>        y3 <span class="token operator">=</span> <span class="token punctuation">(</span>k <span class="token operator">*</span> <span class="token punctuation">(</span>x1 <span class="token operator">-</span> x3<span class="token punctuation">)</span> <span class="token operator">-</span> y1<span class="token punctuation">)</span> <span class="token operator">%</span> p  <span class="token number">108</span><span class="token punctuation">.</span>        <span class="token keyword">return</span> x3<span class="token punctuation">,</span>y3  <span class="token number">109</span><span class="token punctuation">.</span>      <span class="token number">110</span><span class="token punctuation">.</span>    <span class="token keyword">def</span> <span class="token function">get_rank</span><span class="token punctuation">(</span>x0<span class="token punctuation">,</span> y0<span class="token punctuation">,</span> a<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token number">111</span><span class="token punctuation">.</span>        <span class="token triple-quoted-string string">""" 112.        计算曲线的阶n 113.        :param x0: 输入点的x轴坐标 114.        :param y0: 输入点的y轴坐标 115.        :param a: 曲线参数a 116.        :param p: 曲线参数p 117.        :return: 曲线的阶n 118.        """</span>  <span class="token number">119</span><span class="token punctuation">.</span>        x1 <span class="token operator">=</span> x0             <span class="token comment" spellcheck="true">#-p的x坐标  </span><span class="token number">120</span><span class="token punctuation">.</span>        y1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">*</span>y0<span class="token punctuation">)</span><span class="token operator">%</span>p      <span class="token comment" spellcheck="true">#-p的y坐标  </span><span class="token number">121</span><span class="token punctuation">.</span>        tempX <span class="token operator">=</span> x0  <span class="token number">122</span><span class="token punctuation">.</span>        tempY <span class="token operator">=</span> y0  <span class="token number">123</span><span class="token punctuation">.</span>        n <span class="token operator">=</span> <span class="token number">1</span>  <span class="token number">124</span><span class="token punctuation">.</span>        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>  <span class="token number">125</span><span class="token punctuation">.</span>            n <span class="token operator">+=</span> <span class="token number">1</span>  <span class="token number">126</span><span class="token punctuation">.</span>            <span class="token comment" spellcheck="true">#         # 求p+q的和，得到n*p，直到求出阶  </span><span class="token number">127</span><span class="token punctuation">.</span>            p_x<span class="token punctuation">,</span>p_y <span class="token operator">=</span> get_np<span class="token punctuation">(</span>tempX<span class="token punctuation">,</span> tempY<span class="token punctuation">,</span> x0<span class="token punctuation">,</span> y0<span class="token punctuation">,</span> a<span class="token punctuation">,</span> p<span class="token punctuation">)</span>  <span class="token number">128</span><span class="token punctuation">.</span>            <span class="token comment" spellcheck="true"># 如果 == -p,那么阶数+1，返回  </span><span class="token number">129</span><span class="token punctuation">.</span>            <span class="token keyword">if</span> p_x <span class="token operator">==</span> x1 <span class="token operator">and</span> p_y <span class="token operator">==</span> y1<span class="token punctuation">:</span>  <span class="token number">130</span><span class="token punctuation">.</span>                <span class="token keyword">return</span> n<span class="token operator">+</span><span class="token number">1</span>  <span class="token number">131</span><span class="token punctuation">.</span>            tempX <span class="token operator">=</span> p_x  <span class="token number">132</span><span class="token punctuation">.</span>            tempY <span class="token operator">=</span> p_y  <span class="token number">133</span><span class="token punctuation">.</span>      <span class="token number">134</span><span class="token punctuation">.</span>      <span class="token number">135</span><span class="token punctuation">.</span>    <span class="token keyword">def</span> <span class="token function">get_param</span><span class="token punctuation">(</span>x0<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token number">136</span><span class="token punctuation">.</span>        <span class="token triple-quoted-string string">""" 137.        计算P和-P 138.        :param x0:点的x轴坐标 139.        :param a:曲线参数a 140.        :param b:曲线参数b 141.        :param p:曲线参数p 142.        :return:点P和-P 143.        """</span>  <span class="token number">144</span><span class="token punctuation">.</span>        y0 <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>  <span class="token number">145</span><span class="token punctuation">.</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token number">146</span><span class="token punctuation">.</span>            <span class="token comment" spellcheck="true"># 满足取模约束条件，椭圆曲线Ep(a,b)，p为质数，x,y∈[0,p-1]  </span><span class="token number">147</span><span class="token punctuation">.</span>            <span class="token keyword">if</span> i<span class="token operator">**</span><span class="token number">2</span><span class="token operator">%</span>p <span class="token operator">==</span> <span class="token punctuation">(</span>x0<span class="token operator">**</span><span class="token number">3</span> <span class="token operator">+</span> a<span class="token operator">*</span>x0 <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token operator">%</span>p<span class="token punctuation">:</span>  <span class="token number">148</span><span class="token punctuation">.</span>                y0 <span class="token operator">=</span> i  <span class="token number">149</span><span class="token punctuation">.</span>                <span class="token keyword">break</span>  <span class="token number">150</span><span class="token punctuation">.</span>      <span class="token number">151</span><span class="token punctuation">.</span>        <span class="token comment" spellcheck="true"># 如果y0没有，返回false  </span><span class="token number">152</span><span class="token punctuation">.</span>        <span class="token keyword">if</span> y0 <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>  <span class="token number">153</span><span class="token punctuation">.</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>  <span class="token number">154</span><span class="token punctuation">.</span>      <span class="token number">155</span><span class="token punctuation">.</span>        <span class="token comment" spellcheck="true"># 计算-y（负数取模）  </span><span class="token number">156</span><span class="token punctuation">.</span>        x1 <span class="token operator">=</span> x0  <span class="token number">157</span><span class="token punctuation">.</span>        y1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">*</span>y0<span class="token punctuation">)</span> <span class="token operator">%</span> p  <span class="token number">158</span><span class="token punctuation">.</span>        <span class="token keyword">return</span> x0<span class="token punctuation">,</span>y0<span class="token punctuation">,</span>x1<span class="token punctuation">,</span>y1  <span class="token number">159</span><span class="token punctuation">.</span>      <span class="token number">160</span><span class="token punctuation">.</span>    <span class="token keyword">def</span> <span class="token function">get_graph</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token number">161</span><span class="token punctuation">.</span>        <span class="token triple-quoted-string string">""" 162.        求解并计算散点图 163.        :param a: 曲线参数a 164.        :param b: 曲线参数b 165.        :param p: 曲线参数p 166.        :return: 返回一个二维数组并打印，大小[p][p] 167.        """</span>  <span class="token number">168</span><span class="token punctuation">.</span>        x_y <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token number">169</span><span class="token punctuation">.</span>        <span class="token comment" spellcheck="true"># 初始化二维数组，将所有的数组元素用-填充  </span><span class="token number">170</span><span class="token punctuation">.</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token number">171</span><span class="token punctuation">.</span>            x_y<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'-'</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token number">172</span><span class="token punctuation">.</span>      <span class="token number">173</span><span class="token punctuation">.</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token number">174</span><span class="token punctuation">.</span>            val <span class="token operator">=</span>get_param<span class="token punctuation">(</span>i<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> p<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 椭圆曲线上的点  </span><span class="token number">175</span><span class="token punctuation">.</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>val <span class="token operator">!=</span> <span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token number">176</span><span class="token punctuation">.</span>                x0<span class="token punctuation">,</span>y0<span class="token punctuation">,</span>x1<span class="token punctuation">,</span>y1 <span class="token operator">=</span> val  <span class="token number">177</span><span class="token punctuation">.</span>                x_y<span class="token punctuation">[</span>x0<span class="token punctuation">]</span><span class="token punctuation">[</span>y0<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>  <span class="token number">178</span><span class="token punctuation">.</span>                x_y<span class="token punctuation">[</span>x1<span class="token punctuation">]</span><span class="token punctuation">[</span>y1<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>  <span class="token number">179</span><span class="token punctuation">.</span>      <span class="token number">180</span><span class="token punctuation">.</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"椭圆曲线的散列图为："</span><span class="token punctuation">)</span>  <span class="token number">181</span><span class="token punctuation">.</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">:</span>              <span class="token comment" spellcheck="true"># i= 0-> p-1  </span><span class="token number">182</span><span class="token punctuation">.</span>            temp <span class="token operator">=</span> p<span class="token number">-1</span><span class="token operator">-</span>i        <span class="token comment" spellcheck="true"># 倒序  </span><span class="token number">183</span><span class="token punctuation">.</span>      <span class="token number">184</span><span class="token punctuation">.</span>            <span class="token comment" spellcheck="true"># 格式化输出1/2位数，y坐标轴  </span><span class="token number">185</span><span class="token punctuation">.</span>            <span class="token keyword">if</span> temp <span class="token operator">>=</span> <span class="token number">10</span><span class="token punctuation">:</span>  <span class="token number">186</span><span class="token punctuation">.</span>                <span class="token keyword">print</span><span class="token punctuation">(</span>temp<span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">" "</span><span class="token punctuation">)</span>  <span class="token number">187</span><span class="token punctuation">.</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>  <span class="token number">188</span><span class="token punctuation">.</span>                <span class="token keyword">print</span><span class="token punctuation">(</span>temp<span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">"  "</span><span class="token punctuation">)</span>  <span class="token number">189</span><span class="token punctuation">.</span>      <span class="token number">190</span><span class="token punctuation">.</span>            <span class="token comment" spellcheck="true"># 输出具体坐标的值，一行  </span><span class="token number">191</span><span class="token punctuation">.</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token number">192</span><span class="token punctuation">.</span>                <span class="token keyword">print</span><span class="token punctuation">(</span>x_y<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>temp<span class="token punctuation">]</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">"  "</span><span class="token punctuation">)</span>  <span class="token number">193</span><span class="token punctuation">.</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#换行  </span><span class="token number">194</span><span class="token punctuation">.</span>      <span class="token number">195</span><span class="token punctuation">.</span>        <span class="token comment" spellcheck="true"># 输出 x 坐标轴  </span><span class="token number">196</span><span class="token punctuation">.</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"  "</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span>  <span class="token number">197</span><span class="token punctuation">.</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token number">198</span><span class="token punctuation">.</span>            <span class="token keyword">if</span> i <span class="token operator">>=</span><span class="token number">10</span><span class="token punctuation">:</span>  <span class="token number">199</span><span class="token punctuation">.</span>                <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">" "</span><span class="token punctuation">)</span>  <span class="token number">200</span><span class="token punctuation">.</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>  <span class="token number">201</span><span class="token punctuation">.</span>                <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">"  "</span><span class="token punctuation">)</span>  <span class="token number">202</span><span class="token punctuation">.</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span>  <span class="token number">203</span><span class="token punctuation">.</span>      <span class="token number">204</span><span class="token punctuation">.</span>    <span class="token keyword">def</span> <span class="token function">get_ng</span><span class="token punctuation">(</span>G_x<span class="token punctuation">,</span> G_y<span class="token punctuation">,</span> key<span class="token punctuation">,</span> a<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token number">205</span><span class="token punctuation">.</span>        <span class="token triple-quoted-string string">""" 206.        求解nG 207.        :param G_x: G的x轴坐标 208.        :param G_y: G的y轴坐标 209.        :param key: 解密方私钥 210.        :param a: 曲线参数a 211.        :param p: 曲线参数p 212.        :return: nG的坐标 213.        """</span>  <span class="token number">214</span><span class="token punctuation">.</span>        temp_x <span class="token operator">=</span> G_x  <span class="token number">215</span><span class="token punctuation">.</span>        temp_y <span class="token operator">=</span> G_y  <span class="token number">216</span><span class="token punctuation">.</span>        <span class="token keyword">while</span> key <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">:</span>  <span class="token number">217</span><span class="token punctuation">.</span>            temp_x<span class="token punctuation">,</span>temp_y <span class="token operator">=</span> get_np<span class="token punctuation">(</span>temp_x<span class="token punctuation">,</span>temp_y<span class="token punctuation">,</span> G_x<span class="token punctuation">,</span> G_y<span class="token punctuation">,</span> a<span class="token punctuation">,</span> p<span class="token punctuation">)</span>  <span class="token number">218</span><span class="token punctuation">.</span>            key <span class="token operator">-=</span> <span class="token number">1</span>  <span class="token number">219</span><span class="token punctuation">.</span>        <span class="token keyword">return</span> temp_x<span class="token punctuation">,</span>temp_y  <span class="token number">220</span><span class="token punctuation">.</span>      <span class="token number">221</span><span class="token punctuation">.</span>    <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token number">222</span><span class="token punctuation">.</span>        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>  <span class="token number">223</span><span class="token punctuation">.</span>            a <span class="token operator">=</span> int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token string">"请输入a的值："</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token number">224</span><span class="token punctuation">.</span>            b <span class="token operator">=</span> int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token string">"请输入b的值："</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token number">225</span><span class="token punctuation">.</span>            p <span class="token operator">=</span> int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token string">"请输入p的值："</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#用作模运算  </span><span class="token number">226</span><span class="token punctuation">.</span>            <span class="token comment" spellcheck="true"># 条件满足判断  </span><span class="token number">227</span><span class="token punctuation">.</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token operator">*</span><span class="token punctuation">(</span>a<span class="token operator">**</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">27</span><span class="token operator">*</span><span class="token punctuation">(</span>b<span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">%</span>p <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token number">228</span><span class="token punctuation">.</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"您输入的参数有误，请重新输入！！！\n"</span><span class="token punctuation">)</span>  <span class="token number">229</span><span class="token punctuation">.</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>  <span class="token number">230</span><span class="token punctuation">.</span>                <span class="token keyword">break</span>  <span class="token number">231</span><span class="token punctuation">.</span>        <span class="token comment" spellcheck="true">#利用隐函数画出椭圆曲线大致的图  </span><span class="token number">232</span><span class="token punctuation">.</span>        ezplot <span class="token operator">=</span> <span class="token keyword">lambda</span> expr<span class="token punctuation">:</span> plot_implicit<span class="token punctuation">(</span>parse_expr<span class="token punctuation">(</span>expr<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token number">233</span><span class="token punctuation">.</span>        ttte <span class="token operator">=</span><span class="token string">'x*x*x+x*'</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">+</span><span class="token string">'+'</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'-y*y'</span>  <span class="token number">234</span><span class="token punctuation">.</span>        ezplot<span class="token punctuation">(</span>ttte<span class="token punctuation">)</span>  <span class="token number">235</span><span class="token punctuation">.</span>        mp<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token number">236</span><span class="token punctuation">.</span>        <span class="token comment" spellcheck="true">#确认输入图谱  </span><span class="token number">237</span><span class="token punctuation">.</span>        tur <span class="token operator">=</span> int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token string">"请确曲线：1确认，0退出\n"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token number">238</span><span class="token punctuation">.</span>        <span class="token keyword">if</span> tur <span class="token operator">!=</span><span class="token number">0</span> <span class="token punctuation">:</span>  <span class="token number">239</span><span class="token punctuation">.</span>            <span class="token comment" spellcheck="true"># 输出椭圆曲线散点图  </span><span class="token number">240</span><span class="token punctuation">.</span>            get_graph<span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> p<span class="token punctuation">)</span>  <span class="token number">241</span><span class="token punctuation">.</span>            <span class="token comment" spellcheck="true"># 选点作为G点  </span><span class="token number">242</span><span class="token punctuation">.</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"1：在如上坐标系中选一个值为G的坐标"</span><span class="token punctuation">)</span>  <span class="token number">243</span><span class="token punctuation">.</span>            G_x <span class="token operator">=</span> int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token string">"1：请输入选取的x坐标值："</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token number">244</span><span class="token punctuation">.</span>            G_y <span class="token operator">=</span> int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token string">"1：请输入选取的y坐标值："</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token number">245</span><span class="token punctuation">.</span>            <span class="token comment" spellcheck="true"># 获取椭圆曲线的阶  </span><span class="token number">246</span><span class="token punctuation">.</span>            n <span class="token operator">=</span> get_rank<span class="token punctuation">(</span>G_x<span class="token punctuation">,</span> G_y<span class="token punctuation">,</span> a<span class="token punctuation">,</span> p<span class="token punctuation">)</span>  <span class="token number">247</span><span class="token punctuation">.</span>            <span class="token comment" spellcheck="true"># user1生成私钥，小key  </span><span class="token number">248</span><span class="token punctuation">.</span>            key <span class="token operator">=</span> int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token string">"1：请输入私钥小key（&lt;&amp;#123;&amp;#125;）："</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token number">249</span><span class="token punctuation">.</span>            <span class="token comment" spellcheck="true"># user1生成公钥，大KEY  </span><span class="token number">250</span><span class="token punctuation">.</span>      <span class="token number">251</span><span class="token punctuation">.</span>      <span class="token number">252</span><span class="token punctuation">.</span>            KEY_x<span class="token punctuation">,</span> kEY_y <span class="token operator">=</span> get_ng<span class="token punctuation">(</span>G_x<span class="token punctuation">,</span> G_y<span class="token punctuation">,</span> key<span class="token punctuation">,</span> a<span class="token punctuation">,</span> p<span class="token punctuation">)</span>  <span class="token number">253</span><span class="token punctuation">.</span>      <span class="token number">254</span><span class="token punctuation">.</span>            <span class="token comment" spellcheck="true"># user2阶段  </span><span class="token number">255</span><span class="token punctuation">.</span>            <span class="token comment" spellcheck="true"># user2拿到user1的公钥KEY，Ep(a,b)阶n，加密需要加密的明文数据  </span><span class="token number">256</span><span class="token punctuation">.</span>            <span class="token comment" spellcheck="true"># 加密准备  </span><span class="token number">257</span><span class="token punctuation">.</span>            k <span class="token operator">=</span> int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token string">"2：请输入一个整数k（&lt;&amp;#123;&amp;#125;）用于求kG和kQ："</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token number">258</span><span class="token punctuation">.</span>            k_G_x<span class="token punctuation">,</span> k_G_y <span class="token operator">=</span> get_ng<span class="token punctuation">(</span>G_x<span class="token punctuation">,</span> G_y<span class="token punctuation">,</span> k<span class="token punctuation">,</span> a<span class="token punctuation">,</span> p<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># kG  </span><span class="token number">259</span><span class="token punctuation">.</span>            k_Q_x<span class="token punctuation">,</span> k_Q_y <span class="token operator">=</span> get_ng<span class="token punctuation">(</span>KEY_x<span class="token punctuation">,</span> kEY_y<span class="token punctuation">,</span> k<span class="token punctuation">,</span> a<span class="token punctuation">,</span> p<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># kQ  </span><span class="token number">260</span><span class="token punctuation">.</span>      <span class="token number">261</span><span class="token punctuation">.</span>            <span class="token comment" spellcheck="true"># 加密  </span><span class="token number">262</span><span class="token punctuation">.</span>            plain_text <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token string">"2：请输入需要加密的字符串:"</span><span class="token punctuation">)</span>  <span class="token number">263</span><span class="token punctuation">.</span>            plain_text <span class="token operator">=</span> plain_text<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token number">264</span><span class="token punctuation">.</span>            <span class="token comment" spellcheck="true"># plain_text = int(input("user1：请输入需要加密的密文："))  </span><span class="token number">265</span><span class="token punctuation">.</span>            c <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token number">266</span><span class="token punctuation">.</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"密文为："</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span>  <span class="token number">267</span><span class="token punctuation">.</span>            <span class="token keyword">for</span> char <span class="token keyword">in</span> plain_text<span class="token punctuation">:</span>  <span class="token number">268</span><span class="token punctuation">.</span>                intchar <span class="token operator">=</span> ord<span class="token punctuation">(</span>char<span class="token punctuation">)</span>  <span class="token number">269</span><span class="token punctuation">.</span>                cipher_text <span class="token operator">=</span> intchar <span class="token operator">*</span> k_Q_x  <span class="token number">270</span><span class="token punctuation">.</span>                c<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>k_G_x<span class="token punctuation">,</span> k_G_y<span class="token punctuation">,</span> cipher_text<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token number">271</span><span class="token punctuation">.</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"(&amp;#123;&amp;#125;,&amp;#123;&amp;#125;),&amp;#123;&amp;#125;"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>k_G_x<span class="token punctuation">,</span> k_G_y<span class="token punctuation">,</span> cipher_text<span class="token punctuation">)</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">"-"</span><span class="token punctuation">)</span>  <span class="token number">272</span><span class="token punctuation">.</span>      <span class="token number">273</span><span class="token punctuation">.</span>            <span class="token comment" spellcheck="true"># user1阶段  </span><span class="token number">274</span><span class="token punctuation">.</span>            <span class="token comment" spellcheck="true"># 拿到user2加密的数据进行解密  </span><span class="token number">275</span><span class="token punctuation">.</span>            <span class="token comment" spellcheck="true"># 知道 k_G_x,k_G_y，key情况下，求解k_Q_x,k_Q_y是容易的，然后plain_text = cipher_text/k_Q_x  </span><span class="token number">276</span><span class="token punctuation">.</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\n1解密得到明文："</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span>  <span class="token number">277</span><span class="token punctuation">.</span>            <span class="token keyword">for</span> charArr <span class="token keyword">in</span> c<span class="token punctuation">:</span>  <span class="token number">278</span><span class="token punctuation">.</span>                decrypto_text_x<span class="token punctuation">,</span> decrypto_text_y <span class="token operator">=</span> get_ng<span class="token punctuation">(</span>charArr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> charArr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> a<span class="token punctuation">,</span> p<span class="token punctuation">)</span>  <span class="token number">279</span><span class="token punctuation">.</span>                <span class="token keyword">print</span><span class="token punctuation">(</span>chr<span class="token punctuation">(</span>charArr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">//</span> decrypto_text_x<span class="token punctuation">)</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span>  <span class="token number">280</span><span class="token punctuation">.</span>      <span class="token number">281</span><span class="token punctuation">.</span>    <span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>  <span class="token number">282</span><span class="token punctuation">.</span>        <span class="token comment" spellcheck="true">#调用函数,作为程序的入口,自定义程序运行顺序  </span><span class="token number">283</span><span class="token punctuation">.</span>        main<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token number">284</span><span class="token punctuation">.</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\n结束"</span><span class="token punctuation">)</span> </code></pre><p>以上便是本文所有内容了，如果喜欢请收藏本站</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ECC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kalma Filter学习笔记</title>
      <link href="/2020/02/20/kalma-filter/"/>
      <url>/2020/02/20/kalma-filter/</url>
      
        <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>Kalma Filter应用十分广泛，比如导航中</p><p>为什么要使用Kalma Filter呢？</p><p>因为我们生活中的系统存在许多不确定性：</p><ul><li>并不存在完美的数学模型</li><li>大部分的系统模型不可控，也很难建模</li><li>测量传感器自身存在误差</li></ul><p>如何来理解Kalma Filter呢？</p><p><img src="0.jpg" alt="举个栗子！"></p><p>让一个人去测量一枚硬币的大小，测量结果为Z_k</p><p>k意味第k次测量</p><p>假设测量结果为</p><p>Z_1 = 50.2mm</p><p>Z_2 = 50.1mm</p><p>Z_3 = 50.4mm</p><p>….</p><p>这时我们想要知道硬币真实的数据，只需要把所有数据加起来取平均值就可以了，公式如下，我们将他处理一下：</p><p><img src="1.png"></p><p>这里我们可以知道，当k越大，1/k越趋近于0</p><p><img src="2.png"></p><p>也就是说，当k足够大的时候，后续的测试结果就不那么重要了</p><p>我们继续处理这个式子变成如下：</p><p><img src="3.png" alt="①式"></p><p>我们来这么理解：</p><p>当前的估计值 = 上一次的估计值 + 系数 * （当前测量值 - 上一次的估计值）</p><p>而这个系数K就是卡尔曼增益（因数）</p><p>从这个式子里我们可以看到，新的估计值只与上一次的估计只有关，上一次的估计值又只与上上一次的估计值有关，这是一种递归</p><p>在卡尔曼中，你不需要很久以前的数据，只需要上一次的就足够了</p><p>这里我们引入一个新的概念：</p><p>估计误差：E_est  </p><p>测量误差：E_mea</p><p>E：Error</p><p>est：Estimate</p><p>mea：Measurement</p><p>而K就等于：</p><p><img src="4.png"></p><p>在k时刻，当E_est_k-1 &gt;&gt;  E_mea_k 时：K→1，①式变为：</p><p><img src="5.png"></p><p>意味当k-1时的估计误差远大于第k次的测量误差，那么我们的估计值X_k就很趋近于测量值Z_k</p><p>同样，在k时刻，当E_est_k-1 &lt;&lt;  E_mea_k 时：K→0，①式变为：</p><p><img src="6.png"></p><p>意味当我们的估计误差足够大的时候，我们选择更相信测量值</p><p>有了上面这些东西，我们就可以着手这个简单的问题了</p><ul><li>计算：<img src="4.png"></li><li>计算：<img src="7.png"></li><li>更新：<img src="8.png"></li></ul><p>有了这三个公式，让我们来试试下面这个问题：</p><p>有一个条度为<del>50mm</del>的线，我们想要知道它的确切长度，但幸运的是你的<del>测量误差</del>尺子十分的理想，你觉得它的误差为3mm，但不幸运的是你的<del>估计误差</del>估计很不准，有5mm的误差，这时我们想要知道这条线到底有多长，我们需要结合两个测量</p><p>假设我们得出了以下数据：</p><ul><li>第一次的估计值=40mm</li><li>估计误差5mm</li><li>第一次的测量值=51mm</li><li>测量误差3mm</li></ul><p>我们可以借助三个公式用Excel表格进行计算，数据输出如下：</p><p><img src="9.png"></p><p>将公式输入Excel表格并求解画出图像</p><p><img src="10.png"></p><p>可以看到当我们进行五次迭代以后，数据已经非常接近真实值，至此，前言结束，Excal公式如下，想动手的朋友可以自己去试试：</p><ul><li>计算部分从第三行开始，所以这里直接放公式</li><li>D3=D2+E3*(B3-D2)</li><li>E3=F2/(F2+C3)</li><li>F3=(1-E3)*F2</li></ul><h1 id="2-进阶部分"><a href="#2-进阶部分" class="headerlink" title="2 进阶部分"></a>2 进阶部分</h1><p>通过上述栗子我们可以大致了解到Kalman Filter基本思想，但也许有人会说上面的例子里直接数据求算数平均不是更快么？</p><p>确实，在一些比较普通的系统中，Kalman Filter的作用并没有那么明显，但在一些复杂系统中，Kalman Filter能发挥出更大的优势</p><p>回归正题，我们来看下面一个栗子<del>（数据融合）</del>：</p><p>如果我们想要知道一个物体的真实重量，那么我们最简单的办法就是找个秤称一下，但是如果一个称不准呢，那么我们可以再找一个秤，得到两个数据以及两个秤的标准差：</p><ul><li>Z_1 = 30g</li><li>Z_2 = 32g</li><li>σ_1 = 2g</li><li>σ_2 = 3g</li></ul><p><img src="11.png" alt="一个标准的正态分布图"></p><p>两个正态分布图会有交叉的部分，而如果我们想要知道真实的数据，那么这个真实的数据将会落在交叉的部分，并且会更靠近σ_1那部分</p><p><img src="12.png" alt="大概就是这个样子，画的不好见谅"></p><p>由此，我们写出一个公式估计真实值Z：</p><p><img src="13.png"></p><p>K依然是卡尔曼增益，在这里，我们需要求解K，使得方差最小</p><p><img src="14.png"></p><p>由方差的性质可以将这两个分开</p><p><img src="15.png"></p><p>将σ_1 =2g和 σ_2=3g带入</p><p>可以得到K=0.2</p><p>带入公式：</p><p><img src="13.png"></p><p>得出最优估计值Z=30.4g</p><p>可以计算出它的σ = 1.79</p><p>再来看一个例子<del>（协方差矩阵）方差协方差在一个矩阵中表现出来</del>：</p><p><img src="16.png"></p><hr><p>状态空间表达：</p><p><img src="17.png"></p><p>一个简单的栗子，弹簧系统的栗子，F是力，x位移，k弹性系数，B阻尼系数，m质量</p><p>得出方程：</p><p><img src="18.png"></p><p>将上面的公式用矩阵来表示：</p><p><img src="19.png"></p><p>我们可以将其归纳为：</p><p><img src="20.png"></p><p>这里的是连续形式，X(t)随时间变化</p><p>而我们也可以把它写成离散形式：</p><p><img src="21.png"></p><p>这里的下标k、k-1、k+1等都是时间单位</p><p>但现实世界中存在许多不确定性，我们现有的模型不能很好的反应实际情况，所以我们的模型需要改变一下：</p><p><img src="22.png"></p><p>这里的w_k-1和v_k分别代表过程噪音和测量噪音</p><p>一式计算结果</p><p>二试测量结果</p><p>这就是状态空间方程</p><hr><p>虽然过程噪声不可测量，但是我们可以用正态分布来表示</p><ul><li><p>P(w)~(0,Q)0期望，Q协方差矩阵</p></li><li><p>Q=E[w,w^T]</p></li><li><p><img src="23.png"></p></li></ul><p>同理，P(v)~(0,R)0期望，R协方差矩阵，推理过程一样，这里就不写了</p><hr><p>用数据融合的思想来处理一下我们的公式</p><p>先验：</p><p><img src="35.png"></p><p>后验：</p><p><img src="24.png"></p><p>X-_k为先验估计，K与误差大小息息相关K属于[0,H-]，为了量化误差，我们引入E_k</p><p><img src="25.png"></p><p>这里的x_k是真实值，X_k是估计值，化简的出：</p><p><img src="26.png"></p><p>将结果带入原式：</p><p><img src="27.png"></p><p><img src="28.png"></p><p>当测量结果误差小的时候，K_k=H-，当测量误差很大的时候，K_k=0，至此我们已经推导出卡尔曼增益系数K</p><hr><p><img src="29.png"></p><p><img src="30.png"></p><p>有了这个式子，我们就可利用卡尔曼滤波器来预测状态变量的值了</p><p>如此一来，我们总结一下我们所得到的式子将上面的X均带上帽子：</p><p><img src="31.png"></p><p><img src="32.png"></p><p>这就是卡尔曼滤波器的全部五个公式了</p><h1 id="3-示例"><a href="#3-示例" class="headerlink" title="3 示例"></a>3 示例</h1><p><img src="33.png"></p><p><img src="34.png"></p><p>大家可以自行使用这个例子代入合适的数据去计算结果，其中除手写部分均为Math Type输入截图，总结不易希望大家喜欢。</p><p>参考：<a href="https://www.bilibili.com/video/BV1ez4y1X7eR/?spm_id_from=333.788.videocard.2">https://www.bilibili.com/video/BV1ez4y1X7eR/?spm_id_from=333.788.videocard.2</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Kalma_Filter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kalma_Filter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何建立属于自己的博客</title>
      <link href="/2020/02/17/my-blog/"/>
      <url>/2020/02/17/my-blog/</url>
      
        <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>​        搭建博客的准备事项如下：  </p><ul><li>Hexo</li><li>Node.js</li></ul><ul><li><p>github账号，或者gitee账号</p><p>本次所使用环境为Windows，linux也可按照同样的方式安装，步骤略有不同   </p></li></ul><h1 id="2-环境准备以及软件安装工作"><a href="#2-环境准备以及软件安装工作" class="headerlink" title="2.环境准备以及软件安装工作"></a>2.环境准备以及软件安装工作</h1><h2 id="2-1-git"><a href="#2-1-git" class="headerlink" title="2.1 git"></a>2.1 git</h2><p>​        前往<a href="https://git-scm.com/download">官网</a>下载对应操作系统的Git版本，此处无脑下一步即可</p><p>​        安装完成之后使用win+r组合键打开运行，输入cmd回车进入命令行，输入git会弹出如下信息，此为安装成功</p><p>​    <img src="5-17-1.png"></p><h2 id="2-2-Node-js"><a href="#2-2-Node-js" class="headerlink" title="2.2 Node.js"></a>2.2 Node.js</h2><p>前往<a href="https://nodejs.org/zh-cn/">官网</a>下载长期支持版，此处无脑下一步即可</p><h2 id="2-3-Hexo"><a href="#2-3-Hexo" class="headerlink" title="2.3 Hexo"></a>2.3 Hexo</h2><p>Git和Node.js安装成功之后，需要创建一个用来存放博客的文件夹，在此创建名为blog的文件夹，此处命名按个人喜好，但不要是中文，下面就可以开始安装Hexo了</p><p>打开所创建文件夹，下文中均以blog指代，右键点击Git Bash Here<del>注 在Git Bash中不能使用传统Ctrl+V进行粘贴，建议右键粘贴</del></p><p><code>npm install -g hexo-cli</code></p><p><code>hexo init</code></p><p>注 此处hexo init是用git clone拉取远端文件，建议在执行这一步之前先尝试如下几个链接，若能成功打开即可直接执行hexo init，若不能打开，建议修改Hosts文件</p><ul><li><p><a href="https://github.com/">git官网</a></p></li><li><p><a href="https://github.com/mashirozx/Sakura">gitclone</a></p><p>第一个能打开，第二个点击下图中Download ZIP，若能下载，则跳过如下步骤直接hexo init即可</p><p><img src="5-17-4.png"></p><p>如果github官网打不开建议魔法上网，然后再试一次，若还是不行建议访问<a href="https://www.ipaddress.com/">这个地址</a></p><p><img src="5-17-2.png"></p><p>输入github.com回车</p><p><img src="5-17-3.png"></p><p>复制图中 IP Address后面的内容，找到C盘(系统盘)C:\Windows\System32\drivers\etc路径下的HOSTS文件<del>这个文件并没有后缀，有后缀的文件为电脑杀毒软件留下的副本用于恢复的，可以可以不用管</del></p><p>右键用记事本打开，在最后一行输入：</p><p><code>*** github.com</code></p><p>将你刚才复制的IP地址粘贴到这个***的位置并保存，如果手动输入，记得千万要在IP地址和网址中间加上空格，操作完成后win+r打开命令行，断开魔法上网，输入ipconfig回车，在输入ping github.com，若能ping通，则直接打开github.com即可</p><p>若第二个无法下载，同样访问<a href="https://www.ipaddress.com/">这个地址</a></p><p>输入：</p><p><code>codeload.github.com</code></p><p><code>raw.githubusercontent.com</code></p><p>并重复上面那个步骤，将IP地址填入HOSTS文件当中，命令行执行ipconfig，在尝试一次下载</p><hr><p>上述步骤完成后，在Git Bash中输入：</p><p><code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</code></p><p>组合命令，hexo clean是清除缓存，hexo g生成博客静态内容，hexo s本地预览</p><p>这里如果是第一次运行，可能要等的久一点，成功之后会有一句：</p><p><code>INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</code></p><p>复制其中localhost:4000到浏览器中粘贴并回车，进行预览，同时如果在文件夹内修改内容也会上传到你正在预览的网页中，只需要刷新就可更新出新内容，这里Ctrl+C可以推出预览</p><p>放一张成功之后的图:</p><p><img src="zan.png"></p><hr><p>但这个时候，我们的网站只能我们自己看得见，想让别人看见我们需要将它推送到云端上去，这里选择国内访问较快的gitee</p></li></ul><h2 id="2-4-gitee配置"><a href="#2-4-gitee配置" class="headerlink" title="2.4 gitee配置"></a>2.4 gitee配置</h2><p>​        上<a href="https://gitee.com/">gitee主页</a>注册账户</p><p>​        创建一个仓库：</p><p>​        <img src="5-17-5.png"></p><p>​        仓库名称为：仓库名称和路径都可以按照自己喜好（别是中文就好）</p><p>​        <img src="5-17-6.png"></p><p>​        生成之后会有一个路径，复制下来</p><p>​        我们转到我们的blog文件夹，打开文件夹下的_config.yml</p><p>​        在最后一行deploy中修改type和repo的值</p><p>​        <code>type: git</code></p><p>​        <code>repo: https://gitee.com/****    # 仓库的URL</code></p><p>​        修改之后保存，这时候我们需要安装插件，在Git Bash中输入以下内容一个一个执行</p><p>​        <code>npm install hexo-deployer-git --save    # 安装git插件</code></p><p>​        <code>git config --global user.email *********@qq.com    # 设置gitee邮箱（gitee的注册邮箱）</code></p><p>​        <code>git config --global user.name '****'    # 设置用户名（git的注册昵称）</code></p><p>​        <code>hexo d    # 上传到gitee</code></p><p>​        在上传的过程中可能会弹出让你从新输入账号以及密码的窗口，输入就好，这一步可能时间有些长，不用担心放着让他继续进行就好</p><p>​        上传成功后，仓库中会有你本地blog的内容</p><p>​        点击图中位置的Gitee pages</p><p>​        <img src="5-17-7.png"></p><p>​        输入图中内容点击更新</p><p>​        <img src="5-17-8.png"></p><p>​        这时候点击出现的网站地址就好，本次网站建立到此结束</p><hr><h2 id="2-5-需要注意的地方"><a href="#2-5-需要注意的地方" class="headerlink" title="2.5 需要注意的地方"></a>2.5 需要注意的地方</h2><ul><li>如果过程中出了问题，改不回来了，就直接干掉本地的blog文件夹，从头再来一遍即可</li><li>若是修改了本地文件预览通过了，上传之后，记得更新Gitee Pages服务，才能生成，若是还没有反应，直接shift+f5刷新即可</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
